/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub type gint8 = ::std::os::raw::c_schar;
pub type guint8 = ::std::os::raw::c_uchar;
pub type gint16 = ::std::os::raw::c_short;
pub type guint16 = ::std::os::raw::c_ushort;
pub type guint32 = ::std::os::raw::c_uint;
pub type gint64 = ::std::os::raw::c_long;
pub type guint64 = ::std::os::raw::c_ulong;
pub type gsize = ::std::os::raw::c_ulong;
pub type gchar = ::std::os::raw::c_char;
pub type gshort = ::std::os::raw::c_short;
pub type glong = ::std::os::raw::c_long;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type gulong = ::std::os::raw::c_ulong;
pub type guint = ::std::os::raw::c_uint;
pub type gfloat = f32;
pub type gdouble = f64;
pub type gpointer = *mut ::std::os::raw::c_void;
pub type GDestroyNotify =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GArray {
    pub data: *mut gchar,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GArray() {
    assert_eq!(::std::mem::size_of::<_GArray>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _GArray ) ));
    assert_eq! (::std::mem::align_of::<_GArray>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GArray ) ) . data as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GArray ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GArray ) ) . len as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GArray ) , "::" ,
                stringify ! ( len ) ));
}
impl Clone for _GArray {
    fn clone(&self) -> Self { *self }
}
pub type GArray = _GArray;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GPtrArray {
    pub pdata: *mut gpointer,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GPtrArray() {
    assert_eq!(::std::mem::size_of::<_GPtrArray>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _GPtrArray ) ));
    assert_eq! (::std::mem::align_of::<_GPtrArray>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GPtrArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GPtrArray ) ) . pdata as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GPtrArray ) , "::" ,
                stringify ! ( pdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GPtrArray ) ) . len as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GPtrArray ) , "::" ,
                stringify ! ( len ) ));
}
impl Clone for _GPtrArray {
    fn clone(&self) -> Self { *self }
}
pub type GPtrArray = _GPtrArray;
pub type GQuark = guint32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GError {
    pub domain: GQuark,
    pub code: gint,
    pub message: *mut gchar,
}
#[test]
fn bindgen_test_layout__GError() {
    assert_eq!(::std::mem::size_of::<_GError>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _GError ) ));
    assert_eq! (::std::mem::align_of::<_GError>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GError ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GError ) ) . domain as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GError ) , "::" ,
                stringify ! ( domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GError ) ) . code as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _GError ) , "::" ,
                stringify ! ( code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GError ) ) . message as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GError ) , "::" ,
                stringify ! ( message ) ));
}
impl Clone for _GError {
    fn clone(&self) -> Self { *self }
}
/**
 * GError:
 * @domain: error domain, e.g. #G_FILE_ERROR
 * @code: error code, e.g. %G_FILE_ERROR_NOENT
 * @message: human-readable informative error message
 *
 * The `GError` structure contains information about
 * an error that has occurred.
 */
pub type GError = _GError;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GData {
    _unused: [u8; 0],
}
pub type GData = _GData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDateTime {
    _unused: [u8; 0],
}
/**
 * GDateTime:
 *
 * `GDateTime` is an opaque structure whose members
 * cannot be accessed directly.
 *
 * Since: 2.26
 */
pub type GDateTime = _GDateTime;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}
#[test]
fn bindgen_test_layout__GList() {
    assert_eq!(::std::mem::size_of::<_GList>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _GList ) ));
    assert_eq! (::std::mem::align_of::<_GList>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GList ) ) . data as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GList ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GList ) ) . next as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GList ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GList ) ) . prev as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GList ) , "::" ,
                stringify ! ( prev ) ));
}
impl Clone for _GList {
    fn clone(&self) -> Self { *self }
}
pub type GList = _GList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTable {
    _unused: [u8; 0],
}
pub type GHashTable = _GHashTable;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GSList {
    pub data: gpointer,
    pub next: *mut GSList,
}
#[test]
fn bindgen_test_layout__GSList() {
    assert_eq!(::std::mem::size_of::<_GSList>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _GSList ) ));
    assert_eq! (::std::mem::align_of::<_GSList>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GSList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GSList ) ) . data as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GSList ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GSList ) ) . next as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GSList ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for _GSList {
    fn clone(&self) -> Self { *self }
}
pub type GSList = _GSList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariant {
    _unused: [u8; 0],
}
pub type GVariant = _GVariant;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GVariantBuilder {
    pub x: [gsize; 16usize],
}
#[test]
fn bindgen_test_layout__GVariantBuilder() {
    assert_eq!(::std::mem::size_of::<_GVariantBuilder>() , 128usize , concat !
               ( "Size of: " , stringify ! ( _GVariantBuilder ) ));
    assert_eq! (::std::mem::align_of::<_GVariantBuilder>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _GVariantBuilder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GVariantBuilder ) ) . x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GVariantBuilder ) ,
                "::" , stringify ! ( x ) ));
}
impl Clone for _GVariantBuilder {
    fn clone(&self) -> Self { *self }
}
pub type GVariantBuilder = _GVariantBuilder;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GVariantDict {
    pub x: [gsize; 16usize],
}
#[test]
fn bindgen_test_layout__GVariantDict() {
    assert_eq!(::std::mem::size_of::<_GVariantDict>() , 128usize , concat ! (
               "Size of: " , stringify ! ( _GVariantDict ) ));
    assert_eq! (::std::mem::align_of::<_GVariantDict>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GVariantDict ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GVariantDict ) ) . x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GVariantDict ) , "::"
                , stringify ! ( x ) ));
}
impl Clone for _GVariantDict {
    fn clone(&self) -> Self { *self }
}
pub type GVariantDict = _GVariantDict;
pub type GType = gsize;
/**
 * GValue:
 * 
 * An opaque structure used to hold different types of values.
 * The data within the structure has protected scope: it is accessible only
 * to functions within a #GTypeValueTable structure, or implementations of
 * the g_value_*() API. That is, code portions which implement new fundamental
 * types.
 * #GValue users cannot make any assumptions about how data is stored
 * within the 2 element @data union, and the @g_type member should
 * only be accessed through the G_VALUE_TYPE() macro.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GValue {
    pub g_type: GType,
    pub data: [_GValue__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GValue__bindgen_ty_1 {
    pub v_int: __BindgenUnionField<gint>,
    pub v_uint: __BindgenUnionField<guint>,
    pub v_long: __BindgenUnionField<glong>,
    pub v_ulong: __BindgenUnionField<gulong>,
    pub v_int64: __BindgenUnionField<gint64>,
    pub v_uint64: __BindgenUnionField<guint64>,
    pub v_float: __BindgenUnionField<gfloat>,
    pub v_double: __BindgenUnionField<gdouble>,
    pub v_pointer: __BindgenUnionField<gpointer>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__GValue__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_GValue__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( _GValue__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<_GValue__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GValue__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GValue__bindgen_ty_1 ) ) . v_int as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GValue__bindgen_ty_1 )
                , "::" , stringify ! ( v_int ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GValue__bindgen_ty_1 ) ) . v_uint as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GValue__bindgen_ty_1 )
                , "::" , stringify ! ( v_uint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GValue__bindgen_ty_1 ) ) . v_long as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GValue__bindgen_ty_1 )
                , "::" , stringify ! ( v_long ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GValue__bindgen_ty_1 ) ) . v_ulong as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GValue__bindgen_ty_1 )
                , "::" , stringify ! ( v_ulong ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GValue__bindgen_ty_1 ) ) . v_int64 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GValue__bindgen_ty_1 )
                , "::" , stringify ! ( v_int64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GValue__bindgen_ty_1 ) ) . v_uint64 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GValue__bindgen_ty_1 )
                , "::" , stringify ! ( v_uint64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GValue__bindgen_ty_1 ) ) . v_float as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GValue__bindgen_ty_1 )
                , "::" , stringify ! ( v_float ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GValue__bindgen_ty_1 ) ) . v_double as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GValue__bindgen_ty_1 )
                , "::" , stringify ! ( v_double ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GValue__bindgen_ty_1 ) ) . v_pointer as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GValue__bindgen_ty_1 )
                , "::" , stringify ! ( v_pointer ) ));
}
impl Clone for _GValue__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__GValue() {
    assert_eq!(::std::mem::size_of::<_GValue>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _GValue ) ));
    assert_eq! (::std::mem::align_of::<_GValue>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GValue ) ) . g_type as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GValue ) , "::" ,
                stringify ! ( g_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GValue ) ) . data as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GValue ) , "::" ,
                stringify ! ( data ) ));
}
impl Clone for _GValue {
    fn clone(&self) -> Self { *self }
}
pub type GValue = _GValue;
/**
 * GTypeClass:
 * 
 * An opaque structure used as the base of all classes.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GTypeClass {
    pub g_type: GType,
}
#[test]
fn bindgen_test_layout__GTypeClass() {
    assert_eq!(::std::mem::size_of::<_GTypeClass>() , 8usize , concat ! (
               "Size of: " , stringify ! ( _GTypeClass ) ));
    assert_eq! (::std::mem::align_of::<_GTypeClass>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GTypeClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GTypeClass ) ) . g_type as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GTypeClass ) , "::" ,
                stringify ! ( g_type ) ));
}
impl Clone for _GTypeClass {
    fn clone(&self) -> Self { *self }
}
pub type GTypeClass = _GTypeClass;
/**
 * GTypeInterface:
 * 
 * An opaque structure used as the base of all interface types.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GTypeInterface {
    pub g_type: GType,
    pub g_instance_type: GType,
}
#[test]
fn bindgen_test_layout__GTypeInterface() {
    assert_eq!(::std::mem::size_of::<_GTypeInterface>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _GTypeInterface ) ));
    assert_eq! (::std::mem::align_of::<_GTypeInterface>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _GTypeInterface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GTypeInterface ) ) . g_type as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GTypeInterface ) ,
                "::" , stringify ! ( g_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GTypeInterface ) ) . g_instance_type as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GTypeInterface ) ,
                "::" , stringify ! ( g_instance_type ) ));
}
impl Clone for _GTypeInterface {
    fn clone(&self) -> Self { *self }
}
pub type GTypeInterface = _GTypeInterface;
/**
 * GTypeInstance:
 * 
 * An opaque structure used as the base of all type instances.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GTypeInstance {
    pub g_class: *mut GTypeClass,
}
#[test]
fn bindgen_test_layout__GTypeInstance() {
    assert_eq!(::std::mem::size_of::<_GTypeInstance>() , 8usize , concat ! (
               "Size of: " , stringify ! ( _GTypeInstance ) ));
    assert_eq! (::std::mem::align_of::<_GTypeInstance>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GTypeInstance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GTypeInstance ) ) . g_class as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GTypeInstance ) , "::"
                , stringify ! ( g_class ) ));
}
impl Clone for _GTypeInstance {
    fn clone(&self) -> Self { *self }
}
pub type GTypeInstance = _GTypeInstance;
pub const GParamFlags_G_PARAM_PRIVATE: GParamFlags =
    GParamFlags::G_PARAM_STATIC_NAME;
#[repr(i32)]
/**
 * GParamFlags:
 * @G_PARAM_READABLE: the parameter is readable
 * @G_PARAM_WRITABLE: the parameter is writable
 * @G_PARAM_READWRITE: alias for %G_PARAM_READABLE | %G_PARAM_WRITABLE
 * @G_PARAM_CONSTRUCT: the parameter will be set upon object construction
 * @G_PARAM_CONSTRUCT_ONLY: the parameter can only be set upon object construction
 * @G_PARAM_LAX_VALIDATION: upon parameter conversion (see g_param_value_convert())
 *  strict validation is not required
 * @G_PARAM_STATIC_NAME: the string used as name when constructing the 
 *  parameter is guaranteed to remain valid and
 *  unmodified for the lifetime of the parameter. 
 *  Since 2.8
 * @G_PARAM_STATIC_NICK: the string used as nick when constructing the
 *  parameter is guaranteed to remain valid and
 *  unmmodified for the lifetime of the parameter.
 *  Since 2.8
 * @G_PARAM_STATIC_BLURB: the string used as blurb when constructing the 
 *  parameter is guaranteed to remain valid and 
 *  unmodified for the lifetime of the parameter. 
 *  Since 2.8
 * @G_PARAM_EXPLICIT_NOTIFY: calls to g_object_set_property() for this
 *   property will not automatically result in a "notify" signal being
 *   emitted: the implementation must call g_object_notify() themselves
 *   in case the property actually changes.  Since: 2.42.
 * @G_PARAM_PRIVATE: internal
 * @G_PARAM_DEPRECATED: the parameter is deprecated and will be removed
 *  in a future version. A warning will be generated if it is used
 *  while running with G_ENABLE_DIAGNOSTIC=1.
 *  Since 2.26
 * 
 * Through the #GParamFlags flag values, certain aspects of parameters
 * can be configured. See also #G_PARAM_STATIC_STRINGS.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GParamFlags {
    G_PARAM_READABLE = 1,
    G_PARAM_WRITABLE = 2,
    G_PARAM_READWRITE = 3,
    G_PARAM_CONSTRUCT = 4,
    G_PARAM_CONSTRUCT_ONLY = 8,
    G_PARAM_LAX_VALIDATION = 16,
    G_PARAM_STATIC_NAME = 32,
    G_PARAM_STATIC_NICK = 64,
    G_PARAM_STATIC_BLURB = 128,
    G_PARAM_EXPLICIT_NOTIFY = 1073741824,
    G_PARAM_DEPRECATED = -2147483648,
}
/**
 * GParamSpec: (ref-func g_param_spec_ref_sink) (unref-func g_param_spec_uref) (set-value-func g_value_set_param) (get-value-func g_value_get_param)
 * @g_type_instance: private #GTypeInstance portion
 * @name: name of this parameter: always an interned string
 * @flags: #GParamFlags flags for this parameter
 * @value_type: the #GValue type for this parameter
 * @owner_type: #GType type that uses (introduces) this parameter
 * 
 * All other fields of the GParamSpec struct are private and
 * should not be used directly.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GParamSpec {
    pub g_type_instance: GTypeInstance,
    pub name: *const gchar,
    pub flags: GParamFlags,
    pub value_type: GType,
    pub owner_type: GType,
    pub _nick: *mut gchar,
    pub _blurb: *mut gchar,
    pub qdata: *mut GData,
    pub ref_count: guint,
    pub param_id: guint,
}
#[test]
fn bindgen_test_layout__GParamSpec() {
    assert_eq!(::std::mem::size_of::<_GParamSpec>() , 72usize , concat ! (
               "Size of: " , stringify ! ( _GParamSpec ) ));
    assert_eq! (::std::mem::align_of::<_GParamSpec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GParamSpec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GParamSpec ) ) . g_type_instance as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GParamSpec ) , "::" ,
                stringify ! ( g_type_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GParamSpec ) ) . name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GParamSpec ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GParamSpec ) ) . flags as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GParamSpec ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GParamSpec ) ) . value_type as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GParamSpec ) , "::" ,
                stringify ! ( value_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GParamSpec ) ) . owner_type as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _GParamSpec ) , "::" ,
                stringify ! ( owner_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GParamSpec ) ) . _nick as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _GParamSpec ) , "::" ,
                stringify ! ( _nick ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GParamSpec ) ) . _blurb as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _GParamSpec ) , "::" ,
                stringify ! ( _blurb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GParamSpec ) ) . qdata as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _GParamSpec ) , "::" ,
                stringify ! ( qdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GParamSpec ) ) . ref_count as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _GParamSpec ) , "::" ,
                stringify ! ( ref_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GParamSpec ) ) . param_id as * const _
                as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( _GParamSpec ) , "::" ,
                stringify ! ( param_id ) ));
}
impl Clone for _GParamSpec {
    fn clone(&self) -> Self { *self }
}
pub type GParamSpec = _GParamSpec;
/**
 * GObject:
 * 
 * All the fields in the GObject structure are private 
 * to the #GObject implementation and should never be accessed directly.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GObject {
    pub g_type_instance: GTypeInstance,
    pub ref_count: guint,
    pub qdata: *mut GData,
}
#[test]
fn bindgen_test_layout__GObject() {
    assert_eq!(::std::mem::size_of::<_GObject>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _GObject ) ));
    assert_eq! (::std::mem::align_of::<_GObject>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GObject ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GObject ) ) . g_type_instance as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GObject ) , "::" ,
                stringify ! ( g_type_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GObject ) ) . ref_count as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GObject ) , "::" ,
                stringify ! ( ref_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GObject ) ) . qdata as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GObject ) , "::" ,
                stringify ! ( qdata ) ));
}
impl Clone for _GObject {
    fn clone(&self) -> Self { *self }
}
pub type GObject = _GObject;
/**
 * GObjectClass:
 * @g_type_class: the parent class
 * @constructor: the @constructor function is called by g_object_new () to 
 *  complete the object initialization after all the construction properties are
 *  set. The first thing a @constructor implementation must do is chain up to the
 *  @constructor of the parent class. Overriding @constructor should be rarely 
 *  needed, e.g. to handle construct properties, or to implement singletons.
 * @set_property: the generic setter for all properties of this type. Should be
 *  overridden for every type with properties. If implementations of
 *  @set_property don't emit property change notification explicitly, this will
 *  be done implicitly by the type system. However, if the notify signal is
 *  emitted explicitly, the type system will not emit it a second time.
 * @get_property: the generic getter for all properties of this type. Should be
 *  overridden for every type with properties.
 * @dispose: the @dispose function is supposed to drop all references to other 
 *  objects, but keep the instance otherwise intact, so that client method 
 *  invocations still work. It may be run multiple times (due to reference 
 *  loops). Before returning, @dispose should chain up to the @dispose method 
 *  of the parent class.
 * @finalize: instance finalization function, should finish the finalization of 
 *  the instance begun in @dispose and chain up to the @finalize method of the 
 *  parent class.
 * @dispatch_properties_changed: emits property change notification for a bunch
 *  of properties. Overriding @dispatch_properties_changed should be rarely 
 *  needed.
 * @notify: the class closure for the notify signal
 * @constructed: the @constructed function is called by g_object_new() as the
 *  final step of the object creation process.  At the point of the call, all
 *  construction properties have been set on the object.  The purpose of this
 *  call is to allow for object initialisation steps that can only be performed
 *  after construction properties have been set.  @constructed implementors
 *  should chain up to the @constructed call of their parent class to allow it
 *  to complete its initialisation.
 * 
 * The class structure for the GObject type.
 * 
 * <example>
 * <title>Implementing singletons using a constructor</title>
 * <programlisting>
 * static MySingleton *the_singleton = NULL;
 * 
 * static GObject*
 * my_singleton_constructor (GType                  type,
 *                           guint                  n_construct_params,
 *                           GObjectConstructParam *construct_params)
 * {
 *   GObject *object;
 *   
 *   if (!the_singleton)
 *     {
 *       object = G_OBJECT_CLASS (parent_class)->constructor (type,
 *                                                            n_construct_params,
 *                                                            construct_params);
 *       the_singleton = MY_SINGLETON (object);
 *     }
 *   else
 *     object = g_object_ref (G_OBJECT (the_singleton));
 * 
 *   return object;
 * }
 * </programlisting></example>
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GObjectClass {
    pub g_type_class: GTypeClass,
    pub construct_properties: *mut GSList,
    pub constructor: ::std::option::Option<unsafe extern "C" fn(type_: GType,
                                                                n_construct_properties:
                                                                    guint,
                                                                construct_properties:
                                                                    *mut GObjectConstructParam)
                                               -> *mut GObject>,
    pub set_property: ::std::option::Option<unsafe extern "C" fn(object:
                                                                     *mut GObject,
                                                                 property_id:
                                                                     guint,
                                                                 value:
                                                                     *const GValue,
                                                                 pspec:
                                                                     *mut GParamSpec)>,
    pub get_property: ::std::option::Option<unsafe extern "C" fn(object:
                                                                     *mut GObject,
                                                                 property_id:
                                                                     guint,
                                                                 value:
                                                                     *mut GValue,
                                                                 pspec:
                                                                     *mut GParamSpec)>,
    pub dispose: ::std::option::Option<unsafe extern "C" fn(object:
                                                                *mut GObject)>,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(object:
                                                                 *mut GObject)>,
    pub dispatch_properties_changed: ::std::option::Option<unsafe extern "C" fn(object:
                                                                                    *mut GObject,
                                                                                n_pspecs:
                                                                                    guint,
                                                                                pspecs:
                                                                                    *mut *mut GParamSpec)>,
    pub notify: ::std::option::Option<unsafe extern "C" fn(object:
                                                               *mut GObject,
                                                           pspec:
                                                               *mut GParamSpec)>,
    pub constructed: ::std::option::Option<unsafe extern "C" fn(object:
                                                                    *mut GObject)>,
    pub flags: gsize,
    pub pdummy: [gpointer; 6usize],
}
#[test]
fn bindgen_test_layout__GObjectClass() {
    assert_eq!(::std::mem::size_of::<_GObjectClass>() , 136usize , concat ! (
               "Size of: " , stringify ! ( _GObjectClass ) ));
    assert_eq! (::std::mem::align_of::<_GObjectClass>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GObjectClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GObjectClass ) ) . g_type_class as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GObjectClass ) , "::"
                , stringify ! ( g_type_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GObjectClass ) ) . construct_properties
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GObjectClass ) , "::"
                , stringify ! ( construct_properties ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GObjectClass ) ) . constructor as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GObjectClass ) , "::"
                , stringify ! ( constructor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GObjectClass ) ) . set_property as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GObjectClass ) , "::"
                , stringify ! ( set_property ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GObjectClass ) ) . get_property as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _GObjectClass ) , "::"
                , stringify ! ( get_property ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GObjectClass ) ) . dispose as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _GObjectClass ) , "::"
                , stringify ! ( dispose ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GObjectClass ) ) . finalize as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _GObjectClass ) , "::"
                , stringify ! ( finalize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GObjectClass ) ) .
                dispatch_properties_changed as * const _ as usize } , 56usize
                , concat ! (
                "Alignment of field: " , stringify ! ( _GObjectClass ) , "::"
                , stringify ! ( dispatch_properties_changed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GObjectClass ) ) . notify as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _GObjectClass ) , "::"
                , stringify ! ( notify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GObjectClass ) ) . constructed as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _GObjectClass ) , "::"
                , stringify ! ( constructed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GObjectClass ) ) . flags as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _GObjectClass ) , "::"
                , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GObjectClass ) ) . pdummy as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _GObjectClass ) , "::"
                , stringify ! ( pdummy ) ));
}
impl Clone for _GObjectClass {
    fn clone(&self) -> Self { *self }
}
pub type GObjectClass = _GObjectClass;
pub type GInitiallyUnowned = _GObject;
pub type GInitiallyUnownedClass = _GObjectClass;
/**
 * GObjectConstructParam:
 * @pspec: the #GParamSpec of the construct parameter
 * @value: the value to set the parameter to
 * 
 * The GObjectConstructParam struct is an auxiliary 
 * structure used to hand #GParamSpec/#GValue pairs to the @constructor of
 * a #GObjectClass.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GObjectConstructParam {
    pub pspec: *mut GParamSpec,
    pub value: *mut GValue,
}
#[test]
fn bindgen_test_layout__GObjectConstructParam() {
    assert_eq!(::std::mem::size_of::<_GObjectConstructParam>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( _GObjectConstructParam )
               ));
    assert_eq! (::std::mem::align_of::<_GObjectConstructParam>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GObjectConstructParam ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GObjectConstructParam ) ) . pspec as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GObjectConstructParam
                ) , "::" , stringify ! ( pspec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GObjectConstructParam ) ) . value as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GObjectConstructParam
                ) , "::" , stringify ! ( value ) ));
}
impl Clone for _GObjectConstructParam {
    fn clone(&self) -> Self { *self }
}
pub type GObjectConstructParam = _GObjectConstructParam;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GApplication {
    pub parent_instance: GObject,
    pub priv_: *mut GApplicationPrivate,
}
#[test]
fn bindgen_test_layout__GApplication() {
    assert_eq!(::std::mem::size_of::<_GApplication>() , 32usize , concat ! (
               "Size of: " , stringify ! ( _GApplication ) ));
    assert_eq! (::std::mem::align_of::<_GApplication>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GApplication ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GApplication ) ) . parent_instance as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GApplication ) , "::"
                , stringify ! ( parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GApplication ) ) . priv_ as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GApplication ) , "::"
                , stringify ! ( priv_ ) ));
}
impl Clone for _GApplication {
    fn clone(&self) -> Self { *self }
}
pub type GApplication = _GApplication;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GApplicationCommandLine {
    pub parent_instance: GObject,
    pub priv_: *mut GApplicationCommandLinePrivate,
}
#[test]
fn bindgen_test_layout__GApplicationCommandLine() {
    assert_eq!(::std::mem::size_of::<_GApplicationCommandLine>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( _GApplicationCommandLine ) ));
    assert_eq! (::std::mem::align_of::<_GApplicationCommandLine>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GApplicationCommandLine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GApplicationCommandLine ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GApplicationCommandLine ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GApplicationCommandLine ) ) . priv_ as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GApplicationCommandLine ) , "::" , stringify ! ( priv_ ) ));
}
impl Clone for _GApplicationCommandLine {
    fn clone(&self) -> Self { *self }
}
pub type GApplicationCommandLine = _GApplicationCommandLine;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettingsBackend {
    _unused: [u8; 0],
}
pub type GSettingsBackend = _GSettingsBackend;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GSettings {
    pub parent_instance: GObject,
    pub priv_: *mut GSettingsPrivate,
}
#[test]
fn bindgen_test_layout__GSettings() {
    assert_eq!(::std::mem::size_of::<_GSettings>() , 32usize , concat ! (
               "Size of: " , stringify ! ( _GSettings ) ));
    assert_eq! (::std::mem::align_of::<_GSettings>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GSettings ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GSettings ) ) . parent_instance as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GSettings ) , "::" ,
                stringify ! ( parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GSettings ) ) . priv_ as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GSettings ) , "::" ,
                stringify ! ( priv_ ) ));
}
impl Clone for _GSettings {
    fn clone(&self) -> Self { *self }
}
pub type GSettings = _GSettings;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFile {
    _unused: [u8; 0],
}
/**
 * GFile:
 *
 * A handle to an object implementing the #GFileIface interface.
 * Generally stores a location within the file system. Handles do not
 * necessarily represent files or directories that currently exist.
 **/
pub type GFile = _GFile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIcon {
    _unused: [u8; 0],
}
pub type GIcon = _GIcon;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusConnection {
    _unused: [u8; 0],
}
pub type GDBusConnection = _GDBusConnection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GApplicationPrivate {
    _unused: [u8; 0],
}
pub type GApplicationPrivate = _GApplicationPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GApplicationClass {
    pub parent_class: GObjectClass,
    pub startup: ::std::option::Option<unsafe extern "C" fn(application:
                                                                *mut GApplication)>,
    pub activate: ::std::option::Option<unsafe extern "C" fn(application:
                                                                 *mut GApplication)>,
    pub open: ::std::option::Option<unsafe extern "C" fn(application:
                                                             *mut GApplication,
                                                         files:
                                                             *mut *mut GFile,
                                                         n_files: gint,
                                                         hint: *const gchar)>,
    pub command_line: ::std::option::Option<unsafe extern "C" fn(application:
                                                                     *mut GApplication,
                                                                 command_line:
                                                                     *mut GApplicationCommandLine)
                                                -> ::std::os::raw::c_int>,
    /**
   * GApplicationClass::local_command_line:
   * @application: a #GApplication
   * @arguments: (inout) (array zero-terminated=1): array of command line arguments
   * @exit_status: (out): exit status to fill after processing the command line.
   *
   * This virtual function is always invoked in the local instance. It
   * gets passed a pointer to a %NULL-terminated copy of @argv and is
   * expected to remove arguments that it handled (shifting up remaining
   * arguments).
   *
   * The last argument to local_command_line() is a pointer to the @status
   * variable which can used to set the exit status that is returned from
   * g_application_run().
   *
   * See g_application_run() for more details on #GApplication startup.
   *
   * Returns: %TRUE if the commandline has been completely handled
   */
    pub local_command_line: ::std::option::Option<unsafe extern "C" fn(application:
                                                                           *mut GApplication,
                                                                       arguments:
                                                                           *mut *mut *mut gchar,
                                                                       exit_status:
                                                                           *mut ::std::os::raw::c_int)
                                                      -> gboolean>,
    pub before_emit: ::std::option::Option<unsafe extern "C" fn(application:
                                                                    *mut GApplication,
                                                                platform_data:
                                                                    *mut GVariant)>,
    pub after_emit: ::std::option::Option<unsafe extern "C" fn(application:
                                                                   *mut GApplication,
                                                               platform_data:
                                                                   *mut GVariant)>,
    pub add_platform_data: ::std::option::Option<unsafe extern "C" fn(application:
                                                                          *mut GApplication,
                                                                      builder:
                                                                          *mut GVariantBuilder)>,
    pub quit_mainloop: ::std::option::Option<unsafe extern "C" fn(application:
                                                                      *mut GApplication)>,
    pub run_mainloop: ::std::option::Option<unsafe extern "C" fn(application:
                                                                     *mut GApplication)>,
    pub shutdown: ::std::option::Option<unsafe extern "C" fn(application:
                                                                 *mut GApplication)>,
    pub dbus_register: ::std::option::Option<unsafe extern "C" fn(application:
                                                                      *mut GApplication,
                                                                  connection:
                                                                      *mut GDBusConnection,
                                                                  object_path:
                                                                      *const gchar,
                                                                  error:
                                                                      *mut *mut GError)
                                                 -> gboolean>,
    pub dbus_unregister: ::std::option::Option<unsafe extern "C" fn(application:
                                                                        *mut GApplication,
                                                                    connection:
                                                                        *mut GDBusConnection,
                                                                    object_path:
                                                                        *const gchar)>,
    pub handle_local_options: ::std::option::Option<unsafe extern "C" fn(application:
                                                                             *mut GApplication,
                                                                         options:
                                                                             *mut GVariantDict)
                                                        -> gint>,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GApplicationClass() {
    assert_eq!(::std::mem::size_of::<_GApplicationClass>() , 312usize , concat
               ! ( "Size of: " , stringify ! ( _GApplicationClass ) ));
    assert_eq! (::std::mem::align_of::<_GApplicationClass>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _GApplicationClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GApplicationClass ) ) . parent_class as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GApplicationClass ) ,
                "::" , stringify ! ( parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GApplicationClass ) ) . startup as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( _GApplicationClass ) ,
                "::" , stringify ! ( startup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GApplicationClass ) ) . activate as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( _GApplicationClass ) ,
                "::" , stringify ! ( activate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GApplicationClass ) ) . open as * const
                _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( _GApplicationClass ) ,
                "::" , stringify ! ( open ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GApplicationClass ) ) . command_line as
                * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _GApplicationClass ) ,
                "::" , stringify ! ( command_line ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GApplicationClass ) ) .
                local_command_line as * const _ as usize } , 168usize , concat
                ! (
                "Alignment of field: " , stringify ! ( _GApplicationClass ) ,
                "::" , stringify ! ( local_command_line ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GApplicationClass ) ) . before_emit as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( _GApplicationClass ) ,
                "::" , stringify ! ( before_emit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GApplicationClass ) ) . after_emit as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( _GApplicationClass ) ,
                "::" , stringify ! ( after_emit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GApplicationClass ) ) .
                add_platform_data as * const _ as usize } , 192usize , concat
                ! (
                "Alignment of field: " , stringify ! ( _GApplicationClass ) ,
                "::" , stringify ! ( add_platform_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GApplicationClass ) ) . quit_mainloop as
                * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( _GApplicationClass ) ,
                "::" , stringify ! ( quit_mainloop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GApplicationClass ) ) . run_mainloop as
                * const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( _GApplicationClass ) ,
                "::" , stringify ! ( run_mainloop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GApplicationClass ) ) . shutdown as *
                const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( _GApplicationClass ) ,
                "::" , stringify ! ( shutdown ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GApplicationClass ) ) . dbus_register as
                * const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( _GApplicationClass ) ,
                "::" , stringify ! ( dbus_register ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GApplicationClass ) ) . dbus_unregister
                as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( _GApplicationClass ) ,
                "::" , stringify ! ( dbus_unregister ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GApplicationClass ) ) .
                handle_local_options as * const _ as usize } , 240usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _GApplicationClass ) ,
                "::" , stringify ! ( handle_local_options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GApplicationClass ) ) . padding as *
                const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( _GApplicationClass ) ,
                "::" , stringify ! ( padding ) ));
}
impl Clone for _GApplicationClass {
    fn clone(&self) -> Self { *self }
}
pub type GApplicationClass = _GApplicationClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GApplicationCommandLinePrivate {
    _unused: [u8; 0],
}
pub type GApplicationCommandLinePrivate = _GApplicationCommandLinePrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettingsPrivate {
    _unused: [u8; 0],
}
pub type GSettingsPrivate = _GSettingsPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PangoFontDescription {
    _unused: [u8; 0],
}
/**
 * PangoFontDescription:
 *
 * The #PangoFontDescription structure represents the description
 * of an ideal font. These structures are used both to list
 * what fonts are available on the system and also for specifying
 * the characteristics of a font to load.
 */
pub type PangoFontDescription = _PangoFontDescription;
#[repr(u32)]
/**
 * PangoEllipsizeMode:
 * @PANGO_ELLIPSIZE_NONE: No ellipsization
 * @PANGO_ELLIPSIZE_START: Omit characters at the start of the text
 * @PANGO_ELLIPSIZE_MIDDLE: Omit characters in the middle of the text
 * @PANGO_ELLIPSIZE_END: Omit characters at the end of the text
 *
 * The #PangoEllipsizeMode type describes what sort of (if any)
 * ellipsization should be applied to a line of text. In
 * the ellipsization process characters are removed from the
 * text in order to make it fit to a given width and replaced
 * with an ellipsis.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum PangoEllipsizeMode {
    PANGO_ELLIPSIZE_NONE = 0,
    PANGO_ELLIPSIZE_START = 1,
    PANGO_ELLIPSIZE_MIDDLE = 2,
    PANGO_ELLIPSIZE_END = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo {
    _unused: [u8; 0],
}
/**
 * cairo_t:
 *
 * A #cairo_t contains the current state of the rendering device,
 * including coordinates of yet to be drawn shapes.
 *
 * Cairo contexts, as #cairo_t objects are named, are central to
 * cairo and all drawing with cairo is always done to a #cairo_t
 * object.
 *
 * Memory management of #cairo_t is done with
 * cairo_reference() and cairo_destroy().
 *
 * Since: 1.0
 **/
pub type cairo_t = _cairo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo_surface {
    _unused: [u8; 0],
}
/**
 * cairo_surface_t:
 *
 * A #cairo_surface_t represents an image, either as the destination
 * of a drawing operation or as source when drawing onto another
 * surface.  To draw to a #cairo_surface_t, create a cairo context
 * with the surface as the target, using cairo_create().
 *
 * There are different subtypes of #cairo_surface_t for
 * different drawing backends; for example, cairo_image_surface_create()
 * creates a bitmap image in memory.
 * The type of a surface can be queried with cairo_surface_get_type().
 *
 * The initial contents of a surface after creation depend upon the manner
 * of its creation. If cairo creates the surface and backing storage for
 * the user, it will be initially cleared; for example,
 * cairo_image_surface_create() and cairo_surface_create_similar().
 * Alternatively, if the user passes in a reference to some backing storage
 * and asks cairo to wrap that in a #cairo_surface_t, then the contents are
 * not modified; for example, cairo_image_surface_create_for_data() and
 * cairo_xlib_surface_create().
 *
 * Memory management of #cairo_surface_t is done with
 * cairo_surface_reference() and cairo_surface_destroy().
 *
 * Since: 1.0
 **/
pub type cairo_surface_t = _cairo_surface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo_pattern {
    _unused: [u8; 0],
}
/**
 * cairo_pattern_t:
 *
 * A #cairo_pattern_t represents a source when drawing onto a
 * surface. There are different subtypes of #cairo_pattern_t,
 * for different types of sources; for example,
 * cairo_pattern_create_rgb() creates a pattern for a solid
 * opaque color.
 *
 * Other than various
 * <function>cairo_pattern_create_<emphasis>type</emphasis>()</function>
 * functions, some of the pattern types can be implicitly created using various
 * <function>cairo_set_source_<emphasis>type</emphasis>()</function> functions;
 * for example cairo_set_source_rgb().
 *
 * The type of a pattern can be queried with cairo_pattern_get_type().
 *
 * Memory management of #cairo_pattern_t is done with
 * cairo_pattern_reference() and cairo_pattern_destroy().
 *
 * Since: 1.0
 **/
pub type cairo_pattern_t = _cairo_pattern;
/**
 * cairo_rectangle_int_t:
 * @x: X coordinate of the left side of the rectangle
 * @y: Y coordinate of the the top side of the rectangle
 * @width: width of the rectangle
 * @height: height of the rectangle
 *
 * A data structure for holding a rectangle with integer coordinates.
 *
 * Since: 1.10
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _cairo_rectangle_int {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__cairo_rectangle_int() {
    assert_eq!(::std::mem::size_of::<_cairo_rectangle_int>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( _cairo_rectangle_int )
               ));
    assert_eq! (::std::mem::align_of::<_cairo_rectangle_int>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( _cairo_rectangle_int ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _cairo_rectangle_int ) ) . x as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _cairo_rectangle_int )
                , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _cairo_rectangle_int ) ) . y as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _cairo_rectangle_int )
                , "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _cairo_rectangle_int ) ) . width as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _cairo_rectangle_int )
                , "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _cairo_rectangle_int ) ) . height as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _cairo_rectangle_int )
                , "::" , stringify ! ( height ) ));
}
impl Clone for _cairo_rectangle_int {
    fn clone(&self) -> Self { *self }
}
pub type cairo_rectangle_int_t = _cairo_rectangle_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo_region {
    _unused: [u8; 0],
}
/**
 * cairo_region_t:
 *
 * A #cairo_region_t represents a set of integer-aligned rectangles.
 *
 * It allows set-theoretical operations like cairo_region_union() and
 * cairo_region_intersect() to be performed on them.
 *
 * Memory management of #cairo_region_t is done with
 * cairo_region_reference() and cairo_region_destroy().
 *
 * Since: 1.10
 **/
pub type cairo_region_t = _cairo_region;
pub type GdkRectangle = cairo_rectangle_int_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GdkAtom {
    _unused: [u8; 0],
}
/**
 * GdkAtom:
 *
 * An opaque type representing a string as an index into a table
 * of strings on the X server.
 */
pub type GdkAtom = *mut _GdkAtom;
/**
 * GdkColor:
 * @pixel: For allocated colors, the pixel value used to
 *     draw this color on the screen. Not used anymore.
 * @red: The red component of the color. This is
 *     a value between 0 and 65535, with 65535 indicating
 *     full intensity
 * @green: The green component of the color
 * @blue: The blue component of the color
 *
 * A #GdkColor is used to describe a color,
 * similar to the XColor struct used in the X11 drawing API.
 *
 * Deprecated: 3.14: Use #GdkRGBA
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkColor {
    pub pixel: guint32,
    pub red: guint16,
    pub green: guint16,
    pub blue: guint16,
}
#[test]
fn bindgen_test_layout__GdkColor() {
    assert_eq!(::std::mem::size_of::<_GdkColor>() , 12usize , concat ! (
               "Size of: " , stringify ! ( _GdkColor ) ));
    assert_eq! (::std::mem::align_of::<_GdkColor>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _GdkColor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkColor ) ) . pixel as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkColor ) , "::" ,
                stringify ! ( pixel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkColor ) ) . red as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkColor ) , "::" ,
                stringify ! ( red ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkColor ) ) . green as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkColor ) , "::" ,
                stringify ! ( green ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkColor ) ) . blue as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkColor ) , "::" ,
                stringify ! ( blue ) ));
}
impl Clone for _GdkColor {
    fn clone(&self) -> Self { *self }
}
pub type GdkColor = _GdkColor;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkRGBA {
    pub red: gdouble,
    pub green: gdouble,
    pub blue: gdouble,
    pub alpha: gdouble,
}
#[test]
fn bindgen_test_layout__GdkRGBA() {
    assert_eq!(::std::mem::size_of::<_GdkRGBA>() , 32usize , concat ! (
               "Size of: " , stringify ! ( _GdkRGBA ) ));
    assert_eq! (::std::mem::align_of::<_GdkRGBA>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GdkRGBA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkRGBA ) ) . red as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkRGBA ) , "::" ,
                stringify ! ( red ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkRGBA ) ) . green as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkRGBA ) , "::" ,
                stringify ! ( green ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkRGBA ) ) . blue as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkRGBA ) , "::" ,
                stringify ! ( blue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkRGBA ) ) . alpha as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkRGBA ) , "::" ,
                stringify ! ( alpha ) ));
}
impl Clone for _GdkRGBA {
    fn clone(&self) -> Self { *self }
}
pub type GdkRGBA = _GdkRGBA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GdkVisual {
    _unused: [u8; 0],
}
pub type GdkVisual = _GdkVisual;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GdkDevice {
    _unused: [u8; 0],
}
pub type GdkDevice = _GdkDevice;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GdkDragContext {
    _unused: [u8; 0],
}
pub type GdkDragContext = _GdkDragContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GdkScreen {
    _unused: [u8; 0],
}
pub type GdkScreen = _GdkScreen;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GdkWindow {
    _unused: [u8; 0],
}
pub type GdkWindow = _GdkWindow;
#[repr(u32)]
/**
 * GdkDragAction:
 * @GDK_ACTION_DEFAULT: Means nothing, and should not be used.
 * @GDK_ACTION_COPY: Copy the data.
 * @GDK_ACTION_MOVE: Move the data, i.e. first copy it, then delete
 *  it from the source using the DELETE target of the X selection protocol.
 * @GDK_ACTION_LINK: Add a link to the data. Note that this is only
 *  useful if source and destination agree on what it means.
 * @GDK_ACTION_PRIVATE: Special action which tells the source that the
 *  destination will do something that the source doesnt understand.
 * @GDK_ACTION_ASK: Ask the user what to do with the data.
 *
 * Used in #GdkDragContext to indicate what the destination
 * should do with the dropped data.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GdkDragAction {
    GDK_ACTION_DEFAULT = 1,
    GDK_ACTION_COPY = 2,
    GDK_ACTION_MOVE = 4,
    GDK_ACTION_LINK = 8,
    GDK_ACTION_PRIVATE = 16,
    GDK_ACTION_ASK = 32,
}
/**
 * GdkEventAny:
 * @type: the type of the event.
 * @window: the window which received the event.
 * @send_event: %TRUE if the event was sent explicitly.
 *
 * Contains the fields which are common to all event structs.
 * Any event pointer can safely be cast to a pointer to a #GdkEventAny to
 * access these fields.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkEventAny {
    pub type_: GdkEventType,
    pub window: *mut GdkWindow,
    pub send_event: gint8,
}
#[test]
fn bindgen_test_layout__GdkEventAny() {
    assert_eq!(::std::mem::size_of::<_GdkEventAny>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _GdkEventAny ) ));
    assert_eq! (::std::mem::align_of::<_GdkEventAny>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GdkEventAny ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventAny ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventAny ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventAny ) ) . window as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventAny ) , "::" ,
                stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventAny ) ) . send_event as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventAny ) , "::" ,
                stringify ! ( send_event ) ));
}
impl Clone for _GdkEventAny {
    fn clone(&self) -> Self { *self }
}
pub type GdkEventAny = _GdkEventAny;
/**
 * GdkEventExpose:
 * @type: the type of the event (%GDK_EXPOSE or %GDK_DAMAGE).
 * @window: the window which received the event.
 * @send_event: %TRUE if the event was sent explicitly.
 * @area: bounding box of @region.
 * @region: the region that needs to be redrawn.
 * @count: the number of contiguous %GDK_EXPOSE events following this one.
 *   The only use for this is exposure compression, i.e. handling all
 *   contiguous %GDK_EXPOSE events in one go, though GDK performs some
 *   exposure compression so this is not normally needed.
 *
 * Generated when all or part of a window becomes visible and needs to be
 * redrawn.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkEventExpose {
    pub type_: GdkEventType,
    pub window: *mut GdkWindow,
    pub send_event: gint8,
    pub area: GdkRectangle,
    pub region: *mut cairo_region_t,
    pub count: gint,
}
#[test]
fn bindgen_test_layout__GdkEventExpose() {
    assert_eq!(::std::mem::size_of::<_GdkEventExpose>() , 56usize , concat ! (
               "Size of: " , stringify ! ( _GdkEventExpose ) ));
    assert_eq! (::std::mem::align_of::<_GdkEventExpose>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _GdkEventExpose ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventExpose ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventExpose ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventExpose ) ) . window as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventExpose ) ,
                "::" , stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventExpose ) ) . send_event as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventExpose ) ,
                "::" , stringify ! ( send_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventExpose ) ) . area as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventExpose ) ,
                "::" , stringify ! ( area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventExpose ) ) . region as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventExpose ) ,
                "::" , stringify ! ( region ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventExpose ) ) . count as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventExpose ) ,
                "::" , stringify ! ( count ) ));
}
impl Clone for _GdkEventExpose {
    fn clone(&self) -> Self { *self }
}
pub type GdkEventExpose = _GdkEventExpose;
/**
 * GdkEventVisibility:
 * @type: the type of the event (%GDK_VISIBILITY_NOTIFY).
 * @window: the window which received the event.
 * @send_event: %TRUE if the event was sent explicitly.
 * @state: the new visibility state (%GDK_VISIBILITY_FULLY_OBSCURED,
 *   %GDK_VISIBILITY_PARTIAL or %GDK_VISIBILITY_UNOBSCURED).
 *
 * Generated when the window visibility status has changed.
 *
 * Deprecated: 3.12: Modern composited windowing systems with pervasive
 *     transparency make it impossible to track the visibility of a window
 *     reliably, so this event can not be guaranteed to provide useful
 *     information.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkEventVisibility {
    pub type_: GdkEventType,
    pub window: *mut GdkWindow,
    pub send_event: gint8,
    pub state: GdkVisibilityState,
}
#[test]
fn bindgen_test_layout__GdkEventVisibility() {
    assert_eq!(::std::mem::size_of::<_GdkEventVisibility>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( _GdkEventVisibility ) ));
    assert_eq! (::std::mem::align_of::<_GdkEventVisibility>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GdkEventVisibility ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventVisibility ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventVisibility ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventVisibility ) ) . window as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventVisibility ) ,
                "::" , stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventVisibility ) ) . send_event as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventVisibility ) ,
                "::" , stringify ! ( send_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventVisibility ) ) . state as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventVisibility ) ,
                "::" , stringify ! ( state ) ));
}
impl Clone for _GdkEventVisibility {
    fn clone(&self) -> Self { *self }
}
pub type GdkEventVisibility = _GdkEventVisibility;
/**
 * GdkEventMotion:
 * @type: the type of the event.
 * @window: the window which received the event.
 * @send_event: %TRUE if the event was sent explicitly.
 * @time: the time of the event in milliseconds.
 * @x: the x coordinate of the pointer relative to the window.
 * @y: the y coordinate of the pointer relative to the window.
 * @axes: @x, @y translated to the axes of @device, or %NULL if @device is
 *   the mouse.
 * @state: (type GdkModifierType): a bit-mask representing the state of
 *   the modifier keys (e.g. Control, Shift and Alt) and the pointer
 *   buttons. See #GdkModifierType.
 * @is_hint: set to 1 if this event is just a hint, see the
 *   %GDK_POINTER_MOTION_HINT_MASK value of #GdkEventMask.
 * @device: the master device that the event originated from. Use
 * gdk_event_get_source_device() to get the slave device.
 * @x_root: the x coordinate of the pointer relative to the root of the
 *   screen.
 * @y_root: the y coordinate of the pointer relative to the root of the
 *   screen.
 *
 * Generated when the pointer moves.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkEventMotion {
    pub type_: GdkEventType,
    pub window: *mut GdkWindow,
    pub send_event: gint8,
    pub time: guint32,
    pub x: gdouble,
    pub y: gdouble,
    pub axes: *mut gdouble,
    pub state: guint,
    pub is_hint: gint16,
    pub device: *mut GdkDevice,
    pub x_root: gdouble,
    pub y_root: gdouble,
}
#[test]
fn bindgen_test_layout__GdkEventMotion() {
    assert_eq!(::std::mem::size_of::<_GdkEventMotion>() , 80usize , concat ! (
               "Size of: " , stringify ! ( _GdkEventMotion ) ));
    assert_eq! (::std::mem::align_of::<_GdkEventMotion>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _GdkEventMotion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventMotion ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventMotion ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventMotion ) ) . window as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventMotion ) ,
                "::" , stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventMotion ) ) . send_event as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventMotion ) ,
                "::" , stringify ! ( send_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventMotion ) ) . time as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventMotion ) ,
                "::" , stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventMotion ) ) . x as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventMotion ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventMotion ) ) . y as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventMotion ) ,
                "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventMotion ) ) . axes as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventMotion ) ,
                "::" , stringify ! ( axes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventMotion ) ) . state as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventMotion ) ,
                "::" , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventMotion ) ) . is_hint as * const
                _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventMotion ) ,
                "::" , stringify ! ( is_hint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventMotion ) ) . device as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventMotion ) ,
                "::" , stringify ! ( device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventMotion ) ) . x_root as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventMotion ) ,
                "::" , stringify ! ( x_root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventMotion ) ) . y_root as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventMotion ) ,
                "::" , stringify ! ( y_root ) ));
}
impl Clone for _GdkEventMotion {
    fn clone(&self) -> Self { *self }
}
pub type GdkEventMotion = _GdkEventMotion;
/**
 * GdkEventButton:
 * @type: the type of the event (%GDK_BUTTON_PRESS, %GDK_2BUTTON_PRESS,
 *   %GDK_3BUTTON_PRESS or %GDK_BUTTON_RELEASE).
 * @window: the window which received the event.
 * @send_event: %TRUE if the event was sent explicitly.
 * @time: the time of the event in milliseconds.
 * @x: the x coordinate of the pointer relative to the window.
 * @y: the y coordinate of the pointer relative to the window.
 * @axes: @x, @y translated to the axes of @device, or %NULL if @device is
 *   the mouse.
 * @state: (type GdkModifierType): a bit-mask representing the state of
 *   the modifier keys (e.g. Control, Shift and Alt) and the pointer
 *   buttons. See #GdkModifierType.
 * @button: the button which was pressed or released, numbered from 1 to 5.
 *   Normally button 1 is the left mouse button, 2 is the middle button,
 *   and 3 is the right button. On 2-button mice, the middle button can
 *   often be simulated by pressing both mouse buttons together.
 * @device: the master device that the event originated from. Use
 * gdk_event_get_source_device() to get the slave device.
 * @x_root: the x coordinate of the pointer relative to the root of the
 *   screen.
 * @y_root: the y coordinate of the pointer relative to the root of the
 *   screen.
 *
 * Used for button press and button release events. The
 * @type field will be one of %GDK_BUTTON_PRESS,
 * %GDK_2BUTTON_PRESS, %GDK_3BUTTON_PRESS or %GDK_BUTTON_RELEASE,
 *
 * Double and triple-clicks result in a sequence of events being received.
 * For double-clicks the order of events will be:
 *
 * - %GDK_BUTTON_PRESS
 * - %GDK_BUTTON_RELEASE
 * - %GDK_BUTTON_PRESS
 * - %GDK_2BUTTON_PRESS
 * - %GDK_BUTTON_RELEASE
 *
 * Note that the first click is received just like a normal
 * button press, while the second click results in a %GDK_2BUTTON_PRESS
 * being received just after the %GDK_BUTTON_PRESS.
 *
 * Triple-clicks are very similar to double-clicks, except that
 * %GDK_3BUTTON_PRESS is inserted after the third click. The order of the
 * events is:
 *
 * - %GDK_BUTTON_PRESS
 * - %GDK_BUTTON_RELEASE
 * - %GDK_BUTTON_PRESS
 * - %GDK_2BUTTON_PRESS
 * - %GDK_BUTTON_RELEASE
 * - %GDK_BUTTON_PRESS
 * - %GDK_3BUTTON_PRESS
 * - %GDK_BUTTON_RELEASE
 *
 * For a double click to occur, the second button press must occur within
 * 1/4 of a second of the first. For a triple click to occur, the third
 * button press must also occur within 1/2 second of the first button press.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkEventButton {
    pub type_: GdkEventType,
    pub window: *mut GdkWindow,
    pub send_event: gint8,
    pub time: guint32,
    pub x: gdouble,
    pub y: gdouble,
    pub axes: *mut gdouble,
    pub state: guint,
    pub button: guint,
    pub device: *mut GdkDevice,
    pub x_root: gdouble,
    pub y_root: gdouble,
}
#[test]
fn bindgen_test_layout__GdkEventButton() {
    assert_eq!(::std::mem::size_of::<_GdkEventButton>() , 80usize , concat ! (
               "Size of: " , stringify ! ( _GdkEventButton ) ));
    assert_eq! (::std::mem::align_of::<_GdkEventButton>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _GdkEventButton ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventButton ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventButton ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventButton ) ) . window as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventButton ) ,
                "::" , stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventButton ) ) . send_event as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventButton ) ,
                "::" , stringify ! ( send_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventButton ) ) . time as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventButton ) ,
                "::" , stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventButton ) ) . x as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventButton ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventButton ) ) . y as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventButton ) ,
                "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventButton ) ) . axes as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventButton ) ,
                "::" , stringify ! ( axes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventButton ) ) . state as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventButton ) ,
                "::" , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventButton ) ) . button as * const _
                as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventButton ) ,
                "::" , stringify ! ( button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventButton ) ) . device as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventButton ) ,
                "::" , stringify ! ( device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventButton ) ) . x_root as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventButton ) ,
                "::" , stringify ! ( x_root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventButton ) ) . y_root as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventButton ) ,
                "::" , stringify ! ( y_root ) ));
}
impl Clone for _GdkEventButton {
    fn clone(&self) -> Self { *self }
}
pub type GdkEventButton = _GdkEventButton;
/**
 * GdkEventTouch:
 * @type: the type of the event (%GDK_TOUCH_BEGIN, %GDK_TOUCH_UPDATE,
 *   %GDK_TOUCH_END, %GDK_TOUCH_CANCEL)
 * @window: the window which received the event
 * @send_event: %TRUE if the event was sent explicitly.
 * @time: the time of the event in milliseconds.
 * @x: the x coordinate of the pointer relative to the window
 * @y: the y coordinate of the pointer relative to the window
 * @axes: @x, @y translated to the axes of @device, or %NULL if @device is
 *   the mouse
 * @state: (type GdkModifierType): a bit-mask representing the state of
 *   the modifier keys (e.g. Control, Shift and Alt) and the pointer
 *   buttons. See #GdkModifierType
 * @sequence: the event sequence that the event belongs to
 * @emulating_pointer: whether the event should be used for emulating
 *   pointer event
 * @device: the master device that the event originated from. Use
 * gdk_event_get_source_device() to get the slave device.
 * @x_root: the x coordinate of the pointer relative to the root of the
 *   screen
 * @y_root: the y coordinate of the pointer relative to the root of the
 *   screen
 *
 * Used for touch events.
 * @type field will be one of %GDK_TOUCH_BEGIN, %GDK_TOUCH_UPDATE,
 * %GDK_TOUCH_END or %GDK_TOUCH_CANCEL.
 *
 * Touch events are grouped into sequences by means of the @sequence
 * field, which can also be obtained with gdk_event_get_event_sequence().
 * Each sequence begins with a %GDK_TOUCH_BEGIN event, followed by
 * any number of %GDK_TOUCH_UPDATE events, and ends with a %GDK_TOUCH_END
 * (or %GDK_TOUCH_CANCEL) event. With multitouch devices, there may be
 * several active sequences at the same time.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkEventTouch {
    pub type_: GdkEventType,
    pub window: *mut GdkWindow,
    pub send_event: gint8,
    pub time: guint32,
    pub x: gdouble,
    pub y: gdouble,
    pub axes: *mut gdouble,
    pub state: guint,
    pub sequence: *mut GdkEventSequence,
    pub emulating_pointer: gboolean,
    pub device: *mut GdkDevice,
    pub x_root: gdouble,
    pub y_root: gdouble,
}
#[test]
fn bindgen_test_layout__GdkEventTouch() {
    assert_eq!(::std::mem::size_of::<_GdkEventTouch>() , 96usize , concat ! (
               "Size of: " , stringify ! ( _GdkEventTouch ) ));
    assert_eq! (::std::mem::align_of::<_GdkEventTouch>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GdkEventTouch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouch ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouch ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouch ) ) . window as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouch ) , "::"
                , stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouch ) ) . send_event as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouch ) , "::"
                , stringify ! ( send_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouch ) ) . time as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouch ) , "::"
                , stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouch ) ) . x as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouch ) , "::"
                , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouch ) ) . y as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouch ) , "::"
                , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouch ) ) . axes as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouch ) , "::"
                , stringify ! ( axes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouch ) ) . state as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouch ) , "::"
                , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouch ) ) . sequence as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouch ) , "::"
                , stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouch ) ) . emulating_pointer as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouch ) , "::"
                , stringify ! ( emulating_pointer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouch ) ) . device as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouch ) , "::"
                , stringify ! ( device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouch ) ) . x_root as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouch ) , "::"
                , stringify ! ( x_root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouch ) ) . y_root as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouch ) , "::"
                , stringify ! ( y_root ) ));
}
impl Clone for _GdkEventTouch {
    fn clone(&self) -> Self { *self }
}
pub type GdkEventTouch = _GdkEventTouch;
/**
 * GdkEventScroll:
 * @type: the type of the event (%GDK_SCROLL).
 * @window: the window which received the event.
 * @send_event: %TRUE if the event was sent explicitly.
 * @time: the time of the event in milliseconds.
 * @x: the x coordinate of the pointer relative to the window.
 * @y: the y coordinate of the pointer relative to the window.
 * @state: (type GdkModifierType): a bit-mask representing the state of
 *   the modifier keys (e.g. Control, Shift and Alt) and the pointer
 *   buttons. See #GdkModifierType.
 * @direction: the direction to scroll to (one of %GDK_SCROLL_UP,
 *   %GDK_SCROLL_DOWN, %GDK_SCROLL_LEFT, %GDK_SCROLL_RIGHT or
 *   %GDK_SCROLL_SMOOTH).
 * @device: the master device that the event originated from. Use
 * gdk_event_get_source_device() to get the slave device.
 * @x_root: the x coordinate of the pointer relative to the root of the
 *   screen.
 * @y_root: the y coordinate of the pointer relative to the root of the
 *   screen.
 * @delta_x: the x coordinate of the scroll delta
 * @delta_y: the y coordinate of the scroll delta
 *
 * Generated from button presses for the buttons 4 to 7. Wheel mice are
 * usually configured to generate button press events for buttons 4 and 5
 * when the wheel is turned.
 *
 * Some GDK backends can also generate smooth scroll events, which
 * can be recognized by the %GDK_SCROLL_SMOOTH scroll direction. For
 * these, the scroll deltas can be obtained with
 * gdk_event_get_scroll_deltas().
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkEventScroll {
    pub type_: GdkEventType,
    pub window: *mut GdkWindow,
    pub send_event: gint8,
    pub time: guint32,
    pub x: gdouble,
    pub y: gdouble,
    pub state: guint,
    pub direction: GdkScrollDirection,
    pub device: *mut GdkDevice,
    pub x_root: gdouble,
    pub y_root: gdouble,
    pub delta_x: gdouble,
    pub delta_y: gdouble,
}
#[test]
fn bindgen_test_layout__GdkEventScroll() {
    assert_eq!(::std::mem::size_of::<_GdkEventScroll>() , 88usize , concat ! (
               "Size of: " , stringify ! ( _GdkEventScroll ) ));
    assert_eq! (::std::mem::align_of::<_GdkEventScroll>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _GdkEventScroll ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventScroll ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventScroll ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventScroll ) ) . window as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventScroll ) ,
                "::" , stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventScroll ) ) . send_event as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventScroll ) ,
                "::" , stringify ! ( send_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventScroll ) ) . time as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventScroll ) ,
                "::" , stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventScroll ) ) . x as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventScroll ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventScroll ) ) . y as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventScroll ) ,
                "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventScroll ) ) . state as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventScroll ) ,
                "::" , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventScroll ) ) . direction as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventScroll ) ,
                "::" , stringify ! ( direction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventScroll ) ) . device as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventScroll ) ,
                "::" , stringify ! ( device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventScroll ) ) . x_root as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventScroll ) ,
                "::" , stringify ! ( x_root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventScroll ) ) . y_root as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventScroll ) ,
                "::" , stringify ! ( y_root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventScroll ) ) . delta_x as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventScroll ) ,
                "::" , stringify ! ( delta_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventScroll ) ) . delta_y as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventScroll ) ,
                "::" , stringify ! ( delta_y ) ));
}
impl Clone for _GdkEventScroll {
    fn clone(&self) -> Self { *self }
}
pub type GdkEventScroll = _GdkEventScroll;
/**
 * GdkEventKey:
 * @type: the type of the event (%GDK_KEY_PRESS or %GDK_KEY_RELEASE).
 * @window: the window which received the event.
 * @send_event: %TRUE if the event was sent explicitly.
 * @time: the time of the event in milliseconds.
 * @state: (type GdkModifierType): a bit-mask representing the state of
 *   the modifier keys (e.g. Control, Shift and Alt) and the pointer
 *   buttons. See #GdkModifierType.
 * @keyval: the key that was pressed or released. See the
 *   `gdk/gdkkeysyms.h` header file for a
 *   complete list of GDK key codes.
 * @length: the length of @string.
 * @string: a string containing an approximation of the text that
 *   would result from this keypress. The only correct way to handle text
 *   input of text is using input methods (see #GtkIMContext), so this
 *   field is deprecated and should never be used.
 *   (gdk_unicode_to_keyval() provides a non-deprecated way of getting
 *   an approximate translation for a key.) The string is encoded in the
 *   encoding of the current locale (Note: this for backwards compatibility:
 *   strings in GTK+ and GDK are typically in UTF-8.) and NUL-terminated.
 *   In some cases, the translation of the key code will be a single
 *   NUL byte, in which case looking at @length is necessary to distinguish
 *   it from the an empty translation.
 * @hardware_keycode: the raw code of the key that was pressed or released.
 * @group: the keyboard group.
 * @is_modifier: a flag that indicates if @hardware_keycode is mapped to a
 *   modifier. Since 2.10
 *
 * Describes a key press or key release event.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkEventKey {
    pub type_: GdkEventType,
    pub window: *mut GdkWindow,
    pub send_event: gint8,
    pub time: guint32,
    pub state: guint,
    pub keyval: guint,
    pub length: gint,
    pub string: *mut gchar,
    pub hardware_keycode: guint16,
    pub group: guint8,
    pub _bitfield_1: u8,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout__GdkEventKey() {
    assert_eq!(::std::mem::size_of::<_GdkEventKey>() , 56usize , concat ! (
               "Size of: " , stringify ! ( _GdkEventKey ) ));
    assert_eq! (::std::mem::align_of::<_GdkEventKey>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GdkEventKey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventKey ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventKey ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventKey ) ) . window as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventKey ) , "::" ,
                stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventKey ) ) . send_event as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventKey ) , "::" ,
                stringify ! ( send_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventKey ) ) . time as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventKey ) , "::" ,
                stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventKey ) ) . state as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventKey ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventKey ) ) . keyval as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventKey ) , "::" ,
                stringify ! ( keyval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventKey ) ) . length as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventKey ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventKey ) ) . string as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventKey ) , "::" ,
                stringify ! ( string ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventKey ) ) . hardware_keycode as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventKey ) , "::" ,
                stringify ! ( hardware_keycode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventKey ) ) . group as * const _ as
                usize } , 50usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventKey ) , "::" ,
                stringify ! ( group ) ));
}
impl Clone for _GdkEventKey {
    fn clone(&self) -> Self { *self }
}
impl _GdkEventKey {
    #[inline]
    pub fn is_modifier(&self) -> guint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_is_modifier(&mut self, val: guint) {
        let mask = 1u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(is_modifier: guint) -> u8 {
        ({ 0 } | ((is_modifier as u32 as u8) << 0usize) & (1u64 as u8))
    }
}
pub type GdkEventKey = _GdkEventKey;
/**
 * GdkEventFocus:
 * @type: the type of the event (%GDK_FOCUS_CHANGE).
 * @window: the window which received the event.
 * @send_event: %TRUE if the event was sent explicitly.
 * @in: %TRUE if the window has gained the keyboard focus, %FALSE if
 *   it has lost the focus.
 *
 * Describes a change of keyboard focus.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkEventFocus {
    pub type_: GdkEventType,
    pub window: *mut GdkWindow,
    pub send_event: gint8,
    pub in_: gint16,
}
#[test]
fn bindgen_test_layout__GdkEventFocus() {
    assert_eq!(::std::mem::size_of::<_GdkEventFocus>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _GdkEventFocus ) ));
    assert_eq! (::std::mem::align_of::<_GdkEventFocus>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GdkEventFocus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventFocus ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventFocus ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventFocus ) ) . window as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventFocus ) , "::"
                , stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventFocus ) ) . send_event as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventFocus ) , "::"
                , stringify ! ( send_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventFocus ) ) . in_ as * const _ as
                usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventFocus ) , "::"
                , stringify ! ( in_ ) ));
}
impl Clone for _GdkEventFocus {
    fn clone(&self) -> Self { *self }
}
pub type GdkEventFocus = _GdkEventFocus;
/**
 * GdkEventCrossing:
 * @type: the type of the event (%GDK_ENTER_NOTIFY or %GDK_LEAVE_NOTIFY).
 * @window: the window which received the event.
 * @send_event: %TRUE if the event was sent explicitly.
 * @subwindow: the window that was entered or left.
 * @time: the time of the event in milliseconds.
 * @x: the x coordinate of the pointer relative to the window.
 * @y: the y coordinate of the pointer relative to the window.
 * @x_root: the x coordinate of the pointer relative to the root of the screen.
 * @y_root: the y coordinate of the pointer relative to the root of the screen.
 * @mode: the crossing mode (%GDK_CROSSING_NORMAL, %GDK_CROSSING_GRAB,
 *  %GDK_CROSSING_UNGRAB, %GDK_CROSSING_GTK_GRAB, %GDK_CROSSING_GTK_UNGRAB or
 *  %GDK_CROSSING_STATE_CHANGED).  %GDK_CROSSING_GTK_GRAB, %GDK_CROSSING_GTK_UNGRAB,
 *  and %GDK_CROSSING_STATE_CHANGED were added in 2.14 and are always synthesized,
 *  never native.
 * @detail: the kind of crossing that happened (%GDK_NOTIFY_INFERIOR,
 *  %GDK_NOTIFY_ANCESTOR, %GDK_NOTIFY_VIRTUAL, %GDK_NOTIFY_NONLINEAR or
 *  %GDK_NOTIFY_NONLINEAR_VIRTUAL).
 * @focus: %TRUE if @window is the focus window or an inferior.
 * @state: (type GdkModifierType): a bit-mask representing the state of
 *   the modifier keys (e.g. Control, Shift and Alt) and the pointer
 *   buttons. See #GdkModifierType.
 *
 * Generated when the pointer enters or leaves a window.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkEventCrossing {
    pub type_: GdkEventType,
    pub window: *mut GdkWindow,
    pub send_event: gint8,
    pub subwindow: *mut GdkWindow,
    pub time: guint32,
    pub x: gdouble,
    pub y: gdouble,
    pub x_root: gdouble,
    pub y_root: gdouble,
    pub mode: GdkCrossingMode,
    pub detail: GdkNotifyType,
    pub focus: gboolean,
    pub state: guint,
}
#[test]
fn bindgen_test_layout__GdkEventCrossing() {
    assert_eq!(::std::mem::size_of::<_GdkEventCrossing>() , 88usize , concat !
               ( "Size of: " , stringify ! ( _GdkEventCrossing ) ));
    assert_eq! (::std::mem::align_of::<_GdkEventCrossing>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _GdkEventCrossing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventCrossing ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventCrossing ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventCrossing ) ) . window as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventCrossing ) ,
                "::" , stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventCrossing ) ) . send_event as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventCrossing ) ,
                "::" , stringify ! ( send_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventCrossing ) ) . subwindow as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventCrossing ) ,
                "::" , stringify ! ( subwindow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventCrossing ) ) . time as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventCrossing ) ,
                "::" , stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventCrossing ) ) . x as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventCrossing ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventCrossing ) ) . y as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventCrossing ) ,
                "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventCrossing ) ) . x_root as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventCrossing ) ,
                "::" , stringify ! ( x_root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventCrossing ) ) . y_root as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventCrossing ) ,
                "::" , stringify ! ( y_root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventCrossing ) ) . mode as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventCrossing ) ,
                "::" , stringify ! ( mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventCrossing ) ) . detail as * const
                _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventCrossing ) ,
                "::" , stringify ! ( detail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventCrossing ) ) . focus as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventCrossing ) ,
                "::" , stringify ! ( focus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventCrossing ) ) . state as * const
                _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventCrossing ) ,
                "::" , stringify ! ( state ) ));
}
impl Clone for _GdkEventCrossing {
    fn clone(&self) -> Self { *self }
}
pub type GdkEventCrossing = _GdkEventCrossing;
/**
 * GdkEventConfigure:
 * @type: the type of the event (%GDK_CONFIGURE).
 * @window: the window which received the event.
 * @send_event: %TRUE if the event was sent explicitly.
 * @x: the new x coordinate of the window, relative to its parent.
 * @y: the new y coordinate of the window, relative to its parent.
 * @width: the new width of the window.
 * @height: the new height of the window.
 *
 * Generated when a window size or position has changed.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkEventConfigure {
    pub type_: GdkEventType,
    pub window: *mut GdkWindow,
    pub send_event: gint8,
    pub x: gint,
    pub y: gint,
    pub width: gint,
    pub height: gint,
}
#[test]
fn bindgen_test_layout__GdkEventConfigure() {
    assert_eq!(::std::mem::size_of::<_GdkEventConfigure>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( _GdkEventConfigure ) ));
    assert_eq! (::std::mem::align_of::<_GdkEventConfigure>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _GdkEventConfigure ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventConfigure ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventConfigure ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventConfigure ) ) . window as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventConfigure ) ,
                "::" , stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventConfigure ) ) . send_event as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventConfigure ) ,
                "::" , stringify ! ( send_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventConfigure ) ) . x as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventConfigure ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventConfigure ) ) . y as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventConfigure ) ,
                "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventConfigure ) ) . width as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventConfigure ) ,
                "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventConfigure ) ) . height as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventConfigure ) ,
                "::" , stringify ! ( height ) ));
}
impl Clone for _GdkEventConfigure {
    fn clone(&self) -> Self { *self }
}
pub type GdkEventConfigure = _GdkEventConfigure;
/**
 * GdkEventProperty:
 * @type: the type of the event (%GDK_PROPERTY_NOTIFY).
 * @window: the window which received the event.
 * @send_event: %TRUE if the event was sent explicitly.
 * @atom: the property that was changed.
 * @time: the time of the event in milliseconds.
 * @state: (type GdkPropertyState): whether the property was changed
 *   (%GDK_PROPERTY_NEW_VALUE) or deleted (%GDK_PROPERTY_DELETE).
 *
 * Describes a property change on a window.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkEventProperty {
    pub type_: GdkEventType,
    pub window: *mut GdkWindow,
    pub send_event: gint8,
    pub atom: GdkAtom,
    pub time: guint32,
    pub state: guint,
}
#[test]
fn bindgen_test_layout__GdkEventProperty() {
    assert_eq!(::std::mem::size_of::<_GdkEventProperty>() , 40usize , concat !
               ( "Size of: " , stringify ! ( _GdkEventProperty ) ));
    assert_eq! (::std::mem::align_of::<_GdkEventProperty>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _GdkEventProperty ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventProperty ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventProperty ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventProperty ) ) . window as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventProperty ) ,
                "::" , stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventProperty ) ) . send_event as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventProperty ) ,
                "::" , stringify ! ( send_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventProperty ) ) . atom as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventProperty ) ,
                "::" , stringify ! ( atom ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventProperty ) ) . time as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventProperty ) ,
                "::" , stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventProperty ) ) . state as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventProperty ) ,
                "::" , stringify ! ( state ) ));
}
impl Clone for _GdkEventProperty {
    fn clone(&self) -> Self { *self }
}
pub type GdkEventProperty = _GdkEventProperty;
/**
 * GdkEventSelection:
 * @type: the type of the event (%GDK_SELECTION_CLEAR,
 *   %GDK_SELECTION_NOTIFY or %GDK_SELECTION_REQUEST).
 * @window: the window which received the event.
 * @send_event: %TRUE if the event was sent explicitly.
 * @selection: the selection.
 * @target: the target to which the selection should be converted.
 * @property: the property in which to place the result of the conversion.
 * @time: the time of the event in milliseconds.
 * @requestor: the window on which to place @property or %NULL if none.
 *
 * Generated when a selection is requested or ownership of a selection
 * is taken over by another client application.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkEventSelection {
    pub type_: GdkEventType,
    pub window: *mut GdkWindow,
    pub send_event: gint8,
    pub selection: GdkAtom,
    pub target: GdkAtom,
    pub property: GdkAtom,
    pub time: guint32,
    pub requestor: *mut GdkWindow,
}
#[test]
fn bindgen_test_layout__GdkEventSelection() {
    assert_eq!(::std::mem::size_of::<_GdkEventSelection>() , 64usize , concat
               ! ( "Size of: " , stringify ! ( _GdkEventSelection ) ));
    assert_eq! (::std::mem::align_of::<_GdkEventSelection>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _GdkEventSelection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventSelection ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventSelection ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventSelection ) ) . window as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventSelection ) ,
                "::" , stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventSelection ) ) . send_event as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventSelection ) ,
                "::" , stringify ! ( send_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventSelection ) ) . selection as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventSelection ) ,
                "::" , stringify ! ( selection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventSelection ) ) . target as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventSelection ) ,
                "::" , stringify ! ( target ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventSelection ) ) . property as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventSelection ) ,
                "::" , stringify ! ( property ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventSelection ) ) . time as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventSelection ) ,
                "::" , stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventSelection ) ) . requestor as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventSelection ) ,
                "::" , stringify ! ( requestor ) ));
}
impl Clone for _GdkEventSelection {
    fn clone(&self) -> Self { *self }
}
pub type GdkEventSelection = _GdkEventSelection;
/**
 * GdkEventOwnerChange:
 * @type: the type of the event (%GDK_OWNER_CHANGE).
 * @window: the window which received the event
 * @send_event: %TRUE if the event was sent explicitly.
 * @owner: the new owner of the selection, or %NULL if there is none
 * @reason: the reason for the ownership change as a #GdkOwnerChange value
 * @selection: the atom identifying the selection
 * @time: the timestamp of the event
 * @selection_time: the time at which the selection ownership was taken
 *   over
 *
 * Generated when the owner of a selection changes. On X11, this
 * information is only available if the X server supports the XFIXES
 * extension.
 *
 * Since: 2.6
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkEventOwnerChange {
    pub type_: GdkEventType,
    pub window: *mut GdkWindow,
    pub send_event: gint8,
    pub owner: *mut GdkWindow,
    pub reason: GdkOwnerChange,
    pub selection: GdkAtom,
    pub time: guint32,
    pub selection_time: guint32,
}
#[test]
fn bindgen_test_layout__GdkEventOwnerChange() {
    assert_eq!(::std::mem::size_of::<_GdkEventOwnerChange>() , 56usize ,
               concat ! ( "Size of: " , stringify ! ( _GdkEventOwnerChange )
               ));
    assert_eq! (::std::mem::align_of::<_GdkEventOwnerChange>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GdkEventOwnerChange ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventOwnerChange ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventOwnerChange )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventOwnerChange ) ) . window as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventOwnerChange )
                , "::" , stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventOwnerChange ) ) . send_event as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventOwnerChange )
                , "::" , stringify ! ( send_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventOwnerChange ) ) . owner as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventOwnerChange )
                , "::" , stringify ! ( owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventOwnerChange ) ) . reason as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventOwnerChange )
                , "::" , stringify ! ( reason ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventOwnerChange ) ) . selection as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventOwnerChange )
                , "::" , stringify ! ( selection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventOwnerChange ) ) . time as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventOwnerChange )
                , "::" , stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventOwnerChange ) ) . selection_time
                as * const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventOwnerChange )
                , "::" , stringify ! ( selection_time ) ));
}
impl Clone for _GdkEventOwnerChange {
    fn clone(&self) -> Self { *self }
}
pub type GdkEventOwnerChange = _GdkEventOwnerChange;
/**
 * GdkEventProximity:
 * @type: the type of the event (%GDK_PROXIMITY_IN or %GDK_PROXIMITY_OUT).
 * @window: the window which received the event.
 * @send_event: %TRUE if the event was sent explicitly.
 * @time: the time of the event in milliseconds.
 * @device: the master device that the event originated from. Use
 * gdk_event_get_source_device() to get the slave device.
 *
 * Proximity events are generated when using GDKs wrapper for the
 * XInput extension. The XInput extension is an add-on for standard X
 * that allows you to use nonstandard devices such as graphics tablets.
 * A proximity event indicates that the stylus has moved in or out of
 * contact with the tablet, or perhaps that the users finger has moved
 * in or out of contact with a touch screen.
 *
 * This event type will be used pretty rarely. It only is important for
 * XInput aware programs that are drawing their own cursor.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkEventProximity {
    pub type_: GdkEventType,
    pub window: *mut GdkWindow,
    pub send_event: gint8,
    pub time: guint32,
    pub device: *mut GdkDevice,
}
#[test]
fn bindgen_test_layout__GdkEventProximity() {
    assert_eq!(::std::mem::size_of::<_GdkEventProximity>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( _GdkEventProximity ) ));
    assert_eq! (::std::mem::align_of::<_GdkEventProximity>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _GdkEventProximity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventProximity ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventProximity ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventProximity ) ) . window as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventProximity ) ,
                "::" , stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventProximity ) ) . send_event as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventProximity ) ,
                "::" , stringify ! ( send_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventProximity ) ) . time as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventProximity ) ,
                "::" , stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventProximity ) ) . device as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventProximity ) ,
                "::" , stringify ! ( device ) ));
}
impl Clone for _GdkEventProximity {
    fn clone(&self) -> Self { *self }
}
pub type GdkEventProximity = _GdkEventProximity;
/**
 * GdkEventDND:
 * @type: the type of the event (%GDK_DRAG_ENTER, %GDK_DRAG_LEAVE,
 *   %GDK_DRAG_MOTION, %GDK_DRAG_STATUS, %GDK_DROP_START or
 *   %GDK_DROP_FINISHED).
 * @window: the window which received the event.
 * @send_event: %TRUE if the event was sent explicitly.
 * @context: the #GdkDragContext for the current DND operation.
 * @time: the time of the event in milliseconds.
 * @x_root: the x coordinate of the pointer relative to the root of the
 *   screen, only set for %GDK_DRAG_MOTION and %GDK_DROP_START.
 * @y_root: the y coordinate of the pointer relative to the root of the
 *   screen, only set for %GDK_DRAG_MOTION and %GDK_DROP_START.
 *
 * Generated during DND operations.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkEventDND {
    pub type_: GdkEventType,
    pub window: *mut GdkWindow,
    pub send_event: gint8,
    pub context: *mut GdkDragContext,
    pub time: guint32,
    pub x_root: gshort,
    pub y_root: gshort,
}
#[test]
fn bindgen_test_layout__GdkEventDND() {
    assert_eq!(::std::mem::size_of::<_GdkEventDND>() , 40usize , concat ! (
               "Size of: " , stringify ! ( _GdkEventDND ) ));
    assert_eq! (::std::mem::align_of::<_GdkEventDND>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GdkEventDND ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventDND ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventDND ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventDND ) ) . window as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventDND ) , "::" ,
                stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventDND ) ) . send_event as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventDND ) , "::" ,
                stringify ! ( send_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventDND ) ) . context as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventDND ) , "::" ,
                stringify ! ( context ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventDND ) ) . time as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventDND ) , "::" ,
                stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventDND ) ) . x_root as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventDND ) , "::" ,
                stringify ! ( x_root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventDND ) ) . y_root as * const _ as
                usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventDND ) , "::" ,
                stringify ! ( y_root ) ));
}
impl Clone for _GdkEventDND {
    fn clone(&self) -> Self { *self }
}
pub type GdkEventDND = _GdkEventDND;
/**
 * GdkEventWindowState:
 * @type: the type of the event (%GDK_WINDOW_STATE).
 * @window: the window which received the event.
 * @send_event: %TRUE if the event was sent explicitly.
 * @changed_mask: mask specifying what flags have changed.
 * @new_window_state: the new window state, a combination of
 *   #GdkWindowState bits.
 *
 * Generated when the state of a toplevel window changes.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkEventWindowState {
    pub type_: GdkEventType,
    pub window: *mut GdkWindow,
    pub send_event: gint8,
    pub changed_mask: GdkWindowState,
    pub new_window_state: GdkWindowState,
}
#[test]
fn bindgen_test_layout__GdkEventWindowState() {
    assert_eq!(::std::mem::size_of::<_GdkEventWindowState>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( _GdkEventWindowState )
               ));
    assert_eq! (::std::mem::align_of::<_GdkEventWindowState>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GdkEventWindowState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventWindowState ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventWindowState )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventWindowState ) ) . window as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventWindowState )
                , "::" , stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventWindowState ) ) . send_event as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventWindowState )
                , "::" , stringify ! ( send_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventWindowState ) ) . changed_mask
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventWindowState )
                , "::" , stringify ! ( changed_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventWindowState ) ) .
                new_window_state as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! ( _GdkEventWindowState )
                , "::" , stringify ! ( new_window_state ) ));
}
impl Clone for _GdkEventWindowState {
    fn clone(&self) -> Self { *self }
}
pub type GdkEventWindowState = _GdkEventWindowState;
/**
 * GdkEventSetting:
 * @type: the type of the event (%GDK_SETTING).
 * @window: the window which received the event.
 * @send_event: %TRUE if the event was sent explicitly.
 * @action: what happened to the setting (%GDK_SETTING_ACTION_NEW,
 *   %GDK_SETTING_ACTION_CHANGED or %GDK_SETTING_ACTION_DELETED).
 * @name: the name of the setting.
 *
 * Generated when a setting is modified.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkEventSetting {
    pub type_: GdkEventType,
    pub window: *mut GdkWindow,
    pub send_event: gint8,
    pub action: GdkSettingAction,
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__GdkEventSetting() {
    assert_eq!(::std::mem::size_of::<_GdkEventSetting>() , 32usize , concat !
               ( "Size of: " , stringify ! ( _GdkEventSetting ) ));
    assert_eq! (::std::mem::align_of::<_GdkEventSetting>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _GdkEventSetting ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventSetting ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventSetting ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventSetting ) ) . window as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventSetting ) ,
                "::" , stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventSetting ) ) . send_event as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventSetting ) ,
                "::" , stringify ! ( send_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventSetting ) ) . action as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventSetting ) ,
                "::" , stringify ! ( action ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventSetting ) ) . name as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventSetting ) ,
                "::" , stringify ! ( name ) ));
}
impl Clone for _GdkEventSetting {
    fn clone(&self) -> Self { *self }
}
pub type GdkEventSetting = _GdkEventSetting;
/**
 * GdkEventGrabBroken:
 * @type: the type of the event (%GDK_GRAB_BROKEN)
 * @window: the window which received the event, i.e. the window
 *   that previously owned the grab
 * @send_event: %TRUE if the event was sent explicitly.
 * @keyboard: %TRUE if a keyboard grab was broken, %FALSE if a pointer
 *   grab was broken
 * @implicit: %TRUE if the broken grab was implicit
 * @grab_window: If this event is caused by another grab in the same
 *   application, @grab_window contains the new grab window. Otherwise
 *   @grab_window is %NULL.
 *
 * Generated when a pointer or keyboard grab is broken. On X11, this happens
 * when the grab window becomes unviewable (i.e. it or one of its ancestors
 * is unmapped), or if the same application grabs the pointer or keyboard
 * again. Note that implicit grabs (which are initiated by button presses)
 * can also cause #GdkEventGrabBroken events.
 *
 * Since: 2.8
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkEventGrabBroken {
    pub type_: GdkEventType,
    pub window: *mut GdkWindow,
    pub send_event: gint8,
    pub keyboard: gboolean,
    pub implicit: gboolean,
    pub grab_window: *mut GdkWindow,
}
#[test]
fn bindgen_test_layout__GdkEventGrabBroken() {
    assert_eq!(::std::mem::size_of::<_GdkEventGrabBroken>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( _GdkEventGrabBroken ) ));
    assert_eq! (::std::mem::align_of::<_GdkEventGrabBroken>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GdkEventGrabBroken ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventGrabBroken ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventGrabBroken ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventGrabBroken ) ) . window as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventGrabBroken ) ,
                "::" , stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventGrabBroken ) ) . send_event as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventGrabBroken ) ,
                "::" , stringify ! ( send_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventGrabBroken ) ) . keyboard as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventGrabBroken ) ,
                "::" , stringify ! ( keyboard ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventGrabBroken ) ) . implicit as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventGrabBroken ) ,
                "::" , stringify ! ( implicit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventGrabBroken ) ) . grab_window as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventGrabBroken ) ,
                "::" , stringify ! ( grab_window ) ));
}
impl Clone for _GdkEventGrabBroken {
    fn clone(&self) -> Self { *self }
}
pub type GdkEventGrabBroken = _GdkEventGrabBroken;
/**
 * GdkEventTouchpadSwipe:
 * @type: the type of the event (%GDK_TOUCHPAD_SWIPE)
 * @window: the window which received the event
 * @send_event: %TRUE if the event was sent explicitly
 * @phase: (type GdkTouchpadGesturePhase): the current phase of the gesture
 * @n_fingers: The number of fingers triggering the swipe
 * @time: the time of the event in milliseconds
 * @x: The X coordinate of the pointer
 * @y: The Y coordinate of the pointer
 * @dx: Movement delta in the X axis of the swipe focal point
 * @dy: Movement delta in the Y axis of the swipe focal point
 * @x_root: The X coordinate of the pointer, relative to the
 *   root of the screen.
 * @y_root: The Y coordinate of the pointer, relative to the
 *   root of the screen.
 * @state: (type GdkModifierType): a bit-mask representing the state of
 *   the modifier keys (e.g. Control, Shift and Alt) and the pointer
 *   buttons. See #GdkModifierType.
 *
 * Generated during touchpad swipe gestures.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkEventTouchpadSwipe {
    pub type_: GdkEventType,
    pub window: *mut GdkWindow,
    pub send_event: gint8,
    pub phase: gint8,
    pub n_fingers: gint8,
    pub time: guint32,
    pub x: gdouble,
    pub y: gdouble,
    pub dx: gdouble,
    pub dy: gdouble,
    pub x_root: gdouble,
    pub y_root: gdouble,
    pub state: guint,
}
#[test]
fn bindgen_test_layout__GdkEventTouchpadSwipe() {
    assert_eq!(::std::mem::size_of::<_GdkEventTouchpadSwipe>() , 80usize ,
               concat ! ( "Size of: " , stringify ! ( _GdkEventTouchpadSwipe )
               ));
    assert_eq! (::std::mem::align_of::<_GdkEventTouchpadSwipe>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GdkEventTouchpadSwipe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadSwipe ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadSwipe
                ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadSwipe ) ) . window as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadSwipe
                ) , "::" , stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadSwipe ) ) . send_event
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadSwipe
                ) , "::" , stringify ! ( send_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadSwipe ) ) . phase as *
                const _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadSwipe
                ) , "::" , stringify ! ( phase ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadSwipe ) ) . n_fingers as
                * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadSwipe
                ) , "::" , stringify ! ( n_fingers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadSwipe ) ) . time as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadSwipe
                ) , "::" , stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadSwipe ) ) . x as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadSwipe
                ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadSwipe ) ) . y as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadSwipe
                ) , "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadSwipe ) ) . dx as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadSwipe
                ) , "::" , stringify ! ( dx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadSwipe ) ) . dy as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadSwipe
                ) , "::" , stringify ! ( dy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadSwipe ) ) . x_root as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadSwipe
                ) , "::" , stringify ! ( x_root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadSwipe ) ) . y_root as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadSwipe
                ) , "::" , stringify ! ( y_root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadSwipe ) ) . state as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadSwipe
                ) , "::" , stringify ! ( state ) ));
}
impl Clone for _GdkEventTouchpadSwipe {
    fn clone(&self) -> Self { *self }
}
pub type GdkEventTouchpadSwipe = _GdkEventTouchpadSwipe;
/**
 * GdkEventTouchpadPinch:
 * @type: the type of the event (%GDK_TOUCHPAD_PINCH)
 * @window: the window which received the event
 * @send_event: %TRUE if the event was sent explicitly
 * @phase: (type GdkTouchpadGesturePhase): the current phase of the gesture
 * @n_fingers: The number of fingers triggering the pinch
 * @time: the time of the event in milliseconds
 * @x: The X coordinate of the pointer
 * @y: The Y coordinate of the pointer
 * @dx: Movement delta in the X axis of the swipe focal point
 * @dy: Movement delta in the Y axis of the swipe focal point
 * @angle_delta: The angle change in radians, negative angles
 *   denote counter-clockwise movements
 * @scale: The current scale, relative to that at the time of
 *   the corresponding %GDK_TOUCHPAD_GESTURE_PHASE_BEGIN event
 * @x_root: The X coordinate of the pointer, relative to the
 *   root of the screen.
 * @y_root: The Y coordinate of the pointer, relative to the
 *   root of the screen.
 * @state: (type GdkModifierType): a bit-mask representing the state of
 *   the modifier keys (e.g. Control, Shift and Alt) and the pointer
 *   buttons. See #GdkModifierType.
 *
 * Generated during touchpad swipe gestures.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkEventTouchpadPinch {
    pub type_: GdkEventType,
    pub window: *mut GdkWindow,
    pub send_event: gint8,
    pub phase: gint8,
    pub n_fingers: gint8,
    pub time: guint32,
    pub x: gdouble,
    pub y: gdouble,
    pub dx: gdouble,
    pub dy: gdouble,
    pub angle_delta: gdouble,
    pub scale: gdouble,
    pub x_root: gdouble,
    pub y_root: gdouble,
    pub state: guint,
}
#[test]
fn bindgen_test_layout__GdkEventTouchpadPinch() {
    assert_eq!(::std::mem::size_of::<_GdkEventTouchpadPinch>() , 96usize ,
               concat ! ( "Size of: " , stringify ! ( _GdkEventTouchpadPinch )
               ));
    assert_eq! (::std::mem::align_of::<_GdkEventTouchpadPinch>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GdkEventTouchpadPinch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadPinch ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadPinch
                ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadPinch ) ) . window as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadPinch
                ) , "::" , stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadPinch ) ) . send_event
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadPinch
                ) , "::" , stringify ! ( send_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadPinch ) ) . phase as *
                const _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadPinch
                ) , "::" , stringify ! ( phase ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadPinch ) ) . n_fingers as
                * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadPinch
                ) , "::" , stringify ! ( n_fingers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadPinch ) ) . time as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadPinch
                ) , "::" , stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadPinch ) ) . x as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadPinch
                ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadPinch ) ) . y as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadPinch
                ) , "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadPinch ) ) . dx as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadPinch
                ) , "::" , stringify ! ( dx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadPinch ) ) . dy as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadPinch
                ) , "::" , stringify ! ( dy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadPinch ) ) . angle_delta
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadPinch
                ) , "::" , stringify ! ( angle_delta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadPinch ) ) . scale as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadPinch
                ) , "::" , stringify ! ( scale ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadPinch ) ) . x_root as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadPinch
                ) , "::" , stringify ! ( x_root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadPinch ) ) . y_root as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadPinch
                ) , "::" , stringify ! ( y_root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEventTouchpadPinch ) ) . state as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEventTouchpadPinch
                ) , "::" , stringify ! ( state ) ));
}
impl Clone for _GdkEventTouchpadPinch {
    fn clone(&self) -> Self { *self }
}
pub type GdkEventTouchpadPinch = _GdkEventTouchpadPinch;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GdkEventSequence {
    _unused: [u8; 0],
}
pub type GdkEventSequence = _GdkEventSequence;
/**
 * GdkEvent:
 * @type: the #GdkEventType
 * @any: a #GdkEventAny
 * @expose: a #GdkEventExpose
 * @visibility: a #GdkEventVisibility
 * @motion: a #GdkEventMotion
 * @button: a #GdkEventButton
 * @touch: a #GdkEventTouch
 * @scroll: a #GdkEventScroll
 * @key: a #GdkEventKey
 * @crossing: a #GdkEventCrossing
 * @focus_change: a #GdkEventFocus
 * @configure: a #GdkEventConfigure
 * @property: a #GdkEventProperty
 * @selection: a #GdkEventSelection
 * @owner_change: a #GdkEventOwnerChange
 * @proximity: a #GdkEventProximity
 * @dnd: a #GdkEventDND
 * @window_state: a #GdkEventWindowState
 * @setting: a #GdkEventSetting
 * @grab_broken: a #GdkEventGrabBroken
 *
 * A #GdkEvent contains a union of all of the event types,
 * and allows access to the data fields in a number of ways.
 *
 * The event type is always the first field in all of the event types, and
 * can always be accessed with the following code, no matter what type of
 * event it is:
 * |[<!-- language="C" -->
 *   GdkEvent *event;
 *   GdkEventType type;
 *
 *   type = event->type;
 * ]|
 *
 * To access other fields of the event, the pointer to the event
 * can be cast to the appropriate event type, or the union member
 * name can be used. For example if the event type is %GDK_BUTTON_PRESS
 * then the x coordinate of the button press can be accessed with:
 * |[<!-- language="C" -->
 *   GdkEvent *event;
 *   gdouble x;
 *
 *   x = ((GdkEventButton*)event)->x;
 * ]|
 * or:
 * |[<!-- language="C" -->
 *   GdkEvent *event;
 *   gdouble x;
 *
 *   x = event->button.x;
 * ]|
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkEvent {
    pub type_: __BindgenUnionField<GdkEventType>,
    pub any: __BindgenUnionField<GdkEventAny>,
    pub expose: __BindgenUnionField<GdkEventExpose>,
    pub visibility: __BindgenUnionField<GdkEventVisibility>,
    pub motion: __BindgenUnionField<GdkEventMotion>,
    pub button: __BindgenUnionField<GdkEventButton>,
    pub touch: __BindgenUnionField<GdkEventTouch>,
    pub scroll: __BindgenUnionField<GdkEventScroll>,
    pub key: __BindgenUnionField<GdkEventKey>,
    pub crossing: __BindgenUnionField<GdkEventCrossing>,
    pub focus_change: __BindgenUnionField<GdkEventFocus>,
    pub configure: __BindgenUnionField<GdkEventConfigure>,
    pub property: __BindgenUnionField<GdkEventProperty>,
    pub selection: __BindgenUnionField<GdkEventSelection>,
    pub owner_change: __BindgenUnionField<GdkEventOwnerChange>,
    pub proximity: __BindgenUnionField<GdkEventProximity>,
    pub dnd: __BindgenUnionField<GdkEventDND>,
    pub window_state: __BindgenUnionField<GdkEventWindowState>,
    pub setting: __BindgenUnionField<GdkEventSetting>,
    pub grab_broken: __BindgenUnionField<GdkEventGrabBroken>,
    pub touchpad_swipe: __BindgenUnionField<GdkEventTouchpadSwipe>,
    pub touchpad_pinch: __BindgenUnionField<GdkEventTouchpadPinch>,
    pub bindgen_union_field: [u64; 12usize],
}
#[test]
fn bindgen_test_layout__GdkEvent() {
    assert_eq!(::std::mem::size_of::<_GdkEvent>() , 96usize , concat ! (
               "Size of: " , stringify ! ( _GdkEvent ) ));
    assert_eq! (::std::mem::align_of::<_GdkEvent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GdkEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEvent ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEvent ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEvent ) ) . any as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEvent ) , "::" ,
                stringify ! ( any ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEvent ) ) . expose as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEvent ) , "::" ,
                stringify ! ( expose ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEvent ) ) . visibility as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEvent ) , "::" ,
                stringify ! ( visibility ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEvent ) ) . motion as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEvent ) , "::" ,
                stringify ! ( motion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEvent ) ) . button as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEvent ) , "::" ,
                stringify ! ( button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEvent ) ) . touch as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEvent ) , "::" ,
                stringify ! ( touch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEvent ) ) . scroll as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEvent ) , "::" ,
                stringify ! ( scroll ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEvent ) ) . key as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEvent ) , "::" ,
                stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEvent ) ) . crossing as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEvent ) , "::" ,
                stringify ! ( crossing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEvent ) ) . focus_change as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEvent ) , "::" ,
                stringify ! ( focus_change ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEvent ) ) . configure as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEvent ) , "::" ,
                stringify ! ( configure ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEvent ) ) . property as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEvent ) , "::" ,
                stringify ! ( property ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEvent ) ) . selection as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEvent ) , "::" ,
                stringify ! ( selection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEvent ) ) . owner_change as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEvent ) , "::" ,
                stringify ! ( owner_change ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEvent ) ) . proximity as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEvent ) , "::" ,
                stringify ! ( proximity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEvent ) ) . dnd as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEvent ) , "::" ,
                stringify ! ( dnd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEvent ) ) . window_state as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEvent ) , "::" ,
                stringify ! ( window_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEvent ) ) . setting as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEvent ) , "::" ,
                stringify ! ( setting ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEvent ) ) . grab_broken as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEvent ) , "::" ,
                stringify ! ( grab_broken ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEvent ) ) . touchpad_swipe as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEvent ) , "::" ,
                stringify ! ( touchpad_swipe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GdkEvent ) ) . touchpad_pinch as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GdkEvent ) , "::" ,
                stringify ! ( touchpad_pinch ) ));
}
impl Clone for _GdkEvent {
    fn clone(&self) -> Self { *self }
}
pub type GdkEvent = _GdkEvent;
pub const GdkEventType_GDK_DOUBLE_BUTTON_PRESS: GdkEventType =
    GdkEventType::GDK_2BUTTON_PRESS;
pub const GdkEventType_GDK_TRIPLE_BUTTON_PRESS: GdkEventType =
    GdkEventType::GDK_3BUTTON_PRESS;
#[repr(i32)]
/**
 * GdkEventType:
 * @GDK_NOTHING: a special code to indicate a null event.
 * @GDK_DELETE: the window manager has requested that the toplevel window be
 *   hidden or destroyed, usually when the user clicks on a special icon in the
 *   title bar.
 * @GDK_DESTROY: the window has been destroyed.
 * @GDK_EXPOSE: all or part of the window has become visible and needs to be
 *   redrawn.
 * @GDK_MOTION_NOTIFY: the pointer (usually a mouse) has moved.
 * @GDK_BUTTON_PRESS: a mouse button has been pressed.
 * @GDK_2BUTTON_PRESS: a mouse button has been double-clicked (clicked twice
 *   within a short period of time). Note that each click also generates a
 *   %GDK_BUTTON_PRESS event.
 * @GDK_DOUBLE_BUTTON_PRESS: alias for %GDK_2BUTTON_PRESS, added in 3.6.
 * @GDK_3BUTTON_PRESS: a mouse button has been clicked 3 times in a short period
 *   of time. Note that each click also generates a %GDK_BUTTON_PRESS event.
 * @GDK_TRIPLE_BUTTON_PRESS: alias for %GDK_3BUTTON_PRESS, added in 3.6.
 * @GDK_BUTTON_RELEASE: a mouse button has been released.
 * @GDK_KEY_PRESS: a key has been pressed.
 * @GDK_KEY_RELEASE: a key has been released.
 * @GDK_ENTER_NOTIFY: the pointer has entered the window.
 * @GDK_LEAVE_NOTIFY: the pointer has left the window.
 * @GDK_FOCUS_CHANGE: the keyboard focus has entered or left the window.
 * @GDK_CONFIGURE: the size, position or stacking order of the window has changed.
 *   Note that GTK+ discards these events for %GDK_WINDOW_CHILD windows.
 * @GDK_MAP: the window has been mapped.
 * @GDK_UNMAP: the window has been unmapped.
 * @GDK_PROPERTY_NOTIFY: a property on the window has been changed or deleted.
 * @GDK_SELECTION_CLEAR: the application has lost ownership of a selection.
 * @GDK_SELECTION_REQUEST: another application has requested a selection.
 * @GDK_SELECTION_NOTIFY: a selection has been received.
 * @GDK_PROXIMITY_IN: an input device has moved into contact with a sensing
 *   surface (e.g. a touchscreen or graphics tablet).
 * @GDK_PROXIMITY_OUT: an input device has moved out of contact with a sensing
 *   surface.
 * @GDK_DRAG_ENTER: the mouse has entered the window while a drag is in progress.
 * @GDK_DRAG_LEAVE: the mouse has left the window while a drag is in progress.
 * @GDK_DRAG_MOTION: the mouse has moved in the window while a drag is in
 *   progress.
 * @GDK_DRAG_STATUS: the status of the drag operation initiated by the window
 *   has changed.
 * @GDK_DROP_START: a drop operation onto the window has started.
 * @GDK_DROP_FINISHED: the drop operation initiated by the window has completed.
 * @GDK_CLIENT_EVENT: a message has been received from another application.
 * @GDK_VISIBILITY_NOTIFY: the window visibility status has changed.
 * @GDK_SCROLL: the scroll wheel was turned
 * @GDK_WINDOW_STATE: the state of a window has changed. See #GdkWindowState
 *   for the possible window states
 * @GDK_SETTING: a setting has been modified.
 * @GDK_OWNER_CHANGE: the owner of a selection has changed. This event type
 *   was added in 2.6
 * @GDK_GRAB_BROKEN: a pointer or keyboard grab was broken. This event type
 *   was added in 2.8.
 * @GDK_DAMAGE: the content of the window has been changed. This event type
 *   was added in 2.14.
 * @GDK_TOUCH_BEGIN: A new touch event sequence has just started. This event
 *   type was added in 3.4.
 * @GDK_TOUCH_UPDATE: A touch event sequence has been updated. This event type
 *   was added in 3.4.
 * @GDK_TOUCH_END: A touch event sequence has finished. This event type
 *   was added in 3.4.
 * @GDK_TOUCH_CANCEL: A touch event sequence has been canceled. This event type
 *   was added in 3.4.
 * @GDK_TOUCHPAD_SWIPE: A touchpad swipe gesture event, the current state
 *   is determined by its phase field. This event type was added in 3.18.
 * @GDK_TOUCHPAD_PINCH: A touchpad pinch gesture event, the current state
 *   is determined by its phase field. This event type was added in 3.18.
 * @GDK_EVENT_LAST: marks the end of the GdkEventType enumeration. Added in 2.18
 *
 * Specifies the type of the event.
 *
 * Do not confuse these events with the signals that GTK+ widgets emit.
 * Although many of these events result in corresponding signals being emitted,
 * the events are often transformed or filtered along the way.
 *
 * In some language bindings, the values %GDK_2BUTTON_PRESS and
 * %GDK_3BUTTON_PRESS would translate into something syntactically
 * invalid (eg `Gdk.EventType.2ButtonPress`, where a
 * symbol is not allowed to start with a number). In that case, the
 * aliases %GDK_DOUBLE_BUTTON_PRESS and %GDK_TRIPLE_BUTTON_PRESS can
 * be used instead.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GdkEventType {
    GDK_NOTHING = -1,
    GDK_DELETE = 0,
    GDK_DESTROY = 1,
    GDK_EXPOSE = 2,
    GDK_MOTION_NOTIFY = 3,
    GDK_BUTTON_PRESS = 4,
    GDK_2BUTTON_PRESS = 5,
    GDK_3BUTTON_PRESS = 6,
    GDK_BUTTON_RELEASE = 7,
    GDK_KEY_PRESS = 8,
    GDK_KEY_RELEASE = 9,
    GDK_ENTER_NOTIFY = 10,
    GDK_LEAVE_NOTIFY = 11,
    GDK_FOCUS_CHANGE = 12,
    GDK_CONFIGURE = 13,
    GDK_MAP = 14,
    GDK_UNMAP = 15,
    GDK_PROPERTY_NOTIFY = 16,
    GDK_SELECTION_CLEAR = 17,
    GDK_SELECTION_REQUEST = 18,
    GDK_SELECTION_NOTIFY = 19,
    GDK_PROXIMITY_IN = 20,
    GDK_PROXIMITY_OUT = 21,
    GDK_DRAG_ENTER = 22,
    GDK_DRAG_LEAVE = 23,
    GDK_DRAG_MOTION = 24,
    GDK_DRAG_STATUS = 25,
    GDK_DROP_START = 26,
    GDK_DROP_FINISHED = 27,
    GDK_CLIENT_EVENT = 28,
    GDK_VISIBILITY_NOTIFY = 29,
    GDK_SCROLL = 31,
    GDK_WINDOW_STATE = 32,
    GDK_SETTING = 33,
    GDK_OWNER_CHANGE = 34,
    GDK_GRAB_BROKEN = 35,
    GDK_DAMAGE = 36,
    GDK_TOUCH_BEGIN = 37,
    GDK_TOUCH_UPDATE = 38,
    GDK_TOUCH_END = 39,
    GDK_TOUCH_CANCEL = 40,
    GDK_TOUCHPAD_SWIPE = 41,
    GDK_TOUCHPAD_PINCH = 42,
    GDK_EVENT_LAST = 43,
}
#[repr(u32)]
/**
 * GdkVisibilityState:
 * @GDK_VISIBILITY_UNOBSCURED: the window is completely visible.
 * @GDK_VISIBILITY_PARTIAL: the window is partially visible.
 * @GDK_VISIBILITY_FULLY_OBSCURED: the window is not visible at all.
 *
 * Specifies the visiblity status of a window for a #GdkEventVisibility.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GdkVisibilityState {
    GDK_VISIBILITY_UNOBSCURED = 0,
    GDK_VISIBILITY_PARTIAL = 1,
    GDK_VISIBILITY_FULLY_OBSCURED = 2,
}
#[repr(u32)]
/**
 * GdkScrollDirection:
 * @GDK_SCROLL_UP: the window is scrolled up.
 * @GDK_SCROLL_DOWN: the window is scrolled down.
 * @GDK_SCROLL_LEFT: the window is scrolled to the left.
 * @GDK_SCROLL_RIGHT: the window is scrolled to the right.
 * @GDK_SCROLL_SMOOTH: the scrolling is determined by the delta values
 *   in #GdkEventScroll. See gdk_event_get_scroll_deltas(). Since: 3.4
 *
 * Specifies the direction for #GdkEventScroll.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GdkScrollDirection {
    GDK_SCROLL_UP = 0,
    GDK_SCROLL_DOWN = 1,
    GDK_SCROLL_LEFT = 2,
    GDK_SCROLL_RIGHT = 3,
    GDK_SCROLL_SMOOTH = 4,
}
#[repr(u32)]
/**
 * GdkNotifyType:
 * @GDK_NOTIFY_ANCESTOR: the window is entered from an ancestor or
 *   left towards an ancestor.
 * @GDK_NOTIFY_VIRTUAL: the pointer moves between an ancestor and an
 *   inferior of the window.
 * @GDK_NOTIFY_INFERIOR: the window is entered from an inferior or
 *   left towards an inferior.
 * @GDK_NOTIFY_NONLINEAR: the window is entered from or left towards
 *   a window which is neither an ancestor nor an inferior.
 * @GDK_NOTIFY_NONLINEAR_VIRTUAL: the pointer moves between two windows
 *   which are not ancestors of each other and the window is part of
 *   the ancestor chain between one of these windows and their least
 *   common ancestor.
 * @GDK_NOTIFY_UNKNOWN: an unknown type of enter/leave event occurred.
 *
 * Specifies the kind of crossing for #GdkEventCrossing.
 *
 * See the X11 protocol specification of LeaveNotify for
 * full details of crossing event generation.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GdkNotifyType {
    GDK_NOTIFY_ANCESTOR = 0,
    GDK_NOTIFY_VIRTUAL = 1,
    GDK_NOTIFY_INFERIOR = 2,
    GDK_NOTIFY_NONLINEAR = 3,
    GDK_NOTIFY_NONLINEAR_VIRTUAL = 4,
    GDK_NOTIFY_UNKNOWN = 5,
}
#[repr(u32)]
/**
 * GdkCrossingMode:
 * @GDK_CROSSING_NORMAL: crossing because of pointer motion.
 * @GDK_CROSSING_GRAB: crossing because a grab is activated.
 * @GDK_CROSSING_UNGRAB: crossing because a grab is deactivated.
 * @GDK_CROSSING_GTK_GRAB: crossing because a GTK+ grab is activated.
 * @GDK_CROSSING_GTK_UNGRAB: crossing because a GTK+ grab is deactivated.
 * @GDK_CROSSING_STATE_CHANGED: crossing because a GTK+ widget changed
 *   state (e.g. sensitivity).
 * @GDK_CROSSING_TOUCH_BEGIN: crossing because a touch sequence has begun,
 *   this event is synthetic as the pointer might have not left the window.
 * @GDK_CROSSING_TOUCH_END: crossing because a touch sequence has ended,
 *   this event is synthetic as the pointer might have not left the window.
 * @GDK_CROSSING_DEVICE_SWITCH: crossing because of a device switch (i.e.
 *   a mouse taking control of the pointer after a touch device), this event
 *   is synthetic as the pointer didnt leave the window.
 *
 * Specifies the crossing mode for #GdkEventCrossing.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GdkCrossingMode {
    GDK_CROSSING_NORMAL = 0,
    GDK_CROSSING_GRAB = 1,
    GDK_CROSSING_UNGRAB = 2,
    GDK_CROSSING_GTK_GRAB = 3,
    GDK_CROSSING_GTK_UNGRAB = 4,
    GDK_CROSSING_STATE_CHANGED = 5,
    GDK_CROSSING_TOUCH_BEGIN = 6,
    GDK_CROSSING_TOUCH_END = 7,
    GDK_CROSSING_DEVICE_SWITCH = 8,
}
#[repr(u32)]
/**
 * GdkWindowState:
 * @GDK_WINDOW_STATE_WITHDRAWN: the window is not shown.
 * @GDK_WINDOW_STATE_ICONIFIED: the window is minimized.
 * @GDK_WINDOW_STATE_MAXIMIZED: the window is maximized.
 * @GDK_WINDOW_STATE_STICKY: the window is sticky.
 * @GDK_WINDOW_STATE_FULLSCREEN: the window is maximized without
 *   decorations.
 * @GDK_WINDOW_STATE_ABOVE: the window is kept above other windows.
 * @GDK_WINDOW_STATE_BELOW: the window is kept below other windows.
 * @GDK_WINDOW_STATE_FOCUSED: the window is presented as focused (with active decorations).
 * @GDK_WINDOW_STATE_TILED: the window is in a tiled state, Since 3.10
 *
 * Specifies the state of a toplevel window.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GdkWindowState {
    GDK_WINDOW_STATE_WITHDRAWN = 1,
    GDK_WINDOW_STATE_ICONIFIED = 2,
    GDK_WINDOW_STATE_MAXIMIZED = 4,
    GDK_WINDOW_STATE_STICKY = 8,
    GDK_WINDOW_STATE_FULLSCREEN = 16,
    GDK_WINDOW_STATE_ABOVE = 32,
    GDK_WINDOW_STATE_BELOW = 64,
    GDK_WINDOW_STATE_FOCUSED = 128,
    GDK_WINDOW_STATE_TILED = 256,
}
#[repr(u32)]
/**
 * GdkSettingAction:
 * @GDK_SETTING_ACTION_NEW: a setting was added.
 * @GDK_SETTING_ACTION_CHANGED: a setting was changed.
 * @GDK_SETTING_ACTION_DELETED: a setting was deleted.
 *
 * Specifies the kind of modification applied to a setting in a
 * #GdkEventSetting.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GdkSettingAction {
    GDK_SETTING_ACTION_NEW = 0,
    GDK_SETTING_ACTION_CHANGED = 1,
    GDK_SETTING_ACTION_DELETED = 2,
}
#[repr(u32)]
/**
 * GdkOwnerChange:
 * @GDK_OWNER_CHANGE_NEW_OWNER: some other app claimed the ownership
 * @GDK_OWNER_CHANGE_DESTROY: the window was destroyed
 * @GDK_OWNER_CHANGE_CLOSE: the client was closed
 *
 * Specifies why a selection ownership was changed.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GdkOwnerChange {
    GDK_OWNER_CHANGE_NEW_OWNER = 0,
    GDK_OWNER_CHANGE_DESTROY = 1,
    GDK_OWNER_CHANGE_CLOSE = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GdkPixbuf {
    _unused: [u8; 0],
}
/**
 * GdkPixbuf:
 * 
 * This is the main structure in the gdk-pixbuf library.  It is
 * used to represent images.  It contains information about the
 * image's pixel data, its color space, bits per sample, width and
 * height, and the rowstride (the number of bytes between the start of
 * one row and the start of the next). 
 */
pub type GdkPixbuf = _GdkPixbuf;
#[repr(u32)]
/**
 * GtkDeleteType:
 * @GTK_DELETE_CHARS: Delete characters.
 * @GTK_DELETE_WORD_ENDS: Delete only the portion of the word to the
 *   left/right of cursor if were in the middle of a word.
 * @GTK_DELETE_WORDS: Delete words.
 * @GTK_DELETE_DISPLAY_LINES: Delete display-lines. Display-lines
 *   refers to the visible lines, with respect to to the current line
 *   breaks. As opposed to paragraphs, which are defined by line
 *   breaks in the input.
 * @GTK_DELETE_DISPLAY_LINE_ENDS: Delete only the portion of the
 *   display-line to the left/right of cursor.
 * @GTK_DELETE_PARAGRAPH_ENDS: Delete to the end of the
 *   paragraph. Like C-k in Emacs (or its reverse).
 * @GTK_DELETE_PARAGRAPHS: Delete entire line. Like C-k in pico.
 * @GTK_DELETE_WHITESPACE: Delete only whitespace. Like M-\ in Emacs.
 *
 * See also: #GtkEntry::delete-from-cursor.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GtkDeleteType {
    GTK_DELETE_CHARS = 0,
    GTK_DELETE_WORD_ENDS = 1,
    GTK_DELETE_WORDS = 2,
    GTK_DELETE_DISPLAY_LINES = 3,
    GTK_DELETE_DISPLAY_LINE_ENDS = 4,
    GTK_DELETE_PARAGRAPH_ENDS = 5,
    GTK_DELETE_PARAGRAPHS = 6,
    GTK_DELETE_WHITESPACE = 7,
}
#[repr(u32)]
/**
 * GtkDirectionType:
 * @GTK_DIR_TAB_FORWARD: Move forward.
 * @GTK_DIR_TAB_BACKWARD: Move backward.
 * @GTK_DIR_UP: Move up.
 * @GTK_DIR_DOWN: Move down.
 * @GTK_DIR_LEFT: Move left.
 * @GTK_DIR_RIGHT: Move right.
 *
 * Focus movement types.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GtkDirectionType {
    GTK_DIR_TAB_FORWARD = 0,
    GTK_DIR_TAB_BACKWARD = 1,
    GTK_DIR_UP = 2,
    GTK_DIR_DOWN = 3,
    GTK_DIR_LEFT = 4,
    GTK_DIR_RIGHT = 5,
}
#[repr(u32)]
/**
 * GtkIconSize:
 * @GTK_ICON_SIZE_INVALID: Invalid size.
 * @GTK_ICON_SIZE_MENU: Size appropriate for menus (16px).
 * @GTK_ICON_SIZE_SMALL_TOOLBAR: Size appropriate for small toolbars (16px).
 * @GTK_ICON_SIZE_LARGE_TOOLBAR: Size appropriate for large toolbars (24px)
 * @GTK_ICON_SIZE_BUTTON: Size appropriate for buttons (16px)
 * @GTK_ICON_SIZE_DND: Size appropriate for drag and drop (32px)
 * @GTK_ICON_SIZE_DIALOG: Size appropriate for dialogs (48px)
 *
 * Built-in stock icon sizes.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GtkIconSize {
    GTK_ICON_SIZE_INVALID = 0,
    GTK_ICON_SIZE_MENU = 1,
    GTK_ICON_SIZE_SMALL_TOOLBAR = 2,
    GTK_ICON_SIZE_LARGE_TOOLBAR = 3,
    GTK_ICON_SIZE_BUTTON = 4,
    GTK_ICON_SIZE_DND = 5,
    GTK_ICON_SIZE_DIALOG = 6,
}
#[repr(u32)]
/**
 * GtkTextDirection:
 * @GTK_TEXT_DIR_NONE: No direction.
 * @GTK_TEXT_DIR_LTR: Left to right text direction.
 * @GTK_TEXT_DIR_RTL: Right to left text direction.
 *
 * Reading directions for text.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GtkTextDirection {
    GTK_TEXT_DIR_NONE = 0,
    GTK_TEXT_DIR_LTR = 1,
    GTK_TEXT_DIR_RTL = 2,
}
#[repr(u32)]
/**
 * GtkMenuDirectionType:
 * @GTK_MENU_DIR_PARENT: To the parent menu shell
 * @GTK_MENU_DIR_CHILD: To the submenu, if any, associated with the item
 * @GTK_MENU_DIR_NEXT: To the next menu item
 * @GTK_MENU_DIR_PREV: To the previous menu item
 *
 * An enumeration representing directional movements within a menu.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GtkMenuDirectionType {
    GTK_MENU_DIR_PARENT = 0,
    GTK_MENU_DIR_CHILD = 1,
    GTK_MENU_DIR_NEXT = 2,
    GTK_MENU_DIR_PREV = 3,
}
#[repr(u32)]
/**
 * GtkMovementStep:
 * @GTK_MOVEMENT_LOGICAL_POSITIONS: Move forward or back by graphemes
 * @GTK_MOVEMENT_VISUAL_POSITIONS:  Move left or right by graphemes
 * @GTK_MOVEMENT_WORDS:             Move forward or back by words
 * @GTK_MOVEMENT_DISPLAY_LINES:     Move up or down lines (wrapped lines)
 * @GTK_MOVEMENT_DISPLAY_LINE_ENDS: Move to either end of a line
 * @GTK_MOVEMENT_PARAGRAPHS:        Move up or down paragraphs (newline-ended lines)
 * @GTK_MOVEMENT_PARAGRAPH_ENDS:    Move to either end of a paragraph
 * @GTK_MOVEMENT_PAGES:             Move by pages
 * @GTK_MOVEMENT_BUFFER_ENDS:       Move to ends of the buffer
 * @GTK_MOVEMENT_HORIZONTAL_PAGES:  Move horizontally by pages
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GtkMovementStep {
    GTK_MOVEMENT_LOGICAL_POSITIONS = 0,
    GTK_MOVEMENT_VISUAL_POSITIONS = 1,
    GTK_MOVEMENT_WORDS = 2,
    GTK_MOVEMENT_DISPLAY_LINES = 3,
    GTK_MOVEMENT_DISPLAY_LINE_ENDS = 4,
    GTK_MOVEMENT_PARAGRAPHS = 5,
    GTK_MOVEMENT_PARAGRAPH_ENDS = 6,
    GTK_MOVEMENT_PAGES = 7,
    GTK_MOVEMENT_BUFFER_ENDS = 8,
    GTK_MOVEMENT_HORIZONTAL_PAGES = 9,
}
#[repr(u32)]
/**
 * GtkOrientation:
 * @GTK_ORIENTATION_HORIZONTAL: The element is in horizontal orientation.
 * @GTK_ORIENTATION_VERTICAL: The element is in vertical orientation.
 *
 * Represents the orientation of widgets and other objects which can be switched
 * between horizontal and vertical orientation on the fly, like #GtkToolbar or
 * #GtkGesturePan.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GtkOrientation {
    GTK_ORIENTATION_HORIZONTAL = 0,
    GTK_ORIENTATION_VERTICAL = 1,
}
#[repr(u32)]
/**
 * GtkScrollType:
 * @GTK_SCROLL_NONE: No scrolling.
 * @GTK_SCROLL_JUMP: Jump to new location.
 * @GTK_SCROLL_STEP_BACKWARD: Step backward.
 * @GTK_SCROLL_STEP_FORWARD: Step forward.
 * @GTK_SCROLL_PAGE_BACKWARD: Page backward.
 * @GTK_SCROLL_PAGE_FORWARD: Page forward.
 * @GTK_SCROLL_STEP_UP: Step up.
 * @GTK_SCROLL_STEP_DOWN: Step down.
 * @GTK_SCROLL_PAGE_UP: Page up.
 * @GTK_SCROLL_PAGE_DOWN: Page down.
 * @GTK_SCROLL_STEP_LEFT: Step to the left.
 * @GTK_SCROLL_STEP_RIGHT: Step to the right.
 * @GTK_SCROLL_PAGE_LEFT: Page to the left.
 * @GTK_SCROLL_PAGE_RIGHT: Page to the right.
 * @GTK_SCROLL_START: Scroll to start.
 * @GTK_SCROLL_END: Scroll to end.
 *
 * Scrolling types.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GtkScrollType {
    GTK_SCROLL_NONE = 0,
    GTK_SCROLL_JUMP = 1,
    GTK_SCROLL_STEP_BACKWARD = 2,
    GTK_SCROLL_STEP_FORWARD = 3,
    GTK_SCROLL_PAGE_BACKWARD = 4,
    GTK_SCROLL_PAGE_FORWARD = 5,
    GTK_SCROLL_STEP_UP = 6,
    GTK_SCROLL_STEP_DOWN = 7,
    GTK_SCROLL_PAGE_UP = 8,
    GTK_SCROLL_PAGE_DOWN = 9,
    GTK_SCROLL_STEP_LEFT = 10,
    GTK_SCROLL_STEP_RIGHT = 11,
    GTK_SCROLL_PAGE_LEFT = 12,
    GTK_SCROLL_PAGE_RIGHT = 13,
    GTK_SCROLL_START = 14,
    GTK_SCROLL_END = 15,
}
#[repr(u32)]
/**
 * GtkStateType:
 * @GTK_STATE_NORMAL: State during normal operation.
 * @GTK_STATE_ACTIVE: State of a currently active widget, such as a depressed button.
 * @GTK_STATE_PRELIGHT: State indicating that the mouse pointer is over
 *                      the widget and the widget will respond to mouse clicks.
 * @GTK_STATE_SELECTED: State of a selected item, such the selected row in a list.
 * @GTK_STATE_INSENSITIVE: State indicating that the widget is
 *                         unresponsive to user actions.
 * @GTK_STATE_INCONSISTENT: The widget is inconsistent, such as checkbuttons
 *                          or radiobuttons that arent either set to %TRUE nor %FALSE,
 *                          or buttons requiring the user attention.
 * @GTK_STATE_FOCUSED: The widget has the keyboard focus.
 *
 * This type indicates the current state of a widget; the state determines how
 * the widget is drawn. The #GtkStateType enumeration is also used to
 * identify different colors in a #GtkStyle for drawing, so states can be
 * used for subparts of a widget as well as entire widgets.
 *
 * Deprecated: 3.14: All APIs that are using this enumeration have been deprecated
 *     in favor of alternatives using #GtkStateFlags.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GtkStateType {
    GTK_STATE_NORMAL = 0,
    GTK_STATE_ACTIVE = 1,
    GTK_STATE_PRELIGHT = 2,
    GTK_STATE_SELECTED = 3,
    GTK_STATE_INSENSITIVE = 4,
    GTK_STATE_INCONSISTENT = 5,
    GTK_STATE_FOCUSED = 6,
}
#[repr(u32)]
/**
 * GtkToolbarStyle:
 * @GTK_TOOLBAR_ICONS: Buttons display only icons in the toolbar.
 * @GTK_TOOLBAR_TEXT: Buttons display only text labels in the toolbar.
 * @GTK_TOOLBAR_BOTH: Buttons display text and icons in the toolbar.
 * @GTK_TOOLBAR_BOTH_HORIZ: Buttons display icons and text alongside each
 *  other, rather than vertically stacked
 *
 * Used to customize the appearance of a #GtkToolbar. Note that
 * setting the toolbar style overrides the users preferences
 * for the default toolbar style.  Note that if the button has only
 * a label set and GTK_TOOLBAR_ICONS is used, the label will be
 * visible, and vice versa.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GtkToolbarStyle {
    GTK_TOOLBAR_ICONS = 0,
    GTK_TOOLBAR_TEXT = 1,
    GTK_TOOLBAR_BOTH = 2,
    GTK_TOOLBAR_BOTH_HORIZ = 3,
}
#[repr(u32)]
/**
 * GtkSortType:
 * @GTK_SORT_ASCENDING: Sorting is in ascending order.
 * @GTK_SORT_DESCENDING: Sorting is in descending order.
 *
 * Determines the direction of a sort.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GtkSortType { GTK_SORT_ASCENDING = 0, GTK_SORT_DESCENDING = 1, }
#[repr(u32)]
/**
 * GtkDragResult:
 * @GTK_DRAG_RESULT_SUCCESS: The drag operation was successful.
 * @GTK_DRAG_RESULT_NO_TARGET: No suitable drag target.
 * @GTK_DRAG_RESULT_USER_CANCELLED: The user cancelled the drag operation.
 * @GTK_DRAG_RESULT_TIMEOUT_EXPIRED: The drag operation timed out.
 * @GTK_DRAG_RESULT_GRAB_BROKEN: The pointer or keyboard grab used
 *  for the drag operation was broken.
 * @GTK_DRAG_RESULT_ERROR: The drag operation failed due to some
 *  unspecified error.
 *
 * Gives an indication why a drag operation failed.
 * The value can by obtained by connecting to the
 * #GtkWidget::drag-failed signal.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GtkDragResult {
    GTK_DRAG_RESULT_SUCCESS = 0,
    GTK_DRAG_RESULT_NO_TARGET = 1,
    GTK_DRAG_RESULT_USER_CANCELLED = 2,
    GTK_DRAG_RESULT_TIMEOUT_EXPIRED = 3,
    GTK_DRAG_RESULT_GRAB_BROKEN = 4,
    GTK_DRAG_RESULT_ERROR = 5,
}
#[repr(u32)]
/**
 * GtkSizeRequestMode:
 * @GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH: Prefer height-for-width geometry management
 * @GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT: Prefer width-for-height geometry management
 * @GTK_SIZE_REQUEST_CONSTANT_SIZE: Dont trade height-for-width or width-for-height
 * 
 * Specifies a preference for height-for-width or
 * width-for-height geometry management.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GtkSizeRequestMode {
    GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH = 0,
    GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT = 1,
    GTK_SIZE_REQUEST_CONSTANT_SIZE = 2,
}
#[repr(u32)]
/**
 * GtkStateFlags:
 * @GTK_STATE_FLAG_NORMAL: State during normal operation.
 * @GTK_STATE_FLAG_ACTIVE: Widget is active.
 * @GTK_STATE_FLAG_PRELIGHT: Widget has a mouse pointer over it.
 * @GTK_STATE_FLAG_SELECTED: Widget is selected.
 * @GTK_STATE_FLAG_INSENSITIVE: Widget is insensitive.
 * @GTK_STATE_FLAG_INCONSISTENT: Widget is inconsistent.
 * @GTK_STATE_FLAG_FOCUSED: Widget has the keyboard focus.
 * @GTK_STATE_FLAG_BACKDROP: Widget is in a background toplevel window.
 * @GTK_STATE_FLAG_DIR_LTR: Widget is in left-to-right text direction. Since 3.8
 * @GTK_STATE_FLAG_DIR_RTL: Widget is in right-to-left text direction. Since 3.8
 * @GTK_STATE_FLAG_LINK: Widget is a link. Since 3.12
 * @GTK_STATE_FLAG_VISITED: The location the widget points to has already been visited. Since 3.12
 * @GTK_STATE_FLAG_CHECKED: Widget is checked. Since 3.14
 *
 * Describes a widget state. Widget states are used to match the widget
 * against CSS pseudo-classes. Note that GTK extends the regular CSS
 * classes and sometimes uses different names.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GtkStateFlags {
    GTK_STATE_FLAG_NORMAL = 0,
    GTK_STATE_FLAG_ACTIVE = 1,
    GTK_STATE_FLAG_PRELIGHT = 2,
    GTK_STATE_FLAG_SELECTED = 4,
    GTK_STATE_FLAG_INSENSITIVE = 8,
    GTK_STATE_FLAG_INCONSISTENT = 16,
    GTK_STATE_FLAG_FOCUSED = 32,
    GTK_STATE_FLAG_BACKDROP = 64,
    GTK_STATE_FLAG_DIR_LTR = 128,
    GTK_STATE_FLAG_DIR_RTL = 256,
    GTK_STATE_FLAG_LINK = 512,
    GTK_STATE_FLAG_VISITED = 1024,
    GTK_STATE_FLAG_CHECKED = 2048,
}
/**
 * GtkBorder:
 * @left: The width of the left border
 * @right: The width of the right border
 * @top: The width of the top border
 * @bottom: The width of the bottom border
 *
 * A struct that specifies a border around a rectangular area
 * that can be of different width on each side.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkBorder {
    pub left: gint16,
    pub right: gint16,
    pub top: gint16,
    pub bottom: gint16,
}
#[test]
fn bindgen_test_layout__GtkBorder() {
    assert_eq!(::std::mem::size_of::<_GtkBorder>() , 8usize , concat ! (
               "Size of: " , stringify ! ( _GtkBorder ) ));
    assert_eq! (::std::mem::align_of::<_GtkBorder>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( _GtkBorder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkBorder ) ) . left as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkBorder ) , "::" ,
                stringify ! ( left ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkBorder ) ) . right as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkBorder ) , "::" ,
                stringify ! ( right ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkBorder ) ) . top as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkBorder ) , "::" ,
                stringify ! ( top ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkBorder ) ) . bottom as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkBorder ) , "::" ,
                stringify ! ( bottom ) ));
}
impl Clone for _GtkBorder {
    fn clone(&self) -> Self { *self }
}
pub type GtkBorder = _GtkBorder;
/**
 * GtkRcStyle:
 * @name: Name
 * @bg_pixmap_name: Pixmap name
 * @font_desc: A #PangoFontDescription
 * @color_flags: #GtkRcFlags
 * @fg: Foreground colors
 * @bg: Background colors
 * @text: Text colors
 * @base: Base colors
 * @xthickness: X thickness
 * @ythickness: Y thickness
 *
 * The #GtkRcStyle-struct is used to represent a set
 * of information about the appearance of a widget.
 * This can later be composited together with other
 * #GtkRcStyle-struct<!-- -->s to form a #GtkStyle.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkRcStyle {
    pub parent_instance: GObject,
    pub name: *mut gchar,
    pub bg_pixmap_name: [*mut gchar; 5usize],
    pub font_desc: *mut PangoFontDescription,
    pub color_flags: [GtkRcFlags; 5usize],
    pub fg: [GdkColor; 5usize],
    pub bg: [GdkColor; 5usize],
    pub text: [GdkColor; 5usize],
    pub base: [GdkColor; 5usize],
    pub xthickness: gint,
    pub ythickness: gint,
    pub rc_properties: *mut GArray,
    pub rc_style_lists: *mut GSList,
    pub icon_factories: *mut GSList,
    pub _bitfield_1: u8,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout__GtkRcStyle() {
    assert_eq!(::std::mem::size_of::<_GtkRcStyle>() , 384usize , concat ! (
               "Size of: " , stringify ! ( _GtkRcStyle ) ));
    assert_eq! (::std::mem::align_of::<_GtkRcStyle>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkRcStyle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkRcStyle ) ) . parent_instance as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkRcStyle ) , "::" ,
                stringify ! ( parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkRcStyle ) ) . name as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkRcStyle ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkRcStyle ) ) . bg_pixmap_name as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkRcStyle ) , "::" ,
                stringify ! ( bg_pixmap_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkRcStyle ) ) . font_desc as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkRcStyle ) , "::" ,
                stringify ! ( font_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkRcStyle ) ) . color_flags as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkRcStyle ) , "::" ,
                stringify ! ( color_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkRcStyle ) ) . fg as * const _ as
                usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkRcStyle ) , "::" ,
                stringify ! ( fg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkRcStyle ) ) . bg as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkRcStyle ) , "::" ,
                stringify ! ( bg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkRcStyle ) ) . text as * const _ as
                usize } , 220usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkRcStyle ) , "::" ,
                stringify ! ( text ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkRcStyle ) ) . base as * const _ as
                usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkRcStyle ) , "::" ,
                stringify ! ( base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkRcStyle ) ) . xthickness as * const _
                as usize } , 340usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkRcStyle ) , "::" ,
                stringify ! ( xthickness ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkRcStyle ) ) . ythickness as * const _
                as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkRcStyle ) , "::" ,
                stringify ! ( ythickness ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkRcStyle ) ) . rc_properties as *
                const _ as usize } , 352usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkRcStyle ) , "::" ,
                stringify ! ( rc_properties ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkRcStyle ) ) . rc_style_lists as *
                const _ as usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkRcStyle ) , "::" ,
                stringify ! ( rc_style_lists ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkRcStyle ) ) . icon_factories as *
                const _ as usize } , 368usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkRcStyle ) , "::" ,
                stringify ! ( icon_factories ) ));
}
impl Clone for _GtkRcStyle {
    fn clone(&self) -> Self { *self }
}
impl _GtkRcStyle {
    #[inline]
    pub fn engine_specified(&self) -> guint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_engine_specified(&mut self, val: guint) {
        let mask = 1u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(engine_specified: guint) -> u8 {
        ({ 0 } | ((engine_specified as u32 as u8) << 0usize) & (1u64 as u8))
    }
}
pub type GtkRcStyle = _GtkRcStyle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkSelectionData {
    _unused: [u8; 0],
}
pub type GtkSelectionData = _GtkSelectionData;
/**
 * GtkStyle:
 * @fg: Set of foreground #GdkColor
 * @bg: Set of background #GdkColor
 * @light: Set of light #GdkColor
 * @dark: Set of dark #GdkColor
 * @mid: Set of mid #GdkColor
 * @text: Set of text #GdkColor
 * @base: Set of base #GdkColor
 * @text_aa: Color halfway between text/base
 * @black: #GdkColor to use for black
 * @white: #GdkColor to use for white
 * @font_desc: #PangoFontDescription
 * @xthickness: Thickness in X direction
 * @ythickness: Thickness in Y direction
 * @background: Set of background #cairo_pattern_t
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkStyle {
    pub parent_instance: GObject,
    pub fg: [GdkColor; 5usize],
    pub bg: [GdkColor; 5usize],
    pub light: [GdkColor; 5usize],
    pub dark: [GdkColor; 5usize],
    pub mid: [GdkColor; 5usize],
    pub text: [GdkColor; 5usize],
    pub base: [GdkColor; 5usize],
    pub text_aa: [GdkColor; 5usize],
    pub black: GdkColor,
    pub white: GdkColor,
    pub font_desc: *mut PangoFontDescription,
    pub xthickness: gint,
    pub ythickness: gint,
    pub background: [*mut cairo_pattern_t; 5usize],
    pub attach_count: gint,
    pub visual: *mut GdkVisual,
    pub private_font_desc: *mut PangoFontDescription,
    pub rc_style: *mut GtkRcStyle,
    pub styles: *mut GSList,
    pub property_cache: *mut GArray,
    pub icon_factories: *mut GSList,
}
#[test]
fn bindgen_test_layout__GtkStyle() {
    assert_eq!(::std::mem::size_of::<_GtkStyle>() , 640usize , concat ! (
               "Size of: " , stringify ! ( _GtkStyle ) ));
    assert_eq! (::std::mem::align_of::<_GtkStyle>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkStyle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkStyle ) ) . parent_instance as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkStyle ) , "::" ,
                stringify ! ( parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkStyle ) ) . fg as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkStyle ) , "::" ,
                stringify ! ( fg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkStyle ) ) . bg as * const _ as usize
                } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkStyle ) , "::" ,
                stringify ! ( bg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkStyle ) ) . light as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkStyle ) , "::" ,
                stringify ! ( light ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkStyle ) ) . dark as * const _ as
                usize } , 204usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkStyle ) , "::" ,
                stringify ! ( dark ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkStyle ) ) . mid as * const _ as usize
                } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkStyle ) , "::" ,
                stringify ! ( mid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkStyle ) ) . text as * const _ as
                usize } , 324usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkStyle ) , "::" ,
                stringify ! ( text ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkStyle ) ) . base as * const _ as
                usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkStyle ) , "::" ,
                stringify ! ( base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkStyle ) ) . text_aa as * const _ as
                usize } , 444usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkStyle ) , "::" ,
                stringify ! ( text_aa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkStyle ) ) . black as * const _ as
                usize } , 504usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkStyle ) , "::" ,
                stringify ! ( black ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkStyle ) ) . white as * const _ as
                usize } , 516usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkStyle ) , "::" ,
                stringify ! ( white ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkStyle ) ) . font_desc as * const _ as
                usize } , 528usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkStyle ) , "::" ,
                stringify ! ( font_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkStyle ) ) . xthickness as * const _
                as usize } , 536usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkStyle ) , "::" ,
                stringify ! ( xthickness ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkStyle ) ) . ythickness as * const _
                as usize } , 540usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkStyle ) , "::" ,
                stringify ! ( ythickness ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkStyle ) ) . background as * const _
                as usize } , 544usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkStyle ) , "::" ,
                stringify ! ( background ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkStyle ) ) . attach_count as * const _
                as usize } , 584usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkStyle ) , "::" ,
                stringify ! ( attach_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkStyle ) ) . visual as * const _ as
                usize } , 592usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkStyle ) , "::" ,
                stringify ! ( visual ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkStyle ) ) . private_font_desc as *
                const _ as usize } , 600usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkStyle ) , "::" ,
                stringify ! ( private_font_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkStyle ) ) . rc_style as * const _ as
                usize } , 608usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkStyle ) , "::" ,
                stringify ! ( rc_style ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkStyle ) ) . styles as * const _ as
                usize } , 616usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkStyle ) , "::" ,
                stringify ! ( styles ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkStyle ) ) . property_cache as * const
                _ as usize } , 624usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkStyle ) , "::" ,
                stringify ! ( property_cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkStyle ) ) . icon_factories as * const
                _ as usize } , 632usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkStyle ) , "::" ,
                stringify ! ( icon_factories ) ));
}
impl Clone for _GtkStyle {
    fn clone(&self) -> Self { *self }
}
pub type GtkStyle = _GtkStyle;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkStyleContext {
    pub parent_object: GObject,
    pub priv_: *mut GtkStyleContextPrivate,
}
#[test]
fn bindgen_test_layout__GtkStyleContext() {
    assert_eq!(::std::mem::size_of::<_GtkStyleContext>() , 32usize , concat !
               ( "Size of: " , stringify ! ( _GtkStyleContext ) ));
    assert_eq! (::std::mem::align_of::<_GtkStyleContext>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _GtkStyleContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkStyleContext ) ) . parent_object as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkStyleContext ) ,
                "::" , stringify ! ( parent_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkStyleContext ) ) . priv_ as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkStyleContext ) ,
                "::" , stringify ! ( priv_ ) ));
}
impl Clone for _GtkStyleContext {
    fn clone(&self) -> Self { *self }
}
pub type GtkStyleContext = _GtkStyleContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkTooltip {
    _unused: [u8; 0],
}
pub type GtkTooltip = _GtkTooltip;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkWidget {
    pub parent_instance: GInitiallyUnowned,
    pub priv_: *mut GtkWidgetPrivate,
}
#[test]
fn bindgen_test_layout__GtkWidget() {
    assert_eq!(::std::mem::size_of::<_GtkWidget>() , 32usize , concat ! (
               "Size of: " , stringify ! ( _GtkWidget ) ));
    assert_eq! (::std::mem::align_of::<_GtkWidget>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkWidget ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidget ) ) . parent_instance as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidget ) , "::" ,
                stringify ! ( parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidget ) ) . priv_ as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidget ) , "::" ,
                stringify ! ( priv_ ) ));
}
impl Clone for _GtkWidget {
    fn clone(&self) -> Self { *self }
}
pub type GtkWidget = _GtkWidget;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkWidgetPath {
    _unused: [u8; 0],
}
pub type GtkWidgetPath = _GtkWidgetPath;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkWindow {
    pub bin: GtkBin,
    pub priv_: *mut GtkWindowPrivate,
}
#[test]
fn bindgen_test_layout__GtkWindow() {
    assert_eq!(::std::mem::size_of::<_GtkWindow>() , 56usize , concat ! (
               "Size of: " , stringify ! ( _GtkWindow ) ));
    assert_eq! (::std::mem::align_of::<_GtkWindow>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkWindow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWindow ) ) . bin as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWindow ) , "::" ,
                stringify ! ( bin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWindow ) ) . priv_ as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWindow ) , "::" ,
                stringify ! ( priv_ ) ));
}
impl Clone for _GtkWindow {
    fn clone(&self) -> Self { *self }
}
pub type GtkWindow = _GtkWindow;
#[repr(u32)]
/**
 *AtkRole:
 *@ATK_ROLE_INVALID: Invalid role
 *@ATK_ROLE_ACCEL_LABEL: A label which represents an accelerator
 *@ATK_ROLE_ALERT: An object which is an alert to the user. Assistive Technologies typically respond to ATK_ROLE_ALERT by reading the entire onscreen contents of containers advertising this role.  Should be used for warning dialogs, etc.
 *@ATK_ROLE_ANIMATION: An object which is an animated image
 *@ATK_ROLE_ARROW: An arrow in one of the four cardinal directions
 *@ATK_ROLE_CALENDAR:  An object that displays a calendar and allows the user to select a date
 *@ATK_ROLE_CANVAS: An object that can be drawn into and is used to trap events
 *@ATK_ROLE_CHECK_BOX: A choice that can be checked or unchecked and provides a separate indicator for the current state
 *@ATK_ROLE_CHECK_MENU_ITEM: A menu item with a check box
 *@ATK_ROLE_COLOR_CHOOSER: A specialized dialog that lets the user choose a color
 *@ATK_ROLE_COLUMN_HEADER: The header for a column of data
 *@ATK_ROLE_COMBO_BOX: A collapsible list of choices the user can select from
 *@ATK_ROLE_DATE_EDITOR: An object whose purpose is to allow a user to edit a date
 *@ATK_ROLE_DESKTOP_ICON: An inconifed internal frame within a DESKTOP_PANE
 *@ATK_ROLE_DESKTOP_FRAME: A pane that supports internal frames and iconified versions of those internal frames
 *@ATK_ROLE_DIAL: An object whose purpose is to allow a user to set a value
 *@ATK_ROLE_DIALOG: A top level window with title bar and a border
 *@ATK_ROLE_DIRECTORY_PANE: A pane that allows the user to navigate through and select the contents of a directory
 *@ATK_ROLE_DRAWING_AREA: An object used for drawing custom user interface elements
 *@ATK_ROLE_FILE_CHOOSER: A specialized dialog that lets the user choose a file
 *@ATK_ROLE_FILLER: A object that fills up space in a user interface
 *@ATK_ROLE_FONT_CHOOSER: A specialized dialog that lets the user choose a font
 *@ATK_ROLE_FRAME: A top level window with a title bar, border, menubar, etc.
 *@ATK_ROLE_GLASS_PANE: A pane that is guaranteed to be painted on top of all panes beneath it
 *@ATK_ROLE_HTML_CONTAINER: A document container for HTML, whose children represent the document content
 *@ATK_ROLE_ICON: A small fixed size picture, typically used to decorate components
 *@ATK_ROLE_IMAGE: An object whose primary purpose is to display an image
 *@ATK_ROLE_INTERNAL_FRAME: A frame-like object that is clipped by a desktop pane
 *@ATK_ROLE_LABEL: An object used to present an icon or short string in an interface
 *@ATK_ROLE_LAYERED_PANE: A specialized pane that allows its children to be drawn in layers, providing a form of stacking order
 *@ATK_ROLE_LIST: An object that presents a list of objects to the user and allows the user to select one or more of them 
 *@ATK_ROLE_LIST_ITEM: An object that represents an element of a list 
 *@ATK_ROLE_MENU: An object usually found inside a menu bar that contains a list of actions the user can choose from
 *@ATK_ROLE_MENU_BAR: An object usually drawn at the top of the primary dialog box of an application that contains a list of menus the user can choose from 
 *@ATK_ROLE_MENU_ITEM: An object usually contained in a menu that presents an action the user can choose
 *@ATK_ROLE_OPTION_PANE: A specialized pane whose primary use is inside a DIALOG
 *@ATK_ROLE_PAGE_TAB: An object that is a child of a page tab list
 *@ATK_ROLE_PAGE_TAB_LIST: An object that presents a series of panels (or page tabs), one at a time, through some mechanism provided by the object 
 *@ATK_ROLE_PANEL: A generic container that is often used to group objects
 *@ATK_ROLE_PASSWORD_TEXT: A text object uses for passwords, or other places where the text content is not shown visibly to the user
 *@ATK_ROLE_POPUP_MENU: A temporary window that is usually used to offer the user a list of choices, and then hides when the user selects one of those choices
 *@ATK_ROLE_PROGRESS_BAR: An object used to indicate how much of a task has been completed
 *@ATK_ROLE_PUSH_BUTTON: An object the user can manipulate to tell the application to do something
 *@ATK_ROLE_RADIO_BUTTON: A specialized check box that will cause other radio buttons in the same group to become unchecked when this one is checked
 *@ATK_ROLE_RADIO_MENU_ITEM: A check menu item which belongs to a group. At each instant exactly one of the radio menu items from a group is selected
 *@ATK_ROLE_ROOT_PANE: A specialized pane that has a glass pane and a layered pane as its children
 *@ATK_ROLE_ROW_HEADER: The header for a row of data
 *@ATK_ROLE_SCROLL_BAR: An object usually used to allow a user to incrementally view a large amount of data.
 *@ATK_ROLE_SCROLL_PANE: An object that allows a user to incrementally view a large amount of information
 *@ATK_ROLE_SEPARATOR: An object usually contained in a menu to provide a visible and logical separation of the contents in a menu
 *@ATK_ROLE_SLIDER: An object that allows the user to select from a bounded range
 *@ATK_ROLE_SPLIT_PANE: A specialized panel that presents two other panels at the same time
 *@ATK_ROLE_SPIN_BUTTON: An object used to get an integer or floating point number from the user
 *@ATK_ROLE_STATUSBAR: An object which reports messages of minor importance to the user
 *@ATK_ROLE_TABLE: An object used to represent information in terms of rows and columns
 *@ATK_ROLE_TABLE_CELL: A cell in a table
 *@ATK_ROLE_TABLE_COLUMN_HEADER: The header for a column of a table
 *@ATK_ROLE_TABLE_ROW_HEADER: The header for a row of a table
 *@ATK_ROLE_TEAR_OFF_MENU_ITEM: A menu item used to tear off and reattach its menu
 *@ATK_ROLE_TERMINAL: An object that represents an accessible terminal.  @Since: ATK-0.6
 *@ATK_ROLE_TEXT: An interactive widget that supports multiple lines of text and
 * optionally accepts user input, but whose purpose is not to solicit user input.
 * Thus ATK_ROLE_TEXT is appropriate for the text view in a plain text editor
 * but inappropriate for an input field in a dialog box or web form. For widgets
 * whose purpose is to solicit input from the user, see ATK_ROLE_ENTRY and
 * ATK_ROLE_PASSWORD_TEXT. For generic objects which display a brief amount of
 * textual information, see ATK_ROLE_STATIC.
 *@ATK_ROLE_TOGGLE_BUTTON: A specialized push button that can be checked or unchecked, but does not provide a separate indicator for the current state
 *@ATK_ROLE_TOOL_BAR: A bar or palette usually composed of push buttons or toggle buttons
 *@ATK_ROLE_TOOL_TIP: An object that provides information about another object
 *@ATK_ROLE_TREE: An object used to represent hierarchical information to the user
 *@ATK_ROLE_TREE_TABLE: An object capable of expanding and collapsing rows as well as showing multiple columns of data.   @Since: ATK-0.7
 *@ATK_ROLE_UNKNOWN: The object contains some Accessible information, but its role is not known
 *@ATK_ROLE_VIEWPORT: An object usually used in a scroll pane
 *@ATK_ROLE_WINDOW: A top level window with no title or border.
 *@ATK_ROLE_HEADER: An object that serves as a document header. @Since: ATK-1.1.1
 *@ATK_ROLE_FOOTER: An object that serves as a document footer.  @Since: ATK-1.1.1
 *@ATK_ROLE_PARAGRAPH: An object which is contains a paragraph of text content.   @Since: ATK-1.1.1
 *@ATK_ROLE_RULER: An object which describes margins and tab stops, etc. for text objects which it controls (should have CONTROLLER_FOR relation to such).   @Since: ATK-1.1.1
 *@ATK_ROLE_APPLICATION: The object is an application object, which may contain @ATK_ROLE_FRAME objects or other types of accessibles.  The root accessible of any application's ATK hierarchy should have ATK_ROLE_APPLICATION.   @Since: ATK-1.1.4
 *@ATK_ROLE_AUTOCOMPLETE: The object is a dialog or list containing items for insertion into an entry widget, for instance a list of words for completion of a text entry.   @Since: ATK-1.3
 *@ATK_ROLE_EDITBAR: The object is an editable text object in a toolbar.  @Since: ATK-1.5
 *@ATK_ROLE_EMBEDDED: The object is an embedded container within a document or panel.  This role is a grouping "hint" indicating that the contained objects share a context.  @Since: ATK-1.7.2
 *@ATK_ROLE_ENTRY: The object is a component whose textual content may be entered or modified by the user, provided @ATK_STATE_EDITABLE is present.   @Since: ATK-1.11
 *@ATK_ROLE_CHART: The object is a graphical depiction of quantitative data. It may contain multiple subelements whose attributes and/or description may be queried to obtain both the quantitative data and information about how the data is being presented. The LABELLED_BY relation is particularly important in interpreting objects of this type, as is the accessible-description property.  @Since: ATK-1.11
 *@ATK_ROLE_CAPTION: The object contains descriptive information, usually textual, about another user interface element such as a table, chart, or image.  @Since: ATK-1.11
 *@ATK_ROLE_DOCUMENT_FRAME: The object is a visual frame or container which contains a view of document content. Document frames may occur within another Document instance, in which case the second document may be said to be embedded in the containing instance. HTML frames are often ROLE_DOCUMENT_FRAME. Either this object, or a singleton descendant, should implement the Document interface.  @Since: ATK-1.11
 *@ATK_ROLE_HEADING: The object serves as a heading for content which follows it in a document. The 'heading level' of the heading, if availabe, may be obtained by querying the object's attributes.
 *@ATK_ROLE_PAGE: The object is a containing instance which encapsulates a page of information. @ATK_ROLE_PAGE is used in documents and content which support a paginated navigation model.  @Since: ATK-1.11
 *@ATK_ROLE_SECTION: The object is a containing instance of document content which constitutes a particular 'logical' section of the document. The type of content within a section, and the nature of the section division itself, may be obtained by querying the object's attributes. Sections may be nested. @Since: ATK-1.11
 *@ATK_ROLE_REDUNDANT_OBJECT: The object is redundant with another object in the hierarchy, and is exposed for purely technical reasons.  Objects of this role should normally be ignored by clients. @Since: ATK-1.11
 *@ATK_ROLE_FORM: The object is a container for form controls, for instance as part of a 
 * web form or user-input form within a document.  This role is primarily a tag/convenience for 
 * clients when navigating complex documents, it is not expected that ordinary GUI containers will 
 * always have ATK_ROLE_FORM. @Since: ATK-1.12.0
 *@ATK_ROLE_LINK: The object is a hypertext anchor, i.e. a "link" in a
 * hypertext document.  Such objects are distinct from 'inline'
 * content which may also use the Hypertext/Hyperlink interfaces
 * to indicate the range/location within a text object where
 * an inline or embedded object lies.  @Since: ATK-1.12.1
 *@ATK_ROLE_INPUT_METHOD_WINDOW: The object is a window or similar viewport 
 * which is used to allow composition or input of a 'complex character',
 * in other words it is an "input method window." @Since: ATK-1.12.1
 *@ATK_ROLE_TABLE_ROW: A row in a table.  @Since: ATK-2.1.0
 *@ATK_ROLE_TREE_ITEM: An object that represents an element of a tree.  @Since: ATK-2.1.0
 *@ATK_ROLE_DOCUMENT_SPREADSHEET: A document frame which contains a spreadsheet.  @Since: ATK-2.1.0
 *@ATK_ROLE_DOCUMENT_PRESENTATION: A document frame which contains a presentation or slide content.  @Since: ATK-2.1.0
 *@ATK_ROLE_DOCUMENT_TEXT: A document frame which contains textual content, such as found in a word processing application.  @Since: ATK-2.1.0
 *@ATK_ROLE_DOCUMENT_WEB: A document frame which contains HTML or other markup suitable for display in a web browser.  @Since: ATK-2.1.0
 *@ATK_ROLE_DOCUMENT_EMAIL: A document frame which contains email content to be displayed or composed either in plain text or HTML.  @Since: ATK-2.1.0
 *@ATK_ROLE_COMMENT: An object found within a document and designed to present a comment, note, or other annotation. In some cases, this object might not be visible until activated.  @Since: ATK-2.1.0
 *@ATK_ROLE_LIST_BOX: A non-collapsible list of choices the user can select from. @Since: ATK-2.1.0
 *@ATK_ROLE_GROUPING: A group of related widgets. This group typically has a label. @Since: ATK-2.1.0
 *@ATK_ROLE_IMAGE_MAP: An image map object. Usually a graphic with multiple hotspots, where each hotspot can be activated resulting in the loading of another document or section of a document. @Since: ATK-2.1.0
 *@ATK_ROLE_NOTIFICATION: A transitory object designed to present a message to the user, typically at the desktop level rather than inside a particular application.  @Since: ATK-2.1.0
 *@ATK_ROLE_INFO_BAR: An object designed to present a message to the user within an existing window. @Since: ATK-2.1.0
 *@ATK_ROLE_LEVEL_BAR: A bar that serves as a level indicator to, for instance, show the strength of a password or the state of a battery.  @Since: ATK-2.7.3
 *@ATK_ROLE_TITLE_BAR: A bar that serves as the title of a window or a
 * dialog. @Since: ATK-2.12
 *@ATK_ROLE_BLOCK_QUOTE: An object which contains a text section
 * that is quoted from another source. @Since: ATK-2.12
 *@ATK_ROLE_AUDIO: An object which represents an audio element. @Since: ATK-2.12
 *@ATK_ROLE_VIDEO: An object which represents a video element. @Since: ATK-2.12
 *@ATK_ROLE_DEFINITION: A definition of a term or concept. @Since: ATK-2.12
 *@ATK_ROLE_ARTICLE: A section of a page that consists of a
 * composition that forms an independent part of a document, page, or
 * site. Examples: A blog entry, a news story, a forum post. @Since:
 * ATK-2.12
 *@ATK_ROLE_LANDMARK: A region of a web page intended as a
 * navigational landmark. This is designed to allow Assistive
 * Technologies to provide quick navigation among key regions within a
 * document. @Since: ATK-2.12
 *@ATK_ROLE_LOG: A text widget or container holding log content, such
 * as chat history and error logs. In this role there is a
 * relationship between the arrival of new items in the log and the
 * reading order. The log contains a meaningful sequence and new
 * information is added only to the end of the log, not at arbitrary
 * points. @Since: ATK-2.12
 *@ATK_ROLE_MARQUEE: A container where non-essential information
 * changes frequently. Common usages of marquee include stock tickers
 * and ad banners. The primary difference between a marquee and a log
 * is that logs usually have a meaningful order or sequence of
 * important content changes. @Since: ATK-2.12
 *@ATK_ROLE_MATH: A text widget or container that holds a mathematical
 * expression. @Since: ATK-2.12
 *@ATK_ROLE_RATING: A widget whose purpose is to display a rating,
 * such as the number of stars associated with a song in a media
 * player. Objects of this role should also implement
 * AtkValue. @Since: ATK-2.12
 *@ATK_ROLE_TIMER: An object containing a numerical counter which
 * indicates an amount of elapsed time from a start point, or the time
 * remaining until an end point. @Since: ATK-2.12
 *@ATK_ROLE_DESCRIPTION_LIST: An object that represents a list of
 * term-value groups. A term-value group represents a individual
 * description and consist of one or more names
 * (ATK_ROLE_DESCRIPTION_TERM) followed by one or more values
 * (ATK_ROLE_DESCRIPTION_VALUE). For each list, there should not be
 * more than one group with the same term name. @Since: ATK-2.12
 *@ATK_ROLE_DESCRIPTION_TERM: An object that represents the term, or
 * name, part of a term-description group in a description
 * list. @Since: ATK-2.12
 *@ATK_ROLE_DESCRIPTION_VALUE: An object that represents the
 * description, definition or value of a term-description group in a
 * description list. The values within a group are alternatives,
 * meaning that you can have several ATK_ROLE_DESCRIPTION_VALUE for a
 * given ATK_ROLE_DESCRIPTION_TERM. @Since: ATK-2.12
 *@ATK_ROLE_STATIC: A generic non-container object whose purpose is to display a
 * brief amount of information to the user and whose role is known by the
 * implementor but lacks semantic value for the user. Examples in which
 * ATK_ROLE_STATIC is appropriate include the message displayed in a message box
 * and an image used as an alternative means to display text. ATK_ROLE_STATIC
 * should not be applied to widgets which are traditionally interactive, objects
 * which display a significant amount of content, or any object which has an
 * accessible relation pointing to another object. Implementors should expose the
 * displayed information through the accessible name of the object. If doing so seems
 * inappropriate, it may indicate that a different role should be used. For
 * labels which describe another widget, see ATK_ROLE_LABEL. For text views, see
 * ATK_ROLE_TEXT. For generic containers, see ATK_ROLE_PANEL. For objects whose
 * role is not known by the implementor, see ATK_ROLE_UNKNOWN. @Since: ATK-2.16.
 *@ATK_ROLE_MATH_FRACTION: An object that represents a mathematical fraction.
 * @Since: ATK-2.16.
 *@ATK_ROLE_MATH_ROOT: An object that represents a mathematical expression
 * displayed with a radical. @Since: ATK-2.16.
 *@ATK_ROLE_SUBSCRIPT: An object that contains text that is displayed as a
 * subscript. @Since: ATK-2.16.
 *@ATK_ROLE_SUPERSCRIPT: An object that contains text that is displayed as a
 * superscript. @Since: ATK-2.16.
 *@ATK_ROLE_LAST_DEFINED: not a valid role, used for finding end of the enumeration
 *
 * Describes the role of an object
 *
 * These are the built-in enumerated roles that UI components can have in
 * ATK.  Other roles may be added at runtime, so an AtkRole >=
 * ATK_ROLE_LAST_DEFINED is not necessarily an error.
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AtkRole {
    ATK_ROLE_INVALID = 0,
    ATK_ROLE_ACCEL_LABEL = 1,
    ATK_ROLE_ALERT = 2,
    ATK_ROLE_ANIMATION = 3,
    ATK_ROLE_ARROW = 4,
    ATK_ROLE_CALENDAR = 5,
    ATK_ROLE_CANVAS = 6,
    ATK_ROLE_CHECK_BOX = 7,
    ATK_ROLE_CHECK_MENU_ITEM = 8,
    ATK_ROLE_COLOR_CHOOSER = 9,
    ATK_ROLE_COLUMN_HEADER = 10,
    ATK_ROLE_COMBO_BOX = 11,
    ATK_ROLE_DATE_EDITOR = 12,
    ATK_ROLE_DESKTOP_ICON = 13,
    ATK_ROLE_DESKTOP_FRAME = 14,
    ATK_ROLE_DIAL = 15,
    ATK_ROLE_DIALOG = 16,
    ATK_ROLE_DIRECTORY_PANE = 17,
    ATK_ROLE_DRAWING_AREA = 18,
    ATK_ROLE_FILE_CHOOSER = 19,
    ATK_ROLE_FILLER = 20,
    ATK_ROLE_FONT_CHOOSER = 21,
    ATK_ROLE_FRAME = 22,
    ATK_ROLE_GLASS_PANE = 23,
    ATK_ROLE_HTML_CONTAINER = 24,
    ATK_ROLE_ICON = 25,
    ATK_ROLE_IMAGE = 26,
    ATK_ROLE_INTERNAL_FRAME = 27,
    ATK_ROLE_LABEL = 28,
    ATK_ROLE_LAYERED_PANE = 29,
    ATK_ROLE_LIST = 30,
    ATK_ROLE_LIST_ITEM = 31,
    ATK_ROLE_MENU = 32,
    ATK_ROLE_MENU_BAR = 33,
    ATK_ROLE_MENU_ITEM = 34,
    ATK_ROLE_OPTION_PANE = 35,
    ATK_ROLE_PAGE_TAB = 36,
    ATK_ROLE_PAGE_TAB_LIST = 37,
    ATK_ROLE_PANEL = 38,
    ATK_ROLE_PASSWORD_TEXT = 39,
    ATK_ROLE_POPUP_MENU = 40,
    ATK_ROLE_PROGRESS_BAR = 41,
    ATK_ROLE_PUSH_BUTTON = 42,
    ATK_ROLE_RADIO_BUTTON = 43,
    ATK_ROLE_RADIO_MENU_ITEM = 44,
    ATK_ROLE_ROOT_PANE = 45,
    ATK_ROLE_ROW_HEADER = 46,
    ATK_ROLE_SCROLL_BAR = 47,
    ATK_ROLE_SCROLL_PANE = 48,
    ATK_ROLE_SEPARATOR = 49,
    ATK_ROLE_SLIDER = 50,
    ATK_ROLE_SPLIT_PANE = 51,
    ATK_ROLE_SPIN_BUTTON = 52,
    ATK_ROLE_STATUSBAR = 53,
    ATK_ROLE_TABLE = 54,
    ATK_ROLE_TABLE_CELL = 55,
    ATK_ROLE_TABLE_COLUMN_HEADER = 56,
    ATK_ROLE_TABLE_ROW_HEADER = 57,
    ATK_ROLE_TEAR_OFF_MENU_ITEM = 58,
    ATK_ROLE_TERMINAL = 59,
    ATK_ROLE_TEXT = 60,
    ATK_ROLE_TOGGLE_BUTTON = 61,
    ATK_ROLE_TOOL_BAR = 62,
    ATK_ROLE_TOOL_TIP = 63,
    ATK_ROLE_TREE = 64,
    ATK_ROLE_TREE_TABLE = 65,
    ATK_ROLE_UNKNOWN = 66,
    ATK_ROLE_VIEWPORT = 67,
    ATK_ROLE_WINDOW = 68,
    ATK_ROLE_HEADER = 69,
    ATK_ROLE_FOOTER = 70,
    ATK_ROLE_PARAGRAPH = 71,
    ATK_ROLE_RULER = 72,
    ATK_ROLE_APPLICATION = 73,
    ATK_ROLE_AUTOCOMPLETE = 74,
    ATK_ROLE_EDITBAR = 75,
    ATK_ROLE_EMBEDDED = 76,
    ATK_ROLE_ENTRY = 77,
    ATK_ROLE_CHART = 78,
    ATK_ROLE_CAPTION = 79,
    ATK_ROLE_DOCUMENT_FRAME = 80,
    ATK_ROLE_HEADING = 81,
    ATK_ROLE_PAGE = 82,
    ATK_ROLE_SECTION = 83,
    ATK_ROLE_REDUNDANT_OBJECT = 84,
    ATK_ROLE_FORM = 85,
    ATK_ROLE_LINK = 86,
    ATK_ROLE_INPUT_METHOD_WINDOW = 87,
    ATK_ROLE_TABLE_ROW = 88,
    ATK_ROLE_TREE_ITEM = 89,
    ATK_ROLE_DOCUMENT_SPREADSHEET = 90,
    ATK_ROLE_DOCUMENT_PRESENTATION = 91,
    ATK_ROLE_DOCUMENT_TEXT = 92,
    ATK_ROLE_DOCUMENT_WEB = 93,
    ATK_ROLE_DOCUMENT_EMAIL = 94,
    ATK_ROLE_COMMENT = 95,
    ATK_ROLE_LIST_BOX = 96,
    ATK_ROLE_GROUPING = 97,
    ATK_ROLE_IMAGE_MAP = 98,
    ATK_ROLE_NOTIFICATION = 99,
    ATK_ROLE_INFO_BAR = 100,
    ATK_ROLE_LEVEL_BAR = 101,
    ATK_ROLE_TITLE_BAR = 102,
    ATK_ROLE_BLOCK_QUOTE = 103,
    ATK_ROLE_AUDIO = 104,
    ATK_ROLE_VIDEO = 105,
    ATK_ROLE_DEFINITION = 106,
    ATK_ROLE_ARTICLE = 107,
    ATK_ROLE_LANDMARK = 108,
    ATK_ROLE_LOG = 109,
    ATK_ROLE_MARQUEE = 110,
    ATK_ROLE_MATH = 111,
    ATK_ROLE_RATING = 112,
    ATK_ROLE_TIMER = 113,
    ATK_ROLE_DESCRIPTION_LIST = 114,
    ATK_ROLE_DESCRIPTION_TERM = 115,
    ATK_ROLE_DESCRIPTION_VALUE = 116,
    ATK_ROLE_STATIC = 117,
    ATK_ROLE_MATH_FRACTION = 118,
    ATK_ROLE_MATH_ROOT = 119,
    ATK_ROLE_SUBSCRIPT = 120,
    ATK_ROLE_SUPERSCRIPT = 121,
    ATK_ROLE_LAST_DEFINED = 122,
}
#[repr(u32)]
/**
 *AtkLayer:
 *@ATK_LAYER_INVALID: The object does not have a layer
 *@ATK_LAYER_BACKGROUND: This layer is reserved for the desktop background
 *@ATK_LAYER_CANVAS: This layer is used for Canvas components
 *@ATK_LAYER_WIDGET: This layer is normally used for components
 *@ATK_LAYER_MDI: This layer is used for layered components
 *@ATK_LAYER_POPUP: This layer is used for popup components, such as menus
 *@ATK_LAYER_OVERLAY: This layer is reserved for future use.
 *@ATK_LAYER_WINDOW: This layer is used for toplevel windows.
 *
 * Describes the layer of a component
 *
 * These enumerated "layer values" are used when determining which UI
 * rendering layer a component is drawn into, which can help in making
 * determinations of when components occlude one another.
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AtkLayer {
    ATK_LAYER_INVALID = 0,
    ATK_LAYER_BACKGROUND = 1,
    ATK_LAYER_CANVAS = 2,
    ATK_LAYER_WIDGET = 3,
    ATK_LAYER_MDI = 4,
    ATK_LAYER_POPUP = 5,
    ATK_LAYER_OVERLAY = 6,
    ATK_LAYER_WINDOW = 7,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _AtkObject {
    pub parent: GObject,
    pub description: *mut gchar,
    pub name: *mut gchar,
    pub accessible_parent: *mut AtkObject,
    pub role: AtkRole,
    pub relation_set: *mut AtkRelationSet,
    pub layer: AtkLayer,
}
#[test]
fn bindgen_test_layout__AtkObject() {
    assert_eq!(::std::mem::size_of::<_AtkObject>() , 72usize , concat ! (
               "Size of: " , stringify ! ( _AtkObject ) ));
    assert_eq! (::std::mem::align_of::<_AtkObject>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _AtkObject ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _AtkObject ) ) . parent as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _AtkObject ) , "::" ,
                stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _AtkObject ) ) . description as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _AtkObject ) , "::" ,
                stringify ! ( description ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _AtkObject ) ) . name as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _AtkObject ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _AtkObject ) ) . accessible_parent as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _AtkObject ) , "::" ,
                stringify ! ( accessible_parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _AtkObject ) ) . role as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _AtkObject ) , "::" ,
                stringify ! ( role ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _AtkObject ) ) . relation_set as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _AtkObject ) , "::" ,
                stringify ! ( relation_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _AtkObject ) ) . layer as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _AtkObject ) , "::" ,
                stringify ! ( layer ) ));
}
impl Clone for _AtkObject {
    fn clone(&self) -> Self { *self }
}
pub type AtkObject = _AtkObject;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _AtkRelationSet {
    pub parent: GObject,
    pub relations: *mut GPtrArray,
}
#[test]
fn bindgen_test_layout__AtkRelationSet() {
    assert_eq!(::std::mem::size_of::<_AtkRelationSet>() , 32usize , concat ! (
               "Size of: " , stringify ! ( _AtkRelationSet ) ));
    assert_eq! (::std::mem::align_of::<_AtkRelationSet>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _AtkRelationSet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _AtkRelationSet ) ) . parent as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _AtkRelationSet ) ,
                "::" , stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _AtkRelationSet ) ) . relations as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _AtkRelationSet ) ,
                "::" , stringify ! ( relations ) ));
}
impl Clone for _AtkRelationSet {
    fn clone(&self) -> Self { *self }
}
pub type AtkRelationSet = _AtkRelationSet;
#[repr(u32)]
/**
 * GtkWidgetHelpType:
 * @GTK_WIDGET_HELP_TOOLTIP: Tooltip.
 * @GTK_WIDGET_HELP_WHATS_THIS: Whats this.
 *
 * Kinds of widget-specific help. Used by the ::show-help signal.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GtkWidgetHelpType {
    GTK_WIDGET_HELP_TOOLTIP = 0,
    GTK_WIDGET_HELP_WHATS_THIS = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkWidgetPrivate {
    _unused: [u8; 0],
}
pub type GtkWidgetPrivate = _GtkWidgetPrivate;
/**
 * GtkWidgetClass:
 * @parent_class: The object class structure needs to be the first
 *   element in the widget class structure in order for the class mechanism
 *   to work correctly. This allows a GtkWidgetClass pointer to be cast to
 *   a GObjectClass pointer.
 * @activate_signal: The signal to emit when a widget of this class is
 *   activated, gtk_widget_activate() handles the emission.
 *   Implementation of this signal is optional.
 * @dispatch_child_properties_changed: Seldomly overidden.
 * @destroy: Signals that all holders of a reference to the widget
 *   should release the reference that they hold.
 * @show: Signal emitted when widget is shown
 * @show_all: Recursively shows a widget, and any child widgets (if the widget is
 * a container).
 * @hide: Signal emitted when widget is hidden.
 * @map: Signal emitted when widget is going to be mapped, that is
 *   when the widget is visible (which is controlled with
 *   gtk_widget_set_visible()) and all its parents up to the toplevel
 *   widget are also visible.
 * @unmap: Signal emitted when widget is going to be unmapped, which
 *   means that either it or any of its parents up to the toplevel
 *   widget have been set as hidden.
 * @realize: Signal emitted when widget is associated with a
 *   #GdkWindow, which means that gtk_widget_realize() has been called or
 *   the widget has been mapped (that is, it is going to be drawn).
 * @unrealize: Signal emitted when the GdkWindow associated with
 *   widget is destroyed, which means that gtk_widget_unrealize() has
 *   been called or the widget has been unmapped (that is, it is going
 *   to be hidden).
 * @size_allocate: Signal emitted to get the widget allocation.
 * @state_changed: Signal emitted when the widget state
 *   changes. Deprecated: 3.0
 * @state_flags_changed: Signal emitted when the widget state changes,
 *   see gtk_widget_get_state_flags().
 * @parent_set: Signal emitted when a new parent has been set on a
 *   widget.
 * @hierarchy_changed: Signal emitted when the anchored state of a
 *   widget changes.
 * @style_set: Signal emitted when a new style has been set on a
 * widget. Deprecated: 3.0
 * @direction_changed: Signal emitted when the text direction of a
 *   widget changes.
 * @grab_notify: Signal emitted when a widget becomes shadowed by a
 *   GTK+ grab (not a pointer or keyboard grab) on another widget, or
 *   when it becomes unshadowed due to a grab being removed.
 * @child_notify: Signal emitted for each child property that has
 *   changed on an object.
 * @draw: Signal emitted when a widget is supposed to render itself.
 * @get_request_mode: This allows a widget to tell its parent container whether
 *   it prefers to be allocated in %GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH or
 *   %GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT mode.
 *   %GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH means the widget prefers to have
 *   #GtkWidgetClass.get_preferred_width() called and then
 *   #GtkWidgetClass.get_preferred_height_for_width().
 *   %GTK_SIZE_REQUEST_CONSTANT_SIZE disables any height-for-width or
 *   width-for-height geometry management for a said widget and is the
 *   default return.
 *   Its important to note (as described below) that any widget
 *   which trades height-for-width or width-for-height must respond properly 
 *   to both of the virtual methods #GtkWidgetClass.get_preferred_height_for_width()
 *   and #GtkWidgetClass.get_preferred_width_for_height() since it might be 
 *   queried in either #GtkSizeRequestMode by its parent container.
 * @get_preferred_height: This is called by containers to obtain the minimum
 *   and natural height of a widget. A widget that does not actually trade
 *   any height for width or width for height only has to implement these
 *   two virtual methods (#GtkWidgetClass.get_preferred_width() and
 *   #GtkWidgetClass.get_preferred_height()).
 * @get_preferred_width_for_height: This is analogous to
 *   #GtkWidgetClass.get_preferred_height_for_width() except that it
 *   operates in the oposite orientation. Its rare that a widget actually
 *   does %GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT requests but this can happen
 *   when, for example, a widget or container gets additional columns to
 *   compensate for a smaller allocated height.
 * @get_preferred_width: This is called by containers to obtain the minimum
 *   and natural width of a widget. A widget will never be allocated a width
 *   less than its minimum and will only ever be allocated a width greater
 *   than the natural width once all of the said widgets siblings have
 *   received their natural widths.
 *   Furthermore, a widget will only ever be allocated a width greater than
 *   its natural width if it was configured to receive extra expand space
 *   from its parent container.
 * @get_preferred_height_for_width: This is similar to
 *   #GtkWidgetClass.get_preferred_height() except that it is passed a
 *   contextual width to request height for. By implementing this virtual
 *   method it is possible for a #GtkLabel to tell its parent how much height
 *   would be required if the label were to be allocated a said width.
 * @mnemonic_activate: Activates the @widget if @group_cycling is
 *   %FALSE, and just grabs the focus if @group_cycling is %TRUE.
 * @grab_focus: Causes @widget to have the keyboard focus for the
 *   #GtkWindow its inside.
 * @focus:
 * @move_focus: Signal emitted when a change of focus is requested
 * @keynav_failed: Signal emitted if keyboard navigation fails.
 * @event: The GTK+ main loop will emit three signals for each GDK
 *   event delivered to a widget: one generic ::event signal, another,
 *   more specific, signal that matches the type of event delivered
 *   (e.g. "key-press-event") and finally a generic "event-after"
 *   signal.
 * @button_press_event: Signal will be emitted when a button
 *   (typically from a mouse) is pressed.
 * @button_release_event: Signal will be emitted when a button
 *   (typically from a mouse) is released.
 * @scroll_event: Signal emitted when a button in the 4 to 7 range is
 *   pressed.
 * @motion_notify_event: Signal emitted when the pointer moves over
 *   the widgets #GdkWindow.
 * @delete_event: Signal emitted if a user requests that a toplevel
 *   window is closed.
 * @destroy_event: Signal is emitted when a #GdkWindow is destroyed.
 * @key_press_event: Signal emitted when a key is pressed.
 * @key_release_event: Signal is emitted when a key is released.
 * @enter_notify_event: Signal event will be emitted when the pointer
 *   enters the widgets window.
 * @leave_notify_event: Will be emitted when the pointer leaves the
 *   widgets window.
 * @configure_event: Signal will be emitted when the size, position or
 *   stacking of the widgets window has changed.
 * @focus_in_event: Signal emitted when the keyboard focus enters the
 * widgets window.
 * @focus_out_event: Signal emitted when the keyboard focus leaves the
 * widgets window.
 * @map_event: Signal emitted when the widgets window is mapped.
 * @unmap_event: Signal will be emitted when the widgets window is
 *   unmapped.
 * @property_notify_event: Signal will be emitted when a property on
 *   the widgets window has been changed or deleted.
 * @selection_clear_event: Signal will be emitted when the the
 *   widgets window has lost ownership of a selection.
 * @selection_request_event: Signal will be emitted when another
 *   client requests ownership of the selection owned by the widget's
 *   window.
 * @selection_notify_event:
 * @proximity_in_event:
 * @proximity_out_event:
 * @visibility_notify_event: Signal emitted when the widgets window is
 *   obscured or unobscured.
 * @window_state_event: Signal emitted when the state of the toplevel
 *   window associated to the widget changes.
 * @damage_event: Signal emitted when a redirected window belonging to
 *   widget gets drawn into.
 * @grab_broken_event: Signal emitted when a pointer or keyboard grab
 *   on a window belonging to widget gets broken.
 * @selection_get:
 * @selection_received:
 * @drag_begin: Signal emitted on the drag source when a drag is
 *   started.
 * @drag_end: Signal emitted on the drag source when a drag is
 *   finished.
 * @drag_data_get: Signal emitted on the drag source when the drop
 *   site requests the data which is dragged.
 * @drag_data_delete: Signal emitted on the drag source when a drag
 *   with the action %GDK_ACTION_MOVE is successfully completed.
 * @drag_leave: Signal emitted on the drop site when the cursor leaves
 *   the widget.
 * @drag_motion: signal emitted on the drop site when the user moves
 *   the cursor over the widget during a drag.
 * @drag_drop: Signal emitted on the drop site when the user drops the
 *   data onto the widget.
 * @drag_data_received: Signal emitted on the drop site when the
 *   dragged data has been received.
 * @drag_failed: Signal emitted on the drag source when a drag has
 *   failed.
 * @popup_menu: Signal emitted whenever a widget should pop up a
 *   context menu.
 * @show_help:
 * @get_accessible: Returns the accessible object that describes the
 *   widget to an assistive technology.
 * @screen_changed: Signal emitted when the screen of a widget has
 *   changed.
 * @can_activate_accel: Signal allows applications and derived widgets
 *   to override the default GtkWidget handling for determining whether
 *   an accelerator can be activated.
 * @composited_changed: Signal emitted when the composited status of
 *   widgets screen changes. See gdk_screen_is_composited().
 * @query_tooltip: Signal emitted when has-tooltip is %TRUE and the
 *   hover timeout has expired with the cursor hovering above
 *   widget; or emitted when widget got focus in keyboard mode.
 * @compute_expand: Computes whether a container should give this
 *   widget extra space when possible.
 * @adjust_size_request: Convert an initial size request from a widget's
 *   #GtkSizeRequestMode virtual method implementations into a size request to
 *   be used by parent containers in laying out the widget.
 *   adjust_size_request adjusts from a child widget's
 *   original request to what a parent container should
 *   use for layout. The @for_size argument will be -1 if the request should
 *   not be for a particular size in the opposing orientation, i.e. if the
 *   request is not height-for-width or width-for-height. If @for_size is
 *   greater than -1, it is the proposed allocation in the opposing
 *   orientation that we need the request for. Implementations of
 *   adjust_size_request should chain up to the default implementation,
 *   which applies #GtkWidgets margin properties and imposes any values
 *   from gtk_widget_set_size_request(). Chaining up should be last,
 *   after your subclass adjusts the request, so
 *   #GtkWidget can apply constraints and add the margin properly.
 * @adjust_size_allocation: Convert an initial size allocation assigned
 *   by a #GtkContainer using gtk_widget_size_allocate(), into an actual
 *   size allocation to be used by the widget. adjust_size_allocation
 *   adjusts to a child widgets actual allocation
 *   from what a parent container computed for the
 *   child. The adjusted allocation must be entirely within the original
 *   allocation. In any custom implementation, chain up to the default
 *   #GtkWidget implementation of this method, which applies the margin
 *   and alignment properties of #GtkWidget. Chain up
 *   before performing your own adjustments so your
 *   own adjustments remove more allocation after the #GtkWidget base
 *   class has already removed margin and alignment. The natural size
 *   passed in should be adjusted in the same way as the allocated size,
 *   which allows adjustments to perform alignments or other changes
 *   based on natural size.
 * @style_updated: Signal emitted when the GtkStyleContext of a widget
 *   is changed.
 * @touch_event:
 * @get_preferred_height_and_baseline_for_width:
 * @adjust_baseline_request:
 * @adjust_baseline_allocation:
 * @queue_draw_region: Invalidates the area of widget defined by
 *   region by calling gdk_window_invalidate_region() on the widget's
 *   window and all its child windows.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkWidgetClass {
    pub parent_class: GInitiallyUnownedClass,
    pub activate_signal: guint,
    pub dispatch_child_properties_changed: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                                          *mut GtkWidget,
                                                                                      n_pspecs:
                                                                                          guint,
                                                                                      pspecs:
                                                                                          *mut *mut GParamSpec)>,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                *mut GtkWidget)>,
    pub show: ::std::option::Option<unsafe extern "C" fn(widget:
                                                             *mut GtkWidget)>,
    pub show_all: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                 *mut GtkWidget)>,
    pub hide: ::std::option::Option<unsafe extern "C" fn(widget:
                                                             *mut GtkWidget)>,
    pub map: ::std::option::Option<unsafe extern "C" fn(widget:
                                                            *mut GtkWidget)>,
    pub unmap: ::std::option::Option<unsafe extern "C" fn(widget:
                                                              *mut GtkWidget)>,
    pub realize: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                *mut GtkWidget)>,
    pub unrealize: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                  *mut GtkWidget)>,
    pub size_allocate: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                      *mut GtkWidget,
                                                                  allocation:
                                                                      *mut GtkAllocation)>,
    pub state_changed: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                      *mut GtkWidget,
                                                                  previous_state:
                                                                      GtkStateType)>,
    pub state_flags_changed: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                            *mut GtkWidget,
                                                                        previous_state_flags:
                                                                            GtkStateFlags)>,
    pub parent_set: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                   *mut GtkWidget,
                                                               previous_parent:
                                                                   *mut GtkWidget)>,
    pub hierarchy_changed: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                          *mut GtkWidget,
                                                                      previous_toplevel:
                                                                          *mut GtkWidget)>,
    pub style_set: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                  *mut GtkWidget,
                                                              previous_style:
                                                                  *mut GtkStyle)>,
    pub direction_changed: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                          *mut GtkWidget,
                                                                      previous_direction:
                                                                          GtkTextDirection)>,
    pub grab_notify: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                    *mut GtkWidget,
                                                                was_grabbed:
                                                                    gboolean)>,
    pub child_notify: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                     *mut GtkWidget,
                                                                 child_property:
                                                                     *mut GParamSpec)>,
    pub draw: ::std::option::Option<unsafe extern "C" fn(widget:
                                                             *mut GtkWidget,
                                                         cr: *mut cairo_t)
                                        -> gboolean>,
    pub get_request_mode: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                         *mut GtkWidget)
                                                    -> GtkSizeRequestMode>,
    pub get_preferred_height: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                             *mut GtkWidget,
                                                                         minimum_height:
                                                                             *mut gint,
                                                                         natural_height:
                                                                             *mut gint)>,
    pub get_preferred_width_for_height: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                                       *mut GtkWidget,
                                                                                   height:
                                                                                       gint,
                                                                                   minimum_width:
                                                                                       *mut gint,
                                                                                   natural_width:
                                                                                       *mut gint)>,
    pub get_preferred_width: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                            *mut GtkWidget,
                                                                        minimum_width:
                                                                            *mut gint,
                                                                        natural_width:
                                                                            *mut gint)>,
    pub get_preferred_height_for_width: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                                       *mut GtkWidget,
                                                                                   width:
                                                                                       gint,
                                                                                   minimum_height:
                                                                                       *mut gint,
                                                                                   natural_height:
                                                                                       *mut gint)>,
    pub mnemonic_activate: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                          *mut GtkWidget,
                                                                      group_cycling:
                                                                          gboolean)
                                                     -> gboolean>,
    pub grab_focus: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                   *mut GtkWidget)>,
    pub focus: ::std::option::Option<unsafe extern "C" fn(widget:
                                                              *mut GtkWidget,
                                                          direction:
                                                              GtkDirectionType)
                                         -> gboolean>,
    pub move_focus: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                   *mut GtkWidget,
                                                               direction:
                                                                   GtkDirectionType)>,
    pub keynav_failed: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                      *mut GtkWidget,
                                                                  direction:
                                                                      GtkDirectionType)
                                                 -> gboolean>,
    pub event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                              *mut GtkWidget,
                                                          event:
                                                              *mut GdkEvent)
                                         -> gboolean>,
    pub button_press_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                           *mut GtkWidget,
                                                                       event:
                                                                           *mut GdkEventButton)
                                                      -> gboolean>,
    pub button_release_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                             *mut GtkWidget,
                                                                         event:
                                                                             *mut GdkEventButton)
                                                        -> gboolean>,
    pub scroll_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                     *mut GtkWidget,
                                                                 event:
                                                                     *mut GdkEventScroll)
                                                -> gboolean>,
    pub motion_notify_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                            *mut GtkWidget,
                                                                        event:
                                                                            *mut GdkEventMotion)
                                                       -> gboolean>,
    pub delete_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                     *mut GtkWidget,
                                                                 event:
                                                                     *mut GdkEventAny)
                                                -> gboolean>,
    pub destroy_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                      *mut GtkWidget,
                                                                  event:
                                                                      *mut GdkEventAny)
                                                 -> gboolean>,
    pub key_press_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                        *mut GtkWidget,
                                                                    event:
                                                                        *mut GdkEventKey)
                                                   -> gboolean>,
    pub key_release_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                          *mut GtkWidget,
                                                                      event:
                                                                          *mut GdkEventKey)
                                                     -> gboolean>,
    pub enter_notify_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                           *mut GtkWidget,
                                                                       event:
                                                                           *mut GdkEventCrossing)
                                                      -> gboolean>,
    pub leave_notify_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                           *mut GtkWidget,
                                                                       event:
                                                                           *mut GdkEventCrossing)
                                                      -> gboolean>,
    pub configure_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                        *mut GtkWidget,
                                                                    event:
                                                                        *mut GdkEventConfigure)
                                                   -> gboolean>,
    pub focus_in_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                       *mut GtkWidget,
                                                                   event:
                                                                       *mut GdkEventFocus)
                                                  -> gboolean>,
    pub focus_out_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                        *mut GtkWidget,
                                                                    event:
                                                                        *mut GdkEventFocus)
                                                   -> gboolean>,
    pub map_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                  *mut GtkWidget,
                                                              event:
                                                                  *mut GdkEventAny)
                                             -> gboolean>,
    pub unmap_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                    *mut GtkWidget,
                                                                event:
                                                                    *mut GdkEventAny)
                                               -> gboolean>,
    pub property_notify_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                              *mut GtkWidget,
                                                                          event:
                                                                              *mut GdkEventProperty)
                                                         -> gboolean>,
    pub selection_clear_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                              *mut GtkWidget,
                                                                          event:
                                                                              *mut GdkEventSelection)
                                                         -> gboolean>,
    pub selection_request_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                                *mut GtkWidget,
                                                                            event:
                                                                                *mut GdkEventSelection)
                                                           -> gboolean>,
    pub selection_notify_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                               *mut GtkWidget,
                                                                           event:
                                                                               *mut GdkEventSelection)
                                                          -> gboolean>,
    pub proximity_in_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                           *mut GtkWidget,
                                                                       event:
                                                                           *mut GdkEventProximity)
                                                      -> gboolean>,
    pub proximity_out_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                            *mut GtkWidget,
                                                                        event:
                                                                            *mut GdkEventProximity)
                                                       -> gboolean>,
    pub visibility_notify_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                                *mut GtkWidget,
                                                                            event:
                                                                                *mut GdkEventVisibility)
                                                           -> gboolean>,
    pub window_state_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                           *mut GtkWidget,
                                                                       event:
                                                                           *mut GdkEventWindowState)
                                                      -> gboolean>,
    pub damage_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                     *mut GtkWidget,
                                                                 event:
                                                                     *mut GdkEventExpose)
                                                -> gboolean>,
    pub grab_broken_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                          *mut GtkWidget,
                                                                      event:
                                                                          *mut GdkEventGrabBroken)
                                                     -> gboolean>,
    pub selection_get: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                      *mut GtkWidget,
                                                                  selection_data:
                                                                      *mut GtkSelectionData,
                                                                  info: guint,
                                                                  time_:
                                                                      guint)>,
    pub selection_received: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                           *mut GtkWidget,
                                                                       selection_data:
                                                                           *mut GtkSelectionData,
                                                                       time_:
                                                                           guint)>,
    pub drag_begin: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                   *mut GtkWidget,
                                                               context:
                                                                   *mut GdkDragContext)>,
    pub drag_end: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                 *mut GtkWidget,
                                                             context:
                                                                 *mut GdkDragContext)>,
    pub drag_data_get: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                      *mut GtkWidget,
                                                                  context:
                                                                      *mut GdkDragContext,
                                                                  selection_data:
                                                                      *mut GtkSelectionData,
                                                                  info: guint,
                                                                  time_:
                                                                      guint)>,
    pub drag_data_delete: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                         *mut GtkWidget,
                                                                     context:
                                                                         *mut GdkDragContext)>,
    pub drag_leave: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                   *mut GtkWidget,
                                                               context:
                                                                   *mut GdkDragContext,
                                                               time_: guint)>,
    pub drag_motion: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                    *mut GtkWidget,
                                                                context:
                                                                    *mut GdkDragContext,
                                                                x: gint,
                                                                y: gint,
                                                                time_: guint)
                                               -> gboolean>,
    pub drag_drop: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                  *mut GtkWidget,
                                                              context:
                                                                  *mut GdkDragContext,
                                                              x: gint,
                                                              y: gint,
                                                              time_: guint)
                                             -> gboolean>,
    pub drag_data_received: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                           *mut GtkWidget,
                                                                       context:
                                                                           *mut GdkDragContext,
                                                                       x:
                                                                           gint,
                                                                       y:
                                                                           gint,
                                                                       selection_data:
                                                                           *mut GtkSelectionData,
                                                                       info:
                                                                           guint,
                                                                       time_:
                                                                           guint)>,
    pub drag_failed: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                    *mut GtkWidget,
                                                                context:
                                                                    *mut GdkDragContext,
                                                                result:
                                                                    GtkDragResult)
                                               -> gboolean>,
    pub popup_menu: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                   *mut GtkWidget)
                                              -> gboolean>,
    pub show_help: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                  *mut GtkWidget,
                                                              help_type:
                                                                  GtkWidgetHelpType)
                                             -> gboolean>,
    pub get_accessible: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                       *mut GtkWidget)
                                                  -> *mut AtkObject>,
    pub screen_changed: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                       *mut GtkWidget,
                                                                   previous_screen:
                                                                       *mut GdkScreen)>,
    pub can_activate_accel: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                           *mut GtkWidget,
                                                                       signal_id:
                                                                           guint)
                                                      -> gboolean>,
    pub composited_changed: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                           *mut GtkWidget)>,
    pub query_tooltip: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                      *mut GtkWidget,
                                                                  x: gint,
                                                                  y: gint,
                                                                  keyboard_tooltip:
                                                                      gboolean,
                                                                  tooltip:
                                                                      *mut GtkTooltip)
                                                 -> gboolean>,
    pub compute_expand: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                       *mut GtkWidget,
                                                                   hexpand_p:
                                                                       *mut gboolean,
                                                                   vexpand_p:
                                                                       *mut gboolean)>,
    pub adjust_size_request: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                            *mut GtkWidget,
                                                                        orientation:
                                                                            GtkOrientation,
                                                                        minimum_size:
                                                                            *mut gint,
                                                                        natural_size:
                                                                            *mut gint)>,
    pub adjust_size_allocation: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                               *mut GtkWidget,
                                                                           orientation:
                                                                               GtkOrientation,
                                                                           minimum_size:
                                                                               *mut gint,
                                                                           natural_size:
                                                                               *mut gint,
                                                                           allocated_pos:
                                                                               *mut gint,
                                                                           allocated_size:
                                                                               *mut gint)>,
    pub style_updated: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                      *mut GtkWidget)>,
    pub touch_event: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                    *mut GtkWidget,
                                                                event:
                                                                    *mut GdkEventTouch)
                                               -> gboolean>,
    pub get_preferred_height_and_baseline_for_width: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                                                    *mut GtkWidget,
                                                                                                width:
                                                                                                    gint,
                                                                                                minimum_height:
                                                                                                    *mut gint,
                                                                                                natural_height:
                                                                                                    *mut gint,
                                                                                                minimum_baseline:
                                                                                                    *mut gint,
                                                                                                natural_baseline:
                                                                                                    *mut gint)>,
    pub adjust_baseline_request: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                                *mut GtkWidget,
                                                                            minimum_baseline:
                                                                                *mut gint,
                                                                            natural_baseline:
                                                                                *mut gint)>,
    pub adjust_baseline_allocation: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                                   *mut GtkWidget,
                                                                               baseline:
                                                                                   *mut gint)>,
    pub queue_draw_region: ::std::option::Option<unsafe extern "C" fn(widget:
                                                                          *mut GtkWidget,
                                                                      region:
                                                                          *const cairo_region_t)>,
    pub priv_: *mut GtkWidgetClassPrivate,
    pub _gtk_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GtkWidgetClass() {
    assert_eq!(::std::mem::size_of::<_GtkWidgetClass>() , 824usize , concat !
               ( "Size of: " , stringify ! ( _GtkWidgetClass ) ));
    assert_eq! (::std::mem::align_of::<_GtkWidgetClass>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _GtkWidgetClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . parent_class as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . activate_signal as
                * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( activate_signal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) .
                dispatch_child_properties_changed as * const _ as usize } ,
                144usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( dispatch_child_properties_changed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . destroy as * const
                _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( destroy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . show as * const _
                as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( show ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . show_all as * const
                _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( show_all ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . hide as * const _
                as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( hide ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . map as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . unmap as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( unmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . realize as * const
                _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( realize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . unrealize as *
                const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( unrealize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . size_allocate as *
                const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( size_allocate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . state_changed as *
                const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( state_changed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . state_flags_changed
                as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( state_flags_changed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . parent_set as *
                const _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( parent_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . hierarchy_changed
                as * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( hierarchy_changed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . style_set as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( style_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . direction_changed
                as * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( direction_changed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . grab_notify as *
                const _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( grab_notify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . child_notify as *
                const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( child_notify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . draw as * const _
                as usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( draw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . get_request_mode as
                * const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( get_request_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) .
                get_preferred_height as * const _ as usize } , 304usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( get_preferred_height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) .
                get_preferred_width_for_height as * const _ as usize } ,
                312usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( get_preferred_width_for_height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . get_preferred_width
                as * const _ as usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( get_preferred_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) .
                get_preferred_height_for_width as * const _ as usize } ,
                328usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( get_preferred_height_for_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . mnemonic_activate
                as * const _ as usize } , 336usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( mnemonic_activate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . grab_focus as *
                const _ as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( grab_focus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . focus as * const _
                as usize } , 352usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( focus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . move_focus as *
                const _ as usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( move_focus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . keynav_failed as *
                const _ as usize } , 368usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( keynav_failed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . event as * const _
                as usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . button_press_event
                as * const _ as usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( button_press_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) .
                button_release_event as * const _ as usize } , 392usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( button_release_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . scroll_event as *
                const _ as usize } , 400usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( scroll_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . motion_notify_event
                as * const _ as usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( motion_notify_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . delete_event as *
                const _ as usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( delete_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . destroy_event as *
                const _ as usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( destroy_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . key_press_event as
                * const _ as usize } , 432usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( key_press_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . key_release_event
                as * const _ as usize } , 440usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( key_release_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . enter_notify_event
                as * const _ as usize } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( enter_notify_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . leave_notify_event
                as * const _ as usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( leave_notify_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . configure_event as
                * const _ as usize } , 464usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( configure_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . focus_in_event as *
                const _ as usize } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( focus_in_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . focus_out_event as
                * const _ as usize } , 480usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( focus_out_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . map_event as *
                const _ as usize } , 488usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( map_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . unmap_event as *
                const _ as usize } , 496usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( unmap_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) .
                property_notify_event as * const _ as usize } , 504usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( property_notify_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) .
                selection_clear_event as * const _ as usize } , 512usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( selection_clear_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) .
                selection_request_event as * const _ as usize } , 520usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( selection_request_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) .
                selection_notify_event as * const _ as usize } , 528usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( selection_notify_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . proximity_in_event
                as * const _ as usize } , 536usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( proximity_in_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . proximity_out_event
                as * const _ as usize } , 544usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( proximity_out_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) .
                visibility_notify_event as * const _ as usize } , 552usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( visibility_notify_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . window_state_event
                as * const _ as usize } , 560usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( window_state_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . damage_event as *
                const _ as usize } , 568usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( damage_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . grab_broken_event
                as * const _ as usize } , 576usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( grab_broken_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . selection_get as *
                const _ as usize } , 584usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( selection_get ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . selection_received
                as * const _ as usize } , 592usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( selection_received ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . drag_begin as *
                const _ as usize } , 600usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( drag_begin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . drag_end as * const
                _ as usize } , 608usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( drag_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . drag_data_get as *
                const _ as usize } , 616usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( drag_data_get ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . drag_data_delete as
                * const _ as usize } , 624usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( drag_data_delete ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . drag_leave as *
                const _ as usize } , 632usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( drag_leave ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . drag_motion as *
                const _ as usize } , 640usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( drag_motion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . drag_drop as *
                const _ as usize } , 648usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( drag_drop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . drag_data_received
                as * const _ as usize } , 656usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( drag_data_received ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . drag_failed as *
                const _ as usize } , 664usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( drag_failed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . popup_menu as *
                const _ as usize } , 672usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( popup_menu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . show_help as *
                const _ as usize } , 680usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( show_help ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . get_accessible as *
                const _ as usize } , 688usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( get_accessible ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . screen_changed as *
                const _ as usize } , 696usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( screen_changed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . can_activate_accel
                as * const _ as usize } , 704usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( can_activate_accel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . composited_changed
                as * const _ as usize } , 712usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( composited_changed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . query_tooltip as *
                const _ as usize } , 720usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( query_tooltip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . compute_expand as *
                const _ as usize } , 728usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( compute_expand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . adjust_size_request
                as * const _ as usize } , 736usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( adjust_size_request ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) .
                adjust_size_allocation as * const _ as usize } , 744usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( adjust_size_allocation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . style_updated as *
                const _ as usize } , 752usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( style_updated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . touch_event as *
                const _ as usize } , 760usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( touch_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) .
                get_preferred_height_and_baseline_for_width as * const _ as
                usize } , 768usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! (
                get_preferred_height_and_baseline_for_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) .
                adjust_baseline_request as * const _ as usize } , 776usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( adjust_baseline_request ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) .
                adjust_baseline_allocation as * const _ as usize } , 784usize
                , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( adjust_baseline_allocation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . queue_draw_region
                as * const _ as usize } , 792usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( queue_draw_region ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . priv_ as * const _
                as usize } , 800usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( priv_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . _gtk_reserved6 as *
                const _ as usize } , 808usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( _gtk_reserved6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWidgetClass ) ) . _gtk_reserved7 as *
                const _ as usize } , 816usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWidgetClass ) ,
                "::" , stringify ! ( _gtk_reserved7 ) ));
}
impl Clone for _GtkWidgetClass {
    fn clone(&self) -> Self { *self }
}
pub type GtkWidgetClass = _GtkWidgetClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkWidgetClassPrivate {
    _unused: [u8; 0],
}
pub type GtkWidgetClassPrivate = _GtkWidgetClassPrivate;
/**
 * GtkAllocation:
 * @x: the X position of the widgets area relative to its parents allocation.
 * @y: the Y position of the widgets area relative to its parents allocation.
 * @width: the width of the widgets allocated area.
 * @height: the height of the widgets allocated area.
 *
 * A #GtkAllocation-struct of a widget represents region
 * which has been allocated to the widget by its parent. It is a subregion
 * of its parents allocation. See
 * [GtkWidgets geometry management section][geometry-management] for
 * more information.
 */
pub type GtkAllocation = GdkRectangle;
/**
 * GtkCallback:
 * @widget: the widget to operate on
 * @data: (closure): user-supplied data
 *
 * The type of the callback functions used for e.g. iterating over
 * the children of a container, see gtk_container_foreach().
 */
pub type GtkCallback =
    ::std::option::Option<unsafe extern "C" fn(widget: *mut GtkWidget,
                                               data: gpointer)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkApplication {
    pub parent: GApplication,
    pub priv_: *mut GtkApplicationPrivate,
}
#[test]
fn bindgen_test_layout__GtkApplication() {
    assert_eq!(::std::mem::size_of::<_GtkApplication>() , 40usize , concat ! (
               "Size of: " , stringify ! ( _GtkApplication ) ));
    assert_eq! (::std::mem::align_of::<_GtkApplication>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _GtkApplication ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkApplication ) ) . parent as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkApplication ) ,
                "::" , stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkApplication ) ) . priv_ as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkApplication ) ,
                "::" , stringify ! ( priv_ ) ));
}
impl Clone for _GtkApplication {
    fn clone(&self) -> Self { *self }
}
pub type GtkApplication = _GtkApplication;
/**
 * GtkApplicationClass:
 * @parent_class: The parent class.
 * @window_added: Signal emitted when a #GtkWindow is added to
 *    application through gtk_application_add_window().
 * @window_removed: Signal emitted when a #GtkWindow is removed from
 *    application, either as a side-effect of being destroyed or
 *    explicitly through gtk_application_remove_window().
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkApplicationClass {
    pub parent_class: GApplicationClass,
    pub window_added: ::std::option::Option<unsafe extern "C" fn(application:
                                                                     *mut GtkApplication,
                                                                 window:
                                                                     *mut GtkWindow)>,
    pub window_removed: ::std::option::Option<unsafe extern "C" fn(application:
                                                                       *mut GtkApplication,
                                                                   window:
                                                                       *mut GtkWindow)>,
    pub padding: [gpointer; 12usize],
}
#[test]
fn bindgen_test_layout__GtkApplicationClass() {
    assert_eq!(::std::mem::size_of::<_GtkApplicationClass>() , 424usize ,
               concat ! ( "Size of: " , stringify ! ( _GtkApplicationClass )
               ));
    assert_eq! (::std::mem::align_of::<_GtkApplicationClass>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GtkApplicationClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkApplicationClass ) ) . parent_class
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkApplicationClass )
                , "::" , stringify ! ( parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkApplicationClass ) ) . window_added
                as * const _ as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkApplicationClass )
                , "::" , stringify ! ( window_added ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkApplicationClass ) ) . window_removed
                as * const _ as usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkApplicationClass )
                , "::" , stringify ! ( window_removed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkApplicationClass ) ) . padding as *
                const _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkApplicationClass )
                , "::" , stringify ! ( padding ) ));
}
impl Clone for _GtkApplicationClass {
    fn clone(&self) -> Self { *self }
}
pub type GtkApplicationClass = _GtkApplicationClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkApplicationPrivate {
    _unused: [u8; 0],
}
pub type GtkApplicationPrivate = _GtkApplicationPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkContainer {
    pub widget: GtkWidget,
    pub priv_: *mut GtkContainerPrivate,
}
#[test]
fn bindgen_test_layout__GtkContainer() {
    assert_eq!(::std::mem::size_of::<_GtkContainer>() , 40usize , concat ! (
               "Size of: " , stringify ! ( _GtkContainer ) ));
    assert_eq! (::std::mem::align_of::<_GtkContainer>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkContainer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkContainer ) ) . widget as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkContainer ) , "::"
                , stringify ! ( widget ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkContainer ) ) . priv_ as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkContainer ) , "::"
                , stringify ! ( priv_ ) ));
}
impl Clone for _GtkContainer {
    fn clone(&self) -> Self { *self }
}
pub type GtkContainer = _GtkContainer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkContainerPrivate {
    _unused: [u8; 0],
}
pub type GtkContainerPrivate = _GtkContainerPrivate;
/**
 * GtkContainerClass:
 * @parent_class: The parent class.
 * @add: Signal emitted when a widget is added to container.
 * @remove: Signal emitted when a widget is removed from container.
 * @check_resize: Signal emitted when a size recalculation is needed.
 * @forall: Invokes callback on each child of container.
 * @set_focus_child: Sets the focused child of container.
 * @child_type: Returns the type of the children supported by the container.
 * @composite_name: Gets a widgets composite name. Deprecated: 3.10.
 * @set_child_property: Set a property on a child of container.
 * @get_child_property: Get a property from a child of container.
 * @get_path_for_child: Get path representing entire widget hierarchy
 *    from the toplevel down to and including @child.
 *
 * Base class for containers.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkContainerClass {
    pub parent_class: GtkWidgetClass,
    pub add: ::std::option::Option<unsafe extern "C" fn(container:
                                                            *mut GtkContainer,
                                                        widget:
                                                            *mut GtkWidget)>,
    pub remove: ::std::option::Option<unsafe extern "C" fn(container:
                                                               *mut GtkContainer,
                                                           widget:
                                                               *mut GtkWidget)>,
    pub check_resize: ::std::option::Option<unsafe extern "C" fn(container:
                                                                     *mut GtkContainer)>,
    pub forall: ::std::option::Option<unsafe extern "C" fn(container:
                                                               *mut GtkContainer,
                                                           include_internals:
                                                               gboolean,
                                                           callback:
                                                               GtkCallback,
                                                           callback_data:
                                                               gpointer)>,
    pub set_focus_child: ::std::option::Option<unsafe extern "C" fn(container:
                                                                        *mut GtkContainer,
                                                                    child:
                                                                        *mut GtkWidget)>,
    pub child_type: ::std::option::Option<unsafe extern "C" fn(container:
                                                                   *mut GtkContainer)
                                              -> GType>,
    pub composite_name: ::std::option::Option<unsafe extern "C" fn(container:
                                                                       *mut GtkContainer,
                                                                   child:
                                                                       *mut GtkWidget)
                                                  -> *mut gchar>,
    pub set_child_property: ::std::option::Option<unsafe extern "C" fn(container:
                                                                           *mut GtkContainer,
                                                                       child:
                                                                           *mut GtkWidget,
                                                                       property_id:
                                                                           guint,
                                                                       value:
                                                                           *const GValue,
                                                                       pspec:
                                                                           *mut GParamSpec)>,
    pub get_child_property: ::std::option::Option<unsafe extern "C" fn(container:
                                                                           *mut GtkContainer,
                                                                       child:
                                                                           *mut GtkWidget,
                                                                       property_id:
                                                                           guint,
                                                                       value:
                                                                           *mut GValue,
                                                                       pspec:
                                                                           *mut GParamSpec)>,
    pub get_path_for_child: ::std::option::Option<unsafe extern "C" fn(container:
                                                                           *mut GtkContainer,
                                                                       child:
                                                                           *mut GtkWidget)
                                                      -> *mut GtkWidgetPath>,
    pub _bitfield_1: u8,
    pub _gtk_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved8: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GtkContainerClass() {
    assert_eq!(::std::mem::size_of::<_GtkContainerClass>() , 976usize , concat
               ! ( "Size of: " , stringify ! ( _GtkContainerClass ) ));
    assert_eq! (::std::mem::align_of::<_GtkContainerClass>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _GtkContainerClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkContainerClass ) ) . parent_class as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkContainerClass ) ,
                "::" , stringify ! ( parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkContainerClass ) ) . add as * const _
                as usize } , 824usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkContainerClass ) ,
                "::" , stringify ! ( add ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkContainerClass ) ) . remove as *
                const _ as usize } , 832usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkContainerClass ) ,
                "::" , stringify ! ( remove ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkContainerClass ) ) . check_resize as
                * const _ as usize } , 840usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkContainerClass ) ,
                "::" , stringify ! ( check_resize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkContainerClass ) ) . forall as *
                const _ as usize } , 848usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkContainerClass ) ,
                "::" , stringify ! ( forall ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkContainerClass ) ) . set_focus_child
                as * const _ as usize } , 856usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkContainerClass ) ,
                "::" , stringify ! ( set_focus_child ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkContainerClass ) ) . child_type as *
                const _ as usize } , 864usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkContainerClass ) ,
                "::" , stringify ! ( child_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkContainerClass ) ) . composite_name
                as * const _ as usize } , 872usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkContainerClass ) ,
                "::" , stringify ! ( composite_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkContainerClass ) ) .
                set_child_property as * const _ as usize } , 880usize , concat
                ! (
                "Alignment of field: " , stringify ! ( _GtkContainerClass ) ,
                "::" , stringify ! ( set_child_property ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkContainerClass ) ) .
                get_child_property as * const _ as usize } , 888usize , concat
                ! (
                "Alignment of field: " , stringify ! ( _GtkContainerClass ) ,
                "::" , stringify ! ( get_child_property ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkContainerClass ) ) .
                get_path_for_child as * const _ as usize } , 896usize , concat
                ! (
                "Alignment of field: " , stringify ! ( _GtkContainerClass ) ,
                "::" , stringify ! ( get_path_for_child ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkContainerClass ) ) . _gtk_reserved1
                as * const _ as usize } , 912usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkContainerClass ) ,
                "::" , stringify ! ( _gtk_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkContainerClass ) ) . _gtk_reserved2
                as * const _ as usize } , 920usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkContainerClass ) ,
                "::" , stringify ! ( _gtk_reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkContainerClass ) ) . _gtk_reserved3
                as * const _ as usize } , 928usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkContainerClass ) ,
                "::" , stringify ! ( _gtk_reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkContainerClass ) ) . _gtk_reserved4
                as * const _ as usize } , 936usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkContainerClass ) ,
                "::" , stringify ! ( _gtk_reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkContainerClass ) ) . _gtk_reserved5
                as * const _ as usize } , 944usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkContainerClass ) ,
                "::" , stringify ! ( _gtk_reserved5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkContainerClass ) ) . _gtk_reserved6
                as * const _ as usize } , 952usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkContainerClass ) ,
                "::" , stringify ! ( _gtk_reserved6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkContainerClass ) ) . _gtk_reserved7
                as * const _ as usize } , 960usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkContainerClass ) ,
                "::" , stringify ! ( _gtk_reserved7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkContainerClass ) ) . _gtk_reserved8
                as * const _ as usize } , 968usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkContainerClass ) ,
                "::" , stringify ! ( _gtk_reserved8 ) ));
}
impl Clone for _GtkContainerClass {
    fn clone(&self) -> Self { *self }
}
impl _GtkContainerClass {
    #[inline]
    pub fn _handle_border_width(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set__handle_border_width(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(_handle_border_width: ::std::os::raw::c_uint)
     -> u8 {
        ({ 0 } |
             ((_handle_border_width as u32 as u8) << 0usize) & (1u64 as u8))
    }
}
pub type GtkContainerClass = _GtkContainerClass;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkBin {
    pub container: GtkContainer,
    pub priv_: *mut GtkBinPrivate,
}
#[test]
fn bindgen_test_layout__GtkBin() {
    assert_eq!(::std::mem::size_of::<_GtkBin>() , 48usize , concat ! (
               "Size of: " , stringify ! ( _GtkBin ) ));
    assert_eq! (::std::mem::align_of::<_GtkBin>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkBin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkBin ) ) . container as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkBin ) , "::" ,
                stringify ! ( container ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkBin ) ) . priv_ as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkBin ) , "::" ,
                stringify ! ( priv_ ) ));
}
impl Clone for _GtkBin {
    fn clone(&self) -> Self { *self }
}
pub type GtkBin = _GtkBin;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkBinPrivate {
    _unused: [u8; 0],
}
pub type GtkBinPrivate = _GtkBinPrivate;
/**
 * GtkBinClass:
 * @parent_class: The parent class.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkBinClass {
    pub parent_class: GtkContainerClass,
    pub _gtk_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GtkBinClass() {
    assert_eq!(::std::mem::size_of::<_GtkBinClass>() , 1008usize , concat ! (
               "Size of: " , stringify ! ( _GtkBinClass ) ));
    assert_eq! (::std::mem::align_of::<_GtkBinClass>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkBinClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkBinClass ) ) . parent_class as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkBinClass ) , "::" ,
                stringify ! ( parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkBinClass ) ) . _gtk_reserved1 as *
                const _ as usize } , 976usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkBinClass ) , "::" ,
                stringify ! ( _gtk_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkBinClass ) ) . _gtk_reserved2 as *
                const _ as usize } , 984usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkBinClass ) , "::" ,
                stringify ! ( _gtk_reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkBinClass ) ) . _gtk_reserved3 as *
                const _ as usize } , 992usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkBinClass ) , "::" ,
                stringify ! ( _gtk_reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkBinClass ) ) . _gtk_reserved4 as *
                const _ as usize } , 1000usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkBinClass ) , "::" ,
                stringify ! ( _gtk_reserved4 ) ));
}
impl Clone for _GtkBinClass {
    fn clone(&self) -> Self { *self }
}
pub type GtkBinClass = _GtkBinClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkWindowPrivate {
    _unused: [u8; 0],
}
pub type GtkWindowPrivate = _GtkWindowPrivate;
/**
 * GtkWindowClass:
 * @parent_class: The parent class.
 * @set_focus: Sets child as the focus widget for the window.
 * @activate_focus: Activates the current focused widget within the window.
 * @activate_default: Activates the default widget for the window.
 * @keys_changed: Signal gets emitted when the set of accelerators or
 *   mnemonics that are associated with window changes.
 * @enable_debugging: Class handler for the #GtkWindow::enable-debugging
 *   keybinding signal. Since: 3.14
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkWindowClass {
    pub parent_class: GtkBinClass,
    pub set_focus: ::std::option::Option<unsafe extern "C" fn(window:
                                                                  *mut GtkWindow,
                                                              focus:
                                                                  *mut GtkWidget)>,
    pub activate_focus: ::std::option::Option<unsafe extern "C" fn(window:
                                                                       *mut GtkWindow)>,
    pub activate_default: ::std::option::Option<unsafe extern "C" fn(window:
                                                                         *mut GtkWindow)>,
    pub keys_changed: ::std::option::Option<unsafe extern "C" fn(window:
                                                                     *mut GtkWindow)>,
    pub enable_debugging: ::std::option::Option<unsafe extern "C" fn(window:
                                                                         *mut GtkWindow,
                                                                     toggle:
                                                                         gboolean)
                                                    -> gboolean>,
    pub _gtk_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GtkWindowClass() {
    assert_eq!(::std::mem::size_of::<_GtkWindowClass>() , 1072usize , concat !
               ( "Size of: " , stringify ! ( _GtkWindowClass ) ));
    assert_eq! (::std::mem::align_of::<_GtkWindowClass>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _GtkWindowClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWindowClass ) ) . parent_class as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWindowClass ) ,
                "::" , stringify ! ( parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWindowClass ) ) . set_focus as *
                const _ as usize } , 1008usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWindowClass ) ,
                "::" , stringify ! ( set_focus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWindowClass ) ) . activate_focus as *
                const _ as usize } , 1016usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWindowClass ) ,
                "::" , stringify ! ( activate_focus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWindowClass ) ) . activate_default as
                * const _ as usize } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWindowClass ) ,
                "::" , stringify ! ( activate_default ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWindowClass ) ) . keys_changed as *
                const _ as usize } , 1032usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWindowClass ) ,
                "::" , stringify ! ( keys_changed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWindowClass ) ) . enable_debugging as
                * const _ as usize } , 1040usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWindowClass ) ,
                "::" , stringify ! ( enable_debugging ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWindowClass ) ) . _gtk_reserved1 as *
                const _ as usize } , 1048usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWindowClass ) ,
                "::" , stringify ! ( _gtk_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWindowClass ) ) . _gtk_reserved2 as *
                const _ as usize } , 1056usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWindowClass ) ,
                "::" , stringify ! ( _gtk_reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkWindowClass ) ) . _gtk_reserved3 as *
                const _ as usize } , 1064usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkWindowClass ) ,
                "::" , stringify ! ( _gtk_reserved3 ) ));
}
impl Clone for _GtkWindowClass {
    fn clone(&self) -> Self { *self }
}
pub type GtkWindowClass = _GtkWindowClass;
/**
 * GtkDialog:
 *
 * The #GtkDialog-struct contains only private fields
 * and should not be directly accessed.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkDialog {
    pub window: GtkWindow,
    pub priv_: *mut GtkDialogPrivate,
}
#[test]
fn bindgen_test_layout__GtkDialog() {
    assert_eq!(::std::mem::size_of::<_GtkDialog>() , 64usize , concat ! (
               "Size of: " , stringify ! ( _GtkDialog ) ));
    assert_eq! (::std::mem::align_of::<_GtkDialog>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkDialog ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkDialog ) ) . window as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkDialog ) , "::" ,
                stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkDialog ) ) . priv_ as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkDialog ) , "::" ,
                stringify ! ( priv_ ) ));
}
impl Clone for _GtkDialog {
    fn clone(&self) -> Self { *self }
}
pub type GtkDialog = _GtkDialog;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkDialogPrivate {
    _unused: [u8; 0],
}
pub type GtkDialogPrivate = _GtkDialogPrivate;
/**
 * GtkDialogClass:
 * @parent_class: The parent class.
 * @response: Signal emitted when an action widget is activated.
 * @close: Signal emitted when the user uses a keybinding to close the dialog.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkDialogClass {
    pub parent_class: GtkWindowClass,
    pub response: ::std::option::Option<unsafe extern "C" fn(dialog:
                                                                 *mut GtkDialog,
                                                             response_id:
                                                                 gint)>,
    pub close: ::std::option::Option<unsafe extern "C" fn(dialog:
                                                              *mut GtkDialog)>,
    pub _gtk_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GtkDialogClass() {
    assert_eq!(::std::mem::size_of::<_GtkDialogClass>() , 1120usize , concat !
               ( "Size of: " , stringify ! ( _GtkDialogClass ) ));
    assert_eq! (::std::mem::align_of::<_GtkDialogClass>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _GtkDialogClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkDialogClass ) ) . parent_class as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkDialogClass ) ,
                "::" , stringify ! ( parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkDialogClass ) ) . response as * const
                _ as usize } , 1072usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkDialogClass ) ,
                "::" , stringify ! ( response ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkDialogClass ) ) . close as * const _
                as usize } , 1080usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkDialogClass ) ,
                "::" , stringify ! ( close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkDialogClass ) ) . _gtk_reserved1 as *
                const _ as usize } , 1088usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkDialogClass ) ,
                "::" , stringify ! ( _gtk_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkDialogClass ) ) . _gtk_reserved2 as *
                const _ as usize } , 1096usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkDialogClass ) ,
                "::" , stringify ! ( _gtk_reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkDialogClass ) ) . _gtk_reserved3 as *
                const _ as usize } , 1104usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkDialogClass ) ,
                "::" , stringify ! ( _gtk_reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkDialogClass ) ) . _gtk_reserved4 as *
                const _ as usize } , 1112usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkDialogClass ) ,
                "::" , stringify ! ( _gtk_reserved4 ) ));
}
impl Clone for _GtkDialogClass {
    fn clone(&self) -> Self { *self }
}
pub type GtkDialogClass = _GtkDialogClass;
#[repr(u32)]
/**
 * GtkLicense:
 * @GTK_LICENSE_UNKNOWN: No license specified
 * @GTK_LICENSE_CUSTOM: A license text is going to be specified by the
 *   developer
 * @GTK_LICENSE_GPL_2_0: The GNU General Public License, version 2.0 or later
 * @GTK_LICENSE_GPL_3_0: The GNU General Public License, version 3.0 or later
 * @GTK_LICENSE_LGPL_2_1: The GNU Lesser General Public License, version 2.1 or later
 * @GTK_LICENSE_LGPL_3_0: The GNU Lesser General Public License, version 3.0 or later
 * @GTK_LICENSE_BSD: The BSD standard license
 * @GTK_LICENSE_MIT_X11: The MIT/X11 standard license
 * @GTK_LICENSE_ARTISTIC: The Artistic License, version 2.0
 * @GTK_LICENSE_GPL_2_0_ONLY: The GNU General Public License, version 2.0 only. Since 3.12.
 * @GTK_LICENSE_GPL_3_0_ONLY: The GNU General Public License, version 3.0 only. Since 3.12.
 * @GTK_LICENSE_LGPL_2_1_ONLY: The GNU Lesser General Public License, version 2.1 only. Since 3.12.
 * @GTK_LICENSE_LGPL_3_0_ONLY: The GNU Lesser General Public License, version 3.0 only. Since 3.12.
 *
 * The type of license for an application.
 *
 * This enumeration can be expanded at later date.
 *
 * Since: 3.0
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GtkLicense {
    GTK_LICENSE_UNKNOWN = 0,
    GTK_LICENSE_CUSTOM = 1,
    GTK_LICENSE_GPL_2_0 = 2,
    GTK_LICENSE_GPL_3_0 = 3,
    GTK_LICENSE_LGPL_2_1 = 4,
    GTK_LICENSE_LGPL_3_0 = 5,
    GTK_LICENSE_BSD = 6,
    GTK_LICENSE_MIT_X11 = 7,
    GTK_LICENSE_ARTISTIC = 8,
    GTK_LICENSE_GPL_2_0_ONLY = 9,
    GTK_LICENSE_GPL_3_0_ONLY = 10,
    GTK_LICENSE_LGPL_2_1_ONLY = 11,
    GTK_LICENSE_LGPL_3_0_ONLY = 12,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkMisc {
    pub widget: GtkWidget,
    pub priv_: *mut GtkMiscPrivate,
}
#[test]
fn bindgen_test_layout__GtkMisc() {
    assert_eq!(::std::mem::size_of::<_GtkMisc>() , 40usize , concat ! (
               "Size of: " , stringify ! ( _GtkMisc ) ));
    assert_eq! (::std::mem::align_of::<_GtkMisc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkMisc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMisc ) ) . widget as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMisc ) , "::" ,
                stringify ! ( widget ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMisc ) ) . priv_ as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMisc ) , "::" ,
                stringify ! ( priv_ ) ));
}
impl Clone for _GtkMisc {
    fn clone(&self) -> Self { *self }
}
pub type GtkMisc = _GtkMisc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkMiscPrivate {
    _unused: [u8; 0],
}
pub type GtkMiscPrivate = _GtkMiscPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkMiscClass {
    pub parent_class: GtkWidgetClass,
    pub _gtk_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GtkMiscClass() {
    assert_eq!(::std::mem::size_of::<_GtkMiscClass>() , 856usize , concat ! (
               "Size of: " , stringify ! ( _GtkMiscClass ) ));
    assert_eq! (::std::mem::align_of::<_GtkMiscClass>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkMiscClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMiscClass ) ) . parent_class as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMiscClass ) , "::"
                , stringify ! ( parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMiscClass ) ) . _gtk_reserved1 as *
                const _ as usize } , 824usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMiscClass ) , "::"
                , stringify ! ( _gtk_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMiscClass ) ) . _gtk_reserved2 as *
                const _ as usize } , 832usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMiscClass ) , "::"
                , stringify ! ( _gtk_reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMiscClass ) ) . _gtk_reserved3 as *
                const _ as usize } , 840usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMiscClass ) , "::"
                , stringify ! ( _gtk_reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMiscClass ) ) . _gtk_reserved4 as *
                const _ as usize } , 848usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMiscClass ) , "::"
                , stringify ! ( _gtk_reserved4 ) ));
}
impl Clone for _GtkMiscClass {
    fn clone(&self) -> Self { *self }
}
pub type GtkMiscClass = _GtkMiscClass;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkMenuShell {
    pub container: GtkContainer,
    pub priv_: *mut GtkMenuShellPrivate,
}
#[test]
fn bindgen_test_layout__GtkMenuShell() {
    assert_eq!(::std::mem::size_of::<_GtkMenuShell>() , 48usize , concat ! (
               "Size of: " , stringify ! ( _GtkMenuShell ) ));
    assert_eq! (::std::mem::align_of::<_GtkMenuShell>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkMenuShell ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMenuShell ) ) . container as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMenuShell ) , "::"
                , stringify ! ( container ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMenuShell ) ) . priv_ as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMenuShell ) , "::"
                , stringify ! ( priv_ ) ));
}
impl Clone for _GtkMenuShell {
    fn clone(&self) -> Self { *self }
}
pub type GtkMenuShell = _GtkMenuShell;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkMenuShellClass {
    pub parent_class: GtkContainerClass,
    pub _bitfield_1: u8,
    pub deactivate: ::std::option::Option<unsafe extern "C" fn(menu_shell:
                                                                   *mut GtkMenuShell)>,
    pub selection_done: ::std::option::Option<unsafe extern "C" fn(menu_shell:
                                                                       *mut GtkMenuShell)>,
    pub move_current: ::std::option::Option<unsafe extern "C" fn(menu_shell:
                                                                     *mut GtkMenuShell,
                                                                 direction:
                                                                     GtkMenuDirectionType)>,
    pub activate_current: ::std::option::Option<unsafe extern "C" fn(menu_shell:
                                                                         *mut GtkMenuShell,
                                                                     force_hide:
                                                                         gboolean)>,
    pub cancel: ::std::option::Option<unsafe extern "C" fn(menu_shell:
                                                               *mut GtkMenuShell)>,
    pub select_item: ::std::option::Option<unsafe extern "C" fn(menu_shell:
                                                                    *mut GtkMenuShell,
                                                                menu_item:
                                                                    *mut GtkWidget)>,
    pub insert: ::std::option::Option<unsafe extern "C" fn(menu_shell:
                                                               *mut GtkMenuShell,
                                                           child:
                                                               *mut GtkWidget,
                                                           position: gint)>,
    pub get_popup_delay: ::std::option::Option<unsafe extern "C" fn(menu_shell:
                                                                        *mut GtkMenuShell)
                                                   -> gint>,
    pub move_selected: ::std::option::Option<unsafe extern "C" fn(menu_shell:
                                                                      *mut GtkMenuShell,
                                                                  distance:
                                                                      gint)
                                                 -> gboolean>,
    pub _gtk_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GtkMenuShellClass() {
    assert_eq!(::std::mem::size_of::<_GtkMenuShellClass>() , 1088usize ,
               concat ! ( "Size of: " , stringify ! ( _GtkMenuShellClass ) ));
    assert_eq! (::std::mem::align_of::<_GtkMenuShellClass>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _GtkMenuShellClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMenuShellClass ) ) . parent_class as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMenuShellClass ) ,
                "::" , stringify ! ( parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMenuShellClass ) ) . deactivate as *
                const _ as usize } , 984usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMenuShellClass ) ,
                "::" , stringify ! ( deactivate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMenuShellClass ) ) . selection_done
                as * const _ as usize } , 992usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMenuShellClass ) ,
                "::" , stringify ! ( selection_done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMenuShellClass ) ) . move_current as
                * const _ as usize } , 1000usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMenuShellClass ) ,
                "::" , stringify ! ( move_current ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMenuShellClass ) ) . activate_current
                as * const _ as usize } , 1008usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMenuShellClass ) ,
                "::" , stringify ! ( activate_current ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMenuShellClass ) ) . cancel as *
                const _ as usize } , 1016usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMenuShellClass ) ,
                "::" , stringify ! ( cancel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMenuShellClass ) ) . select_item as *
                const _ as usize } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMenuShellClass ) ,
                "::" , stringify ! ( select_item ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMenuShellClass ) ) . insert as *
                const _ as usize } , 1032usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMenuShellClass ) ,
                "::" , stringify ! ( insert ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMenuShellClass ) ) . get_popup_delay
                as * const _ as usize } , 1040usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMenuShellClass ) ,
                "::" , stringify ! ( get_popup_delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMenuShellClass ) ) . move_selected as
                * const _ as usize } , 1048usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMenuShellClass ) ,
                "::" , stringify ! ( move_selected ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMenuShellClass ) ) . _gtk_reserved1
                as * const _ as usize } , 1056usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMenuShellClass ) ,
                "::" , stringify ! ( _gtk_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMenuShellClass ) ) . _gtk_reserved2
                as * const _ as usize } , 1064usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMenuShellClass ) ,
                "::" , stringify ! ( _gtk_reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMenuShellClass ) ) . _gtk_reserved3
                as * const _ as usize } , 1072usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMenuShellClass ) ,
                "::" , stringify ! ( _gtk_reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMenuShellClass ) ) . _gtk_reserved4
                as * const _ as usize } , 1080usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMenuShellClass ) ,
                "::" , stringify ! ( _gtk_reserved4 ) ));
}
impl Clone for _GtkMenuShellClass {
    fn clone(&self) -> Self { *self }
}
impl _GtkMenuShellClass {
    #[inline]
    pub fn submenu_placement(&self) -> guint {
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_submenu_placement(&mut self, val: guint) {
        let mask = 1u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u8 as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(submenu_placement: guint) -> u8 {
        ({ 0 } | ((submenu_placement as u32 as u8) << 0usize) & (1u64 as u8))
    }
}
pub type GtkMenuShellClass = _GtkMenuShellClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkMenuShellPrivate {
    _unused: [u8; 0],
}
pub type GtkMenuShellPrivate = _GtkMenuShellPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkMenu {
    pub menu_shell: GtkMenuShell,
    pub priv_: *mut GtkMenuPrivate,
}
#[test]
fn bindgen_test_layout__GtkMenu() {
    assert_eq!(::std::mem::size_of::<_GtkMenu>() , 56usize , concat ! (
               "Size of: " , stringify ! ( _GtkMenu ) ));
    assert_eq! (::std::mem::align_of::<_GtkMenu>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkMenu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMenu ) ) . menu_shell as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMenu ) , "::" ,
                stringify ! ( menu_shell ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMenu ) ) . priv_ as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMenu ) , "::" ,
                stringify ! ( priv_ ) ));
}
impl Clone for _GtkMenu {
    fn clone(&self) -> Self { *self }
}
pub type GtkMenu = _GtkMenu;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkMenuClass {
    pub parent_class: GtkMenuShellClass,
    pub _gtk_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GtkMenuClass() {
    assert_eq!(::std::mem::size_of::<_GtkMenuClass>() , 1120usize , concat ! (
               "Size of: " , stringify ! ( _GtkMenuClass ) ));
    assert_eq! (::std::mem::align_of::<_GtkMenuClass>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkMenuClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMenuClass ) ) . parent_class as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMenuClass ) , "::"
                , stringify ! ( parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMenuClass ) ) . _gtk_reserved1 as *
                const _ as usize } , 1088usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMenuClass ) , "::"
                , stringify ! ( _gtk_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMenuClass ) ) . _gtk_reserved2 as *
                const _ as usize } , 1096usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMenuClass ) , "::"
                , stringify ! ( _gtk_reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMenuClass ) ) . _gtk_reserved3 as *
                const _ as usize } , 1104usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMenuClass ) , "::"
                , stringify ! ( _gtk_reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMenuClass ) ) . _gtk_reserved4 as *
                const _ as usize } , 1112usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMenuClass ) , "::"
                , stringify ! ( _gtk_reserved4 ) ));
}
impl Clone for _GtkMenuClass {
    fn clone(&self) -> Self { *self }
}
pub type GtkMenuClass = _GtkMenuClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkMenuPrivate {
    _unused: [u8; 0],
}
pub type GtkMenuPrivate = _GtkMenuPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkLabel {
    pub misc: GtkMisc,
    pub priv_: *mut GtkLabelPrivate,
}
#[test]
fn bindgen_test_layout__GtkLabel() {
    assert_eq!(::std::mem::size_of::<_GtkLabel>() , 48usize , concat ! (
               "Size of: " , stringify ! ( _GtkLabel ) ));
    assert_eq! (::std::mem::align_of::<_GtkLabel>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkLabel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkLabel ) ) . misc as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkLabel ) , "::" ,
                stringify ! ( misc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkLabel ) ) . priv_ as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkLabel ) , "::" ,
                stringify ! ( priv_ ) ));
}
impl Clone for _GtkLabel {
    fn clone(&self) -> Self { *self }
}
pub type GtkLabel = _GtkLabel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkLabelPrivate {
    _unused: [u8; 0],
}
pub type GtkLabelPrivate = _GtkLabelPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkLabelClass {
    pub parent_class: GtkMiscClass,
    pub move_cursor: ::std::option::Option<unsafe extern "C" fn(label:
                                                                    *mut GtkLabel,
                                                                step:
                                                                    GtkMovementStep,
                                                                count: gint,
                                                                extend_selection:
                                                                    gboolean)>,
    pub copy_clipboard: ::std::option::Option<unsafe extern "C" fn(label:
                                                                       *mut GtkLabel)>,
    pub populate_popup: ::std::option::Option<unsafe extern "C" fn(label:
                                                                       *mut GtkLabel,
                                                                   menu:
                                                                       *mut GtkMenu)>,
    pub activate_link: ::std::option::Option<unsafe extern "C" fn(label:
                                                                      *mut GtkLabel,
                                                                  uri:
                                                                      *const gchar)
                                                 -> gboolean>,
    pub _gtk_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved8: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GtkLabelClass() {
    assert_eq!(::std::mem::size_of::<_GtkLabelClass>() , 952usize , concat ! (
               "Size of: " , stringify ! ( _GtkLabelClass ) ));
    assert_eq! (::std::mem::align_of::<_GtkLabelClass>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkLabelClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkLabelClass ) ) . parent_class as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkLabelClass ) , "::"
                , stringify ! ( parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkLabelClass ) ) . move_cursor as *
                const _ as usize } , 856usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkLabelClass ) , "::"
                , stringify ! ( move_cursor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkLabelClass ) ) . copy_clipboard as *
                const _ as usize } , 864usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkLabelClass ) , "::"
                , stringify ! ( copy_clipboard ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkLabelClass ) ) . populate_popup as *
                const _ as usize } , 872usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkLabelClass ) , "::"
                , stringify ! ( populate_popup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkLabelClass ) ) . activate_link as *
                const _ as usize } , 880usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkLabelClass ) , "::"
                , stringify ! ( activate_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkLabelClass ) ) . _gtk_reserved1 as *
                const _ as usize } , 888usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkLabelClass ) , "::"
                , stringify ! ( _gtk_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkLabelClass ) ) . _gtk_reserved2 as *
                const _ as usize } , 896usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkLabelClass ) , "::"
                , stringify ! ( _gtk_reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkLabelClass ) ) . _gtk_reserved3 as *
                const _ as usize } , 904usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkLabelClass ) , "::"
                , stringify ! ( _gtk_reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkLabelClass ) ) . _gtk_reserved4 as *
                const _ as usize } , 912usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkLabelClass ) , "::"
                , stringify ! ( _gtk_reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkLabelClass ) ) . _gtk_reserved5 as *
                const _ as usize } , 920usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkLabelClass ) , "::"
                , stringify ! ( _gtk_reserved5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkLabelClass ) ) . _gtk_reserved6 as *
                const _ as usize } , 928usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkLabelClass ) , "::"
                , stringify ! ( _gtk_reserved6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkLabelClass ) ) . _gtk_reserved7 as *
                const _ as usize } , 936usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkLabelClass ) , "::"
                , stringify ! ( _gtk_reserved7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkLabelClass ) ) . _gtk_reserved8 as *
                const _ as usize } , 944usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkLabelClass ) , "::"
                , stringify ! ( _gtk_reserved8 ) ));
}
impl Clone for _GtkLabelClass {
    fn clone(&self) -> Self { *self }
}
pub type GtkLabelClass = _GtkLabelClass;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkBox {
    pub container: GtkContainer,
    pub priv_: *mut GtkBoxPrivate,
}
#[test]
fn bindgen_test_layout__GtkBox() {
    assert_eq!(::std::mem::size_of::<_GtkBox>() , 48usize , concat ! (
               "Size of: " , stringify ! ( _GtkBox ) ));
    assert_eq! (::std::mem::align_of::<_GtkBox>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkBox ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkBox ) ) . container as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkBox ) , "::" ,
                stringify ! ( container ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkBox ) ) . priv_ as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkBox ) , "::" ,
                stringify ! ( priv_ ) ));
}
impl Clone for _GtkBox {
    fn clone(&self) -> Self { *self }
}
pub type GtkBox = _GtkBox;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkBoxPrivate {
    _unused: [u8; 0],
}
pub type GtkBoxPrivate = _GtkBoxPrivate;
/**
 * GtkBoxClass:
 * @parent_class: The parent class.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkBoxClass {
    pub parent_class: GtkContainerClass,
    pub _gtk_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GtkBoxClass() {
    assert_eq!(::std::mem::size_of::<_GtkBoxClass>() , 1008usize , concat ! (
               "Size of: " , stringify ! ( _GtkBoxClass ) ));
    assert_eq! (::std::mem::align_of::<_GtkBoxClass>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkBoxClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkBoxClass ) ) . parent_class as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkBoxClass ) , "::" ,
                stringify ! ( parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkBoxClass ) ) . _gtk_reserved1 as *
                const _ as usize } , 976usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkBoxClass ) , "::" ,
                stringify ! ( _gtk_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkBoxClass ) ) . _gtk_reserved2 as *
                const _ as usize } , 984usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkBoxClass ) , "::" ,
                stringify ! ( _gtk_reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkBoxClass ) ) . _gtk_reserved3 as *
                const _ as usize } , 992usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkBoxClass ) , "::" ,
                stringify ! ( _gtk_reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkBoxClass ) ) . _gtk_reserved4 as *
                const _ as usize } , 1000usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkBoxClass ) , "::" ,
                stringify ! ( _gtk_reserved4 ) ));
}
impl Clone for _GtkBoxClass {
    fn clone(&self) -> Self { *self }
}
pub type GtkBoxClass = _GtkBoxClass;
/**
 * GtkTreeIter:
 * @stamp: a unique stamp to catch invalid iterators
 * @user_data: model-specific data
 * @user_data2: model-specific data
 * @user_data3: model-specific data
 *
 * The #GtkTreeIter is the primary structure
 * for accessing a #GtkTreeModel. Models are expected to put a unique
 * integer in the @stamp member, and put
 * model-specific data in the three @user_data
 * members.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkTreeIter {
    pub stamp: gint,
    pub user_data: gpointer,
    pub user_data2: gpointer,
    pub user_data3: gpointer,
}
#[test]
fn bindgen_test_layout__GtkTreeIter() {
    assert_eq!(::std::mem::size_of::<_GtkTreeIter>() , 32usize , concat ! (
               "Size of: " , stringify ! ( _GtkTreeIter ) ));
    assert_eq! (::std::mem::align_of::<_GtkTreeIter>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkTreeIter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeIter ) ) . stamp as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeIter ) , "::" ,
                stringify ! ( stamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeIter ) ) . user_data as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeIter ) , "::" ,
                stringify ! ( user_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeIter ) ) . user_data2 as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeIter ) , "::" ,
                stringify ! ( user_data2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeIter ) ) . user_data3 as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeIter ) , "::" ,
                stringify ! ( user_data3 ) ));
}
impl Clone for _GtkTreeIter {
    fn clone(&self) -> Self { *self }
}
pub type GtkTreeIter = _GtkTreeIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkTreePath {
    _unused: [u8; 0],
}
pub type GtkTreePath = _GtkTreePath;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkCellEditable {
    _unused: [u8; 0],
}
pub type GtkCellEditable = _GtkCellEditable;
#[repr(u32)]
/**
 * GtkCellRendererState:
 * @GTK_CELL_RENDERER_SELECTED: The cell is currently selected, and
 *  probably has a selection colored background to render to.
 * @GTK_CELL_RENDERER_PRELIT: The mouse is hovering over the cell.
 * @GTK_CELL_RENDERER_INSENSITIVE: The cell is drawn in an insensitive manner
 * @GTK_CELL_RENDERER_SORTED: The cell is in a sorted row
 * @GTK_CELL_RENDERER_FOCUSED: The cell is in the focus row.
 * @GTK_CELL_RENDERER_EXPANDABLE: The cell is in a row that can be expanded. Since 3.4
 * @GTK_CELL_RENDERER_EXPANDED: The cell is in a row that is expanded. Since 3.4
 *
 * Tells how a cell is to be rendered.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GtkCellRendererState {
    GTK_CELL_RENDERER_SELECTED = 1,
    GTK_CELL_RENDERER_PRELIT = 2,
    GTK_CELL_RENDERER_INSENSITIVE = 4,
    GTK_CELL_RENDERER_SORTED = 8,
    GTK_CELL_RENDERER_FOCUSED = 16,
    GTK_CELL_RENDERER_EXPANDABLE = 32,
    GTK_CELL_RENDERER_EXPANDED = 64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkCellRenderer {
    pub parent_instance: GInitiallyUnowned,
    pub priv_: *mut GtkCellRendererPrivate,
}
#[test]
fn bindgen_test_layout__GtkCellRenderer() {
    assert_eq!(::std::mem::size_of::<_GtkCellRenderer>() , 32usize , concat !
               ( "Size of: " , stringify ! ( _GtkCellRenderer ) ));
    assert_eq! (::std::mem::align_of::<_GtkCellRenderer>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _GtkCellRenderer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkCellRenderer ) ) . parent_instance as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkCellRenderer ) ,
                "::" , stringify ! ( parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkCellRenderer ) ) . priv_ as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkCellRenderer ) ,
                "::" , stringify ! ( priv_ ) ));
}
impl Clone for _GtkCellRenderer {
    fn clone(&self) -> Self { *self }
}
pub type GtkCellRenderer = _GtkCellRenderer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkCellRendererPrivate {
    _unused: [u8; 0],
}
pub type GtkCellRendererPrivate = _GtkCellRendererPrivate;
/**
 * GtkCellRendererClass:
 * @get_request_mode: Called to gets whether the cell renderer prefers
 *    a height-for-width layout or a width-for-height layout.
 * @get_preferred_width: Called to get a renderers natural width.
 * @get_preferred_height_for_width: Called to get a renderers natural height for width.
 * @get_preferred_height: Called to get a renderers natural height.
 * @get_preferred_width_for_height: Called to get a renderers natural width for height.
 * @get_aligned_area: Called to get the aligned area used by @cell inside @cell_area.
 * @get_size: Called to get the width and height needed to render the cell. Deprecated: 3.0.
 * @render: Called to render the content of the #GtkCellRenderer.
 * @activate: Called to activate the content of the #GtkCellRenderer.
 * @start_editing: Called to initiate editing the content of the #GtkCellRenderer.
 * @editing_canceled: Signal gets emitted when the user cancels the process of editing a cell.
 * @editing_started: Signal gets emitted when a cell starts to be edited.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkCellRendererClass {
    pub parent_class: GInitiallyUnownedClass,
    pub get_request_mode: ::std::option::Option<unsafe extern "C" fn(cell:
                                                                         *mut GtkCellRenderer)
                                                    -> GtkSizeRequestMode>,
    pub get_preferred_width: ::std::option::Option<unsafe extern "C" fn(cell:
                                                                            *mut GtkCellRenderer,
                                                                        widget:
                                                                            *mut GtkWidget,
                                                                        minimum_size:
                                                                            *mut gint,
                                                                        natural_size:
                                                                            *mut gint)>,
    pub get_preferred_height_for_width: ::std::option::Option<unsafe extern "C" fn(cell:
                                                                                       *mut GtkCellRenderer,
                                                                                   widget:
                                                                                       *mut GtkWidget,
                                                                                   width:
                                                                                       gint,
                                                                                   minimum_height:
                                                                                       *mut gint,
                                                                                   natural_height:
                                                                                       *mut gint)>,
    pub get_preferred_height: ::std::option::Option<unsafe extern "C" fn(cell:
                                                                             *mut GtkCellRenderer,
                                                                         widget:
                                                                             *mut GtkWidget,
                                                                         minimum_size:
                                                                             *mut gint,
                                                                         natural_size:
                                                                             *mut gint)>,
    pub get_preferred_width_for_height: ::std::option::Option<unsafe extern "C" fn(cell:
                                                                                       *mut GtkCellRenderer,
                                                                                   widget:
                                                                                       *mut GtkWidget,
                                                                                   height:
                                                                                       gint,
                                                                                   minimum_width:
                                                                                       *mut gint,
                                                                                   natural_width:
                                                                                       *mut gint)>,
    pub get_aligned_area: ::std::option::Option<unsafe extern "C" fn(cell:
                                                                         *mut GtkCellRenderer,
                                                                     widget:
                                                                         *mut GtkWidget,
                                                                     flags:
                                                                         GtkCellRendererState,
                                                                     cell_area:
                                                                         *const GdkRectangle,
                                                                     aligned_area:
                                                                         *mut GdkRectangle)>,
    pub get_size: ::std::option::Option<unsafe extern "C" fn(cell:
                                                                 *mut GtkCellRenderer,
                                                             widget:
                                                                 *mut GtkWidget,
                                                             cell_area:
                                                                 *const GdkRectangle,
                                                             x_offset:
                                                                 *mut gint,
                                                             y_offset:
                                                                 *mut gint,
                                                             width: *mut gint,
                                                             height:
                                                                 *mut gint)>,
    pub render: ::std::option::Option<unsafe extern "C" fn(cell:
                                                               *mut GtkCellRenderer,
                                                           cr: *mut cairo_t,
                                                           widget:
                                                               *mut GtkWidget,
                                                           background_area:
                                                               *const GdkRectangle,
                                                           cell_area:
                                                               *const GdkRectangle,
                                                           flags:
                                                               GtkCellRendererState)>,
    pub activate: ::std::option::Option<unsafe extern "C" fn(cell:
                                                                 *mut GtkCellRenderer,
                                                             event:
                                                                 *mut GdkEvent,
                                                             widget:
                                                                 *mut GtkWidget,
                                                             path:
                                                                 *const gchar,
                                                             background_area:
                                                                 *const GdkRectangle,
                                                             cell_area:
                                                                 *const GdkRectangle,
                                                             flags:
                                                                 GtkCellRendererState)
                                            -> gboolean>,
    pub start_editing: ::std::option::Option<unsafe extern "C" fn(cell:
                                                                      *mut GtkCellRenderer,
                                                                  event:
                                                                      *mut GdkEvent,
                                                                  widget:
                                                                      *mut GtkWidget,
                                                                  path:
                                                                      *const gchar,
                                                                  background_area:
                                                                      *const GdkRectangle,
                                                                  cell_area:
                                                                      *const GdkRectangle,
                                                                  flags:
                                                                      GtkCellRendererState)
                                                 -> *mut GtkCellEditable>,
    pub editing_canceled: ::std::option::Option<unsafe extern "C" fn(cell:
                                                                         *mut GtkCellRenderer)>,
    pub editing_started: ::std::option::Option<unsafe extern "C" fn(cell:
                                                                        *mut GtkCellRenderer,
                                                                    editable:
                                                                        *mut GtkCellEditable,
                                                                    path:
                                                                        *const gchar)>,
    pub priv_: *mut GtkCellRendererClassPrivate,
    pub _gtk_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GtkCellRendererClass() {
    assert_eq!(::std::mem::size_of::<_GtkCellRendererClass>() , 264usize ,
               concat ! ( "Size of: " , stringify ! ( _GtkCellRendererClass )
               ));
    assert_eq! (::std::mem::align_of::<_GtkCellRendererClass>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GtkCellRendererClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkCellRendererClass ) ) . parent_class
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkCellRendererClass )
                , "::" , stringify ! ( parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkCellRendererClass ) ) .
                get_request_mode as * const _ as usize } , 136usize , concat !
                (
                "Alignment of field: " , stringify ! ( _GtkCellRendererClass )
                , "::" , stringify ! ( get_request_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkCellRendererClass ) ) .
                get_preferred_width as * const _ as usize } , 144usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _GtkCellRendererClass )
                , "::" , stringify ! ( get_preferred_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkCellRendererClass ) ) .
                get_preferred_height_for_width as * const _ as usize } ,
                152usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkCellRendererClass )
                , "::" , stringify ! ( get_preferred_height_for_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkCellRendererClass ) ) .
                get_preferred_height as * const _ as usize } , 160usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _GtkCellRendererClass )
                , "::" , stringify ! ( get_preferred_height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkCellRendererClass ) ) .
                get_preferred_width_for_height as * const _ as usize } ,
                168usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkCellRendererClass )
                , "::" , stringify ! ( get_preferred_width_for_height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkCellRendererClass ) ) .
                get_aligned_area as * const _ as usize } , 176usize , concat !
                (
                "Alignment of field: " , stringify ! ( _GtkCellRendererClass )
                , "::" , stringify ! ( get_aligned_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkCellRendererClass ) ) . get_size as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkCellRendererClass )
                , "::" , stringify ! ( get_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkCellRendererClass ) ) . render as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkCellRendererClass )
                , "::" , stringify ! ( render ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkCellRendererClass ) ) . activate as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkCellRendererClass )
                , "::" , stringify ! ( activate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkCellRendererClass ) ) . start_editing
                as * const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkCellRendererClass )
                , "::" , stringify ! ( start_editing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkCellRendererClass ) ) .
                editing_canceled as * const _ as usize } , 216usize , concat !
                (
                "Alignment of field: " , stringify ! ( _GtkCellRendererClass )
                , "::" , stringify ! ( editing_canceled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkCellRendererClass ) ) .
                editing_started as * const _ as usize } , 224usize , concat !
                (
                "Alignment of field: " , stringify ! ( _GtkCellRendererClass )
                , "::" , stringify ! ( editing_started ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkCellRendererClass ) ) . priv_ as *
                const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkCellRendererClass )
                , "::" , stringify ! ( priv_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkCellRendererClass ) ) .
                _gtk_reserved2 as * const _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkCellRendererClass )
                , "::" , stringify ! ( _gtk_reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkCellRendererClass ) ) .
                _gtk_reserved3 as * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkCellRendererClass )
                , "::" , stringify ! ( _gtk_reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkCellRendererClass ) ) .
                _gtk_reserved4 as * const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkCellRendererClass )
                , "::" , stringify ! ( _gtk_reserved4 ) ));
}
impl Clone for _GtkCellRendererClass {
    fn clone(&self) -> Self { *self }
}
pub type GtkCellRendererClass = _GtkCellRendererClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkCellRendererClassPrivate {
    _unused: [u8; 0],
}
pub type GtkCellRendererClassPrivate = _GtkCellRendererClassPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkTreeViewColumn {
    pub parent_instance: GInitiallyUnowned,
    pub priv_: *mut GtkTreeViewColumnPrivate,
}
#[test]
fn bindgen_test_layout__GtkTreeViewColumn() {
    assert_eq!(::std::mem::size_of::<_GtkTreeViewColumn>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( _GtkTreeViewColumn ) ));
    assert_eq! (::std::mem::align_of::<_GtkTreeViewColumn>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _GtkTreeViewColumn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewColumn ) ) . parent_instance
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewColumn ) ,
                "::" , stringify ! ( parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewColumn ) ) . priv_ as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewColumn ) ,
                "::" , stringify ! ( priv_ ) ));
}
impl Clone for _GtkTreeViewColumn {
    fn clone(&self) -> Self { *self }
}
pub type GtkTreeViewColumn = _GtkTreeViewColumn;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkTreeViewColumnPrivate {
    _unused: [u8; 0],
}
pub type GtkTreeViewColumnPrivate = _GtkTreeViewColumnPrivate;
/**
 * GtkTargetEntry:
 * @target: a string representation of the target type
 * @flags: #GtkTargetFlags for DND
 * @info: an application-assigned integer ID which will
 *     get passed as a parameter to e.g the #GtkWidget::selection-get
 *     signal. It allows the application to identify the target
 *     type without extensive string compares.
 *
 * A #GtkTargetEntry represents a single type of
 * data than can be supplied for by a widget for a selection
 * or for supplied or received during drag-and-drop.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkTargetEntry {
    pub target: *mut gchar,
    pub flags: guint,
    pub info: guint,
}
#[test]
fn bindgen_test_layout__GtkTargetEntry() {
    assert_eq!(::std::mem::size_of::<_GtkTargetEntry>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _GtkTargetEntry ) ));
    assert_eq! (::std::mem::align_of::<_GtkTargetEntry>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _GtkTargetEntry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTargetEntry ) ) . target as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTargetEntry ) ,
                "::" , stringify ! ( target ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTargetEntry ) ) . flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTargetEntry ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTargetEntry ) ) . info as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTargetEntry ) ,
                "::" , stringify ! ( info ) ));
}
impl Clone for _GtkTargetEntry {
    fn clone(&self) -> Self { *self }
}
pub type GtkTargetEntry = _GtkTargetEntry;
/**
 * GtkImage:
 *
 * This struct contain private data only and should be accessed by the functions
 * below.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkImage {
    pub misc: GtkMisc,
    pub priv_: *mut GtkImagePrivate,
}
#[test]
fn bindgen_test_layout__GtkImage() {
    assert_eq!(::std::mem::size_of::<_GtkImage>() , 48usize , concat ! (
               "Size of: " , stringify ! ( _GtkImage ) ));
    assert_eq! (::std::mem::align_of::<_GtkImage>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkImage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkImage ) ) . misc as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkImage ) , "::" ,
                stringify ! ( misc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkImage ) ) . priv_ as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkImage ) , "::" ,
                stringify ! ( priv_ ) ));
}
impl Clone for _GtkImage {
    fn clone(&self) -> Self { *self }
}
pub type GtkImage = _GtkImage;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkImagePrivate {
    _unused: [u8; 0],
}
pub type GtkImagePrivate = _GtkImagePrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkEntry {
    pub parent_instance: GtkWidget,
    pub priv_: *mut GtkEntryPrivate,
}
#[test]
fn bindgen_test_layout__GtkEntry() {
    assert_eq!(::std::mem::size_of::<_GtkEntry>() , 40usize , concat ! (
               "Size of: " , stringify ! ( _GtkEntry ) ));
    assert_eq! (::std::mem::align_of::<_GtkEntry>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkEntry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEntry ) ) . parent_instance as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEntry ) , "::" ,
                stringify ! ( parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEntry ) ) . priv_ as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEntry ) , "::" ,
                stringify ! ( priv_ ) ));
}
impl Clone for _GtkEntry {
    fn clone(&self) -> Self { *self }
}
pub type GtkEntry = _GtkEntry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkEntryPrivate {
    _unused: [u8; 0],
}
pub type GtkEntryPrivate = _GtkEntryPrivate;
/**
 * GtkEntryClass:
 * @parent_class: The parent class.
 * @populate_popup: Class handler for the #GtkEntry::populate-popup signal. If
 *   non-%NULL, this will be called to add additional entries to the context
 *   menu when it is displayed.
 * @activate: Class handler for the #GtkEntry::activate signal. The default
 *   implementation calls gtk_window_activate_default() on the entrys top-level
 *   window.
 * @move_cursor: Class handler for the #GtkEntry::move-cursor signal. The
 *   default implementation specifies the standard #GtkEntry cursor movement
 *   behavior.
 * @insert_at_cursor: Class handler for the #GtkEntry::insert-at-cursor signal.
 *   The default implementation inserts text at the cursor.
 * @delete_from_cursor: Class handler for the #GtkEntry::delete-from-cursor
 *   signal. The default implementation deletes the selection or the specified
 *   number of characters or words.
 * @backspace: Class handler for the #GtkEntry::backspace signal. The default
 *   implementation deletes the selection or a single character or word.
 * @cut_clipboard: Class handler for the #GtkEntry::cut-clipboard signal. The
 *   default implementation cuts the selection, if one exists.
 * @copy_clipboard: Class handler for the #GtkEntry::copy-clipboard signal. The
 *   default implementation copies the selection, if one exists.
 * @paste_clipboard: Class handler for the #GtkEntry::paste-clipboard signal.
 *   The default implementation pastes at the current cursor position or over
 *   the current selection if one exists.
 * @toggle_overwrite: Class handler for the #GtkEntry::toggle-overwrite signal.
 *   The default implementation toggles overwrite mode and blinks the cursor.
 * @get_text_area_size: Calculate the size of the text area, which is its
 *   allocated width and requested height, minus space for margins and borders.
 *   This virtual function must be non-%NULL.
 * @get_frame_size: Calculate the size of the text area frame, which is its
 *   allocated width and requested height, minus space for margins and borders,
 *   and taking baseline and text height into account. This virtual function
 *   must be non-%NULL.
 *
 * Class structure for #GtkEntry. All virtual functions have a default
 * implementation. Derived classes may set the virtual function pointers for the
 * signal handlers to %NULL, but must keep @get_text_area_size and
 * @get_frame_size non-%NULL; either use the default implementation, or provide
 * a custom one.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkEntryClass {
    pub parent_class: GtkWidgetClass,
    pub populate_popup: ::std::option::Option<unsafe extern "C" fn(entry:
                                                                       *mut GtkEntry,
                                                                   popup:
                                                                       *mut GtkWidget)>,
    pub activate: ::std::option::Option<unsafe extern "C" fn(entry:
                                                                 *mut GtkEntry)>,
    pub move_cursor: ::std::option::Option<unsafe extern "C" fn(entry:
                                                                    *mut GtkEntry,
                                                                step:
                                                                    GtkMovementStep,
                                                                count: gint,
                                                                extend_selection:
                                                                    gboolean)>,
    pub insert_at_cursor: ::std::option::Option<unsafe extern "C" fn(entry:
                                                                         *mut GtkEntry,
                                                                     str:
                                                                         *const gchar)>,
    pub delete_from_cursor: ::std::option::Option<unsafe extern "C" fn(entry:
                                                                           *mut GtkEntry,
                                                                       type_:
                                                                           GtkDeleteType,
                                                                       count:
                                                                           gint)>,
    pub backspace: ::std::option::Option<unsafe extern "C" fn(entry:
                                                                  *mut GtkEntry)>,
    pub cut_clipboard: ::std::option::Option<unsafe extern "C" fn(entry:
                                                                      *mut GtkEntry)>,
    pub copy_clipboard: ::std::option::Option<unsafe extern "C" fn(entry:
                                                                       *mut GtkEntry)>,
    pub paste_clipboard: ::std::option::Option<unsafe extern "C" fn(entry:
                                                                        *mut GtkEntry)>,
    pub toggle_overwrite: ::std::option::Option<unsafe extern "C" fn(entry:
                                                                         *mut GtkEntry)>,
    pub get_text_area_size: ::std::option::Option<unsafe extern "C" fn(entry:
                                                                           *mut GtkEntry,
                                                                       x:
                                                                           *mut gint,
                                                                       y:
                                                                           *mut gint,
                                                                       width:
                                                                           *mut gint,
                                                                       height:
                                                                           *mut gint)>,
    pub get_frame_size: ::std::option::Option<unsafe extern "C" fn(entry:
                                                                       *mut GtkEntry,
                                                                   x:
                                                                       *mut gint,
                                                                   y:
                                                                       *mut gint,
                                                                   width:
                                                                       *mut gint,
                                                                   height:
                                                                       *mut gint)>,
    pub _gtk_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GtkEntryClass() {
    assert_eq!(::std::mem::size_of::<_GtkEntryClass>() , 976usize , concat ! (
               "Size of: " , stringify ! ( _GtkEntryClass ) ));
    assert_eq! (::std::mem::align_of::<_GtkEntryClass>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkEntryClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEntryClass ) ) . parent_class as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEntryClass ) , "::"
                , stringify ! ( parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEntryClass ) ) . populate_popup as *
                const _ as usize } , 824usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEntryClass ) , "::"
                , stringify ! ( populate_popup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEntryClass ) ) . activate as * const
                _ as usize } , 832usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEntryClass ) , "::"
                , stringify ! ( activate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEntryClass ) ) . move_cursor as *
                const _ as usize } , 840usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEntryClass ) , "::"
                , stringify ! ( move_cursor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEntryClass ) ) . insert_at_cursor as
                * const _ as usize } , 848usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEntryClass ) , "::"
                , stringify ! ( insert_at_cursor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEntryClass ) ) . delete_from_cursor
                as * const _ as usize } , 856usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEntryClass ) , "::"
                , stringify ! ( delete_from_cursor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEntryClass ) ) . backspace as * const
                _ as usize } , 864usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEntryClass ) , "::"
                , stringify ! ( backspace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEntryClass ) ) . cut_clipboard as *
                const _ as usize } , 872usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEntryClass ) , "::"
                , stringify ! ( cut_clipboard ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEntryClass ) ) . copy_clipboard as *
                const _ as usize } , 880usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEntryClass ) , "::"
                , stringify ! ( copy_clipboard ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEntryClass ) ) . paste_clipboard as *
                const _ as usize } , 888usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEntryClass ) , "::"
                , stringify ! ( paste_clipboard ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEntryClass ) ) . toggle_overwrite as
                * const _ as usize } , 896usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEntryClass ) , "::"
                , stringify ! ( toggle_overwrite ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEntryClass ) ) . get_text_area_size
                as * const _ as usize } , 904usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEntryClass ) , "::"
                , stringify ! ( get_text_area_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEntryClass ) ) . get_frame_size as *
                const _ as usize } , 912usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEntryClass ) , "::"
                , stringify ! ( get_frame_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEntryClass ) ) . _gtk_reserved1 as *
                const _ as usize } , 920usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEntryClass ) , "::"
                , stringify ! ( _gtk_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEntryClass ) ) . _gtk_reserved2 as *
                const _ as usize } , 928usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEntryClass ) , "::"
                , stringify ! ( _gtk_reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEntryClass ) ) . _gtk_reserved3 as *
                const _ as usize } , 936usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEntryClass ) , "::"
                , stringify ! ( _gtk_reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEntryClass ) ) . _gtk_reserved4 as *
                const _ as usize } , 944usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEntryClass ) , "::"
                , stringify ! ( _gtk_reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEntryClass ) ) . _gtk_reserved5 as *
                const _ as usize } , 952usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEntryClass ) , "::"
                , stringify ! ( _gtk_reserved5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEntryClass ) ) . _gtk_reserved6 as *
                const _ as usize } , 960usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEntryClass ) , "::"
                , stringify ! ( _gtk_reserved6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEntryClass ) ) . _gtk_reserved7 as *
                const _ as usize } , 968usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEntryClass ) , "::"
                , stringify ! ( _gtk_reserved7 ) ));
}
impl Clone for _GtkEntryClass {
    fn clone(&self) -> Self { *self }
}
pub type GtkEntryClass = _GtkEntryClass;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkTreeView {
    pub parent: GtkContainer,
    pub priv_: *mut GtkTreeViewPrivate,
}
#[test]
fn bindgen_test_layout__GtkTreeView() {
    assert_eq!(::std::mem::size_of::<_GtkTreeView>() , 48usize , concat ! (
               "Size of: " , stringify ! ( _GtkTreeView ) ));
    assert_eq! (::std::mem::align_of::<_GtkTreeView>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkTreeView ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeView ) ) . parent as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeView ) , "::" ,
                stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeView ) ) . priv_ as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeView ) , "::" ,
                stringify ! ( priv_ ) ));
}
impl Clone for _GtkTreeView {
    fn clone(&self) -> Self { *self }
}
pub type GtkTreeView = _GtkTreeView;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkTreeViewClass {
    pub parent_class: GtkContainerClass,
    pub row_activated: ::std::option::Option<unsafe extern "C" fn(tree_view:
                                                                      *mut GtkTreeView,
                                                                  path:
                                                                      *mut GtkTreePath,
                                                                  column:
                                                                      *mut GtkTreeViewColumn)>,
    pub test_expand_row: ::std::option::Option<unsafe extern "C" fn(tree_view:
                                                                        *mut GtkTreeView,
                                                                    iter:
                                                                        *mut GtkTreeIter,
                                                                    path:
                                                                        *mut GtkTreePath)
                                                   -> gboolean>,
    pub test_collapse_row: ::std::option::Option<unsafe extern "C" fn(tree_view:
                                                                          *mut GtkTreeView,
                                                                      iter:
                                                                          *mut GtkTreeIter,
                                                                      path:
                                                                          *mut GtkTreePath)
                                                     -> gboolean>,
    pub row_expanded: ::std::option::Option<unsafe extern "C" fn(tree_view:
                                                                     *mut GtkTreeView,
                                                                 iter:
                                                                     *mut GtkTreeIter,
                                                                 path:
                                                                     *mut GtkTreePath)>,
    pub row_collapsed: ::std::option::Option<unsafe extern "C" fn(tree_view:
                                                                      *mut GtkTreeView,
                                                                  iter:
                                                                      *mut GtkTreeIter,
                                                                  path:
                                                                      *mut GtkTreePath)>,
    pub columns_changed: ::std::option::Option<unsafe extern "C" fn(tree_view:
                                                                        *mut GtkTreeView)>,
    pub cursor_changed: ::std::option::Option<unsafe extern "C" fn(tree_view:
                                                                       *mut GtkTreeView)>,
    pub move_cursor: ::std::option::Option<unsafe extern "C" fn(tree_view:
                                                                    *mut GtkTreeView,
                                                                step:
                                                                    GtkMovementStep,
                                                                count: gint)
                                               -> gboolean>,
    pub select_all: ::std::option::Option<unsafe extern "C" fn(tree_view:
                                                                   *mut GtkTreeView)
                                              -> gboolean>,
    pub unselect_all: ::std::option::Option<unsafe extern "C" fn(tree_view:
                                                                     *mut GtkTreeView)
                                                -> gboolean>,
    pub select_cursor_row: ::std::option::Option<unsafe extern "C" fn(tree_view:
                                                                          *mut GtkTreeView,
                                                                      start_editing:
                                                                          gboolean)
                                                     -> gboolean>,
    pub toggle_cursor_row: ::std::option::Option<unsafe extern "C" fn(tree_view:
                                                                          *mut GtkTreeView)
                                                     -> gboolean>,
    pub expand_collapse_cursor_row: ::std::option::Option<unsafe extern "C" fn(tree_view:
                                                                                   *mut GtkTreeView,
                                                                               logical:
                                                                                   gboolean,
                                                                               expand:
                                                                                   gboolean,
                                                                               open_all:
                                                                                   gboolean)
                                                              -> gboolean>,
    pub select_cursor_parent: ::std::option::Option<unsafe extern "C" fn(tree_view:
                                                                             *mut GtkTreeView)
                                                        -> gboolean>,
    pub start_interactive_search: ::std::option::Option<unsafe extern "C" fn(tree_view:
                                                                                 *mut GtkTreeView)
                                                            -> gboolean>,
    pub _gtk_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved8: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GtkTreeViewClass() {
    assert_eq!(::std::mem::size_of::<_GtkTreeViewClass>() , 1160usize , concat
               ! ( "Size of: " , stringify ! ( _GtkTreeViewClass ) ));
    assert_eq! (::std::mem::align_of::<_GtkTreeViewClass>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _GtkTreeViewClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewClass ) ) . parent_class as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewClass ) ,
                "::" , stringify ! ( parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewClass ) ) . row_activated as
                * const _ as usize } , 976usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewClass ) ,
                "::" , stringify ! ( row_activated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewClass ) ) . test_expand_row
                as * const _ as usize } , 984usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewClass ) ,
                "::" , stringify ! ( test_expand_row ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewClass ) ) . test_collapse_row
                as * const _ as usize } , 992usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewClass ) ,
                "::" , stringify ! ( test_collapse_row ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewClass ) ) . row_expanded as *
                const _ as usize } , 1000usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewClass ) ,
                "::" , stringify ! ( row_expanded ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewClass ) ) . row_collapsed as
                * const _ as usize } , 1008usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewClass ) ,
                "::" , stringify ! ( row_collapsed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewClass ) ) . columns_changed
                as * const _ as usize } , 1016usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewClass ) ,
                "::" , stringify ! ( columns_changed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewClass ) ) . cursor_changed as
                * const _ as usize } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewClass ) ,
                "::" , stringify ! ( cursor_changed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewClass ) ) . move_cursor as *
                const _ as usize } , 1032usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewClass ) ,
                "::" , stringify ! ( move_cursor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewClass ) ) . select_all as *
                const _ as usize } , 1040usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewClass ) ,
                "::" , stringify ! ( select_all ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewClass ) ) . unselect_all as *
                const _ as usize } , 1048usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewClass ) ,
                "::" , stringify ! ( unselect_all ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewClass ) ) . select_cursor_row
                as * const _ as usize } , 1056usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewClass ) ,
                "::" , stringify ! ( select_cursor_row ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewClass ) ) . toggle_cursor_row
                as * const _ as usize } , 1064usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewClass ) ,
                "::" , stringify ! ( toggle_cursor_row ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewClass ) ) .
                expand_collapse_cursor_row as * const _ as usize } , 1072usize
                , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewClass ) ,
                "::" , stringify ! ( expand_collapse_cursor_row ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewClass ) ) .
                select_cursor_parent as * const _ as usize } , 1080usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewClass ) ,
                "::" , stringify ! ( select_cursor_parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewClass ) ) .
                start_interactive_search as * const _ as usize } , 1088usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewClass ) ,
                "::" , stringify ! ( start_interactive_search ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewClass ) ) . _gtk_reserved1 as
                * const _ as usize } , 1096usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewClass ) ,
                "::" , stringify ! ( _gtk_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewClass ) ) . _gtk_reserved2 as
                * const _ as usize } , 1104usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewClass ) ,
                "::" , stringify ! ( _gtk_reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewClass ) ) . _gtk_reserved3 as
                * const _ as usize } , 1112usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewClass ) ,
                "::" , stringify ! ( _gtk_reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewClass ) ) . _gtk_reserved4 as
                * const _ as usize } , 1120usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewClass ) ,
                "::" , stringify ! ( _gtk_reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewClass ) ) . _gtk_reserved5 as
                * const _ as usize } , 1128usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewClass ) ,
                "::" , stringify ! ( _gtk_reserved5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewClass ) ) . _gtk_reserved6 as
                * const _ as usize } , 1136usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewClass ) ,
                "::" , stringify ! ( _gtk_reserved6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewClass ) ) . _gtk_reserved7 as
                * const _ as usize } , 1144usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewClass ) ,
                "::" , stringify ! ( _gtk_reserved7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkTreeViewClass ) ) . _gtk_reserved8 as
                * const _ as usize } , 1152usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkTreeViewClass ) ,
                "::" , stringify ! ( _gtk_reserved8 ) ));
}
impl Clone for _GtkTreeViewClass {
    fn clone(&self) -> Self { *self }
}
pub type GtkTreeViewClass = _GtkTreeViewClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkTreeViewPrivate {
    _unused: [u8; 0],
}
pub type GtkTreeViewPrivate = _GtkTreeViewPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkButton {
    pub bin: GtkBin,
    pub priv_: *mut GtkButtonPrivate,
}
#[test]
fn bindgen_test_layout__GtkButton() {
    assert_eq!(::std::mem::size_of::<_GtkButton>() , 56usize , concat ! (
               "Size of: " , stringify ! ( _GtkButton ) ));
    assert_eq! (::std::mem::align_of::<_GtkButton>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkButton ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkButton ) ) . bin as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkButton ) , "::" ,
                stringify ! ( bin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkButton ) ) . priv_ as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkButton ) , "::" ,
                stringify ! ( priv_ ) ));
}
impl Clone for _GtkButton {
    fn clone(&self) -> Self { *self }
}
pub type GtkButton = _GtkButton;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkButtonPrivate {
    _unused: [u8; 0],
}
pub type GtkButtonPrivate = _GtkButtonPrivate;
/**
 * GtkButtonClass:
 * @parent_class: The parent class.
 * @pressed: Signal emitted when the button is pressed. Deprecated: 2.8.
 * @released: Signal emitted when the button is released. Deprecated: 2.8.
 * @clicked: Signal emitted when the button has been activated (pressed and released).
 * @enter: Signal emitted when the pointer enters the button. Deprecated: 2.8.
 * @leave: Signal emitted when the pointer leaves the button. Deprecated: 2.8.
 * @activate: Signal that causes the button to animate press then
 *    release. Applications should never connect to this signal, but use
 *    the @clicked signal.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkButtonClass {
    pub parent_class: GtkBinClass,
    pub pressed: ::std::option::Option<unsafe extern "C" fn(button:
                                                                *mut GtkButton)>,
    pub released: ::std::option::Option<unsafe extern "C" fn(button:
                                                                 *mut GtkButton)>,
    pub clicked: ::std::option::Option<unsafe extern "C" fn(button:
                                                                *mut GtkButton)>,
    pub enter: ::std::option::Option<unsafe extern "C" fn(button:
                                                              *mut GtkButton)>,
    pub leave: ::std::option::Option<unsafe extern "C" fn(button:
                                                              *mut GtkButton)>,
    pub activate: ::std::option::Option<unsafe extern "C" fn(button:
                                                                 *mut GtkButton)>,
    pub _gtk_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GtkButtonClass() {
    assert_eq!(::std::mem::size_of::<_GtkButtonClass>() , 1088usize , concat !
               ( "Size of: " , stringify ! ( _GtkButtonClass ) ));
    assert_eq! (::std::mem::align_of::<_GtkButtonClass>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _GtkButtonClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkButtonClass ) ) . parent_class as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkButtonClass ) ,
                "::" , stringify ! ( parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkButtonClass ) ) . pressed as * const
                _ as usize } , 1008usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkButtonClass ) ,
                "::" , stringify ! ( pressed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkButtonClass ) ) . released as * const
                _ as usize } , 1016usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkButtonClass ) ,
                "::" , stringify ! ( released ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkButtonClass ) ) . clicked as * const
                _ as usize } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkButtonClass ) ,
                "::" , stringify ! ( clicked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkButtonClass ) ) . enter as * const _
                as usize } , 1032usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkButtonClass ) ,
                "::" , stringify ! ( enter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkButtonClass ) ) . leave as * const _
                as usize } , 1040usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkButtonClass ) ,
                "::" , stringify ! ( leave ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkButtonClass ) ) . activate as * const
                _ as usize } , 1048usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkButtonClass ) ,
                "::" , stringify ! ( activate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkButtonClass ) ) . _gtk_reserved1 as *
                const _ as usize } , 1056usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkButtonClass ) ,
                "::" , stringify ! ( _gtk_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkButtonClass ) ) . _gtk_reserved2 as *
                const _ as usize } , 1064usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkButtonClass ) ,
                "::" , stringify ! ( _gtk_reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkButtonClass ) ) . _gtk_reserved3 as *
                const _ as usize } , 1072usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkButtonClass ) ,
                "::" , stringify ! ( _gtk_reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkButtonClass ) ) . _gtk_reserved4 as *
                const _ as usize } , 1080usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkButtonClass ) ,
                "::" , stringify ! ( _gtk_reserved4 ) ));
}
impl Clone for _GtkButtonClass {
    fn clone(&self) -> Self { *self }
}
pub type GtkButtonClass = _GtkButtonClass;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkCalendar {
    pub widget: GtkWidget,
    pub priv_: *mut GtkCalendarPrivate,
}
#[test]
fn bindgen_test_layout__GtkCalendar() {
    assert_eq!(::std::mem::size_of::<_GtkCalendar>() , 40usize , concat ! (
               "Size of: " , stringify ! ( _GtkCalendar ) ));
    assert_eq! (::std::mem::align_of::<_GtkCalendar>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkCalendar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkCalendar ) ) . widget as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkCalendar ) , "::" ,
                stringify ! ( widget ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkCalendar ) ) . priv_ as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkCalendar ) , "::" ,
                stringify ! ( priv_ ) ));
}
impl Clone for _GtkCalendar {
    fn clone(&self) -> Self { *self }
}
pub type GtkCalendar = _GtkCalendar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkCalendarPrivate {
    _unused: [u8; 0],
}
pub type GtkCalendarPrivate = _GtkCalendarPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkMenuItem {
    pub bin: GtkBin,
    pub priv_: *mut GtkMenuItemPrivate,
}
#[test]
fn bindgen_test_layout__GtkMenuItem() {
    assert_eq!(::std::mem::size_of::<_GtkMenuItem>() , 56usize , concat ! (
               "Size of: " , stringify ! ( _GtkMenuItem ) ));
    assert_eq! (::std::mem::align_of::<_GtkMenuItem>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkMenuItem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMenuItem ) ) . bin as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMenuItem ) , "::" ,
                stringify ! ( bin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkMenuItem ) ) . priv_ as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkMenuItem ) , "::" ,
                stringify ! ( priv_ ) ));
}
impl Clone for _GtkMenuItem {
    fn clone(&self) -> Self { *self }
}
pub type GtkMenuItem = _GtkMenuItem;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkMenuItemPrivate {
    _unused: [u8; 0],
}
pub type GtkMenuItemPrivate = _GtkMenuItemPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkCssProvider {
    pub parent_instance: GObject,
    pub priv_: *mut GtkCssProviderPrivate,
}
#[test]
fn bindgen_test_layout__GtkCssProvider() {
    assert_eq!(::std::mem::size_of::<_GtkCssProvider>() , 32usize , concat ! (
               "Size of: " , stringify ! ( _GtkCssProvider ) ));
    assert_eq! (::std::mem::align_of::<_GtkCssProvider>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _GtkCssProvider ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkCssProvider ) ) . parent_instance as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkCssProvider ) ,
                "::" , stringify ! ( parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkCssProvider ) ) . priv_ as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkCssProvider ) ,
                "::" , stringify ! ( priv_ ) ));
}
impl Clone for _GtkCssProvider {
    fn clone(&self) -> Self { *self }
}
pub type GtkCssProvider = _GtkCssProvider;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkCssProviderPrivate {
    _unused: [u8; 0],
}
pub type GtkCssProviderPrivate = _GtkCssProviderPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkEventBox {
    pub bin: GtkBin,
    pub priv_: *mut GtkEventBoxPrivate,
}
#[test]
fn bindgen_test_layout__GtkEventBox() {
    assert_eq!(::std::mem::size_of::<_GtkEventBox>() , 56usize , concat ! (
               "Size of: " , stringify ! ( _GtkEventBox ) ));
    assert_eq! (::std::mem::align_of::<_GtkEventBox>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkEventBox ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEventBox ) ) . bin as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEventBox ) , "::" ,
                stringify ! ( bin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEventBox ) ) . priv_ as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEventBox ) , "::" ,
                stringify ! ( priv_ ) ));
}
impl Clone for _GtkEventBox {
    fn clone(&self) -> Self { *self }
}
pub type GtkEventBox = _GtkEventBox;
/**
 * GtkEventBoxClass:
 * @parent_class: The parent class.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkEventBoxClass {
    pub parent_class: GtkBinClass,
    pub _gtk_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GtkEventBoxClass() {
    assert_eq!(::std::mem::size_of::<_GtkEventBoxClass>() , 1040usize , concat
               ! ( "Size of: " , stringify ! ( _GtkEventBoxClass ) ));
    assert_eq! (::std::mem::align_of::<_GtkEventBoxClass>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _GtkEventBoxClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEventBoxClass ) ) . parent_class as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEventBoxClass ) ,
                "::" , stringify ! ( parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEventBoxClass ) ) . _gtk_reserved1 as
                * const _ as usize } , 1008usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEventBoxClass ) ,
                "::" , stringify ! ( _gtk_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEventBoxClass ) ) . _gtk_reserved2 as
                * const _ as usize } , 1016usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEventBoxClass ) ,
                "::" , stringify ! ( _gtk_reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEventBoxClass ) ) . _gtk_reserved3 as
                * const _ as usize } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEventBoxClass ) ,
                "::" , stringify ! ( _gtk_reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkEventBoxClass ) ) . _gtk_reserved4 as
                * const _ as usize } , 1032usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkEventBoxClass ) ,
                "::" , stringify ! ( _gtk_reserved4 ) ));
}
impl Clone for _GtkEventBoxClass {
    fn clone(&self) -> Self { *self }
}
pub type GtkEventBoxClass = _GtkEventBoxClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkEventBoxPrivate {
    _unused: [u8; 0],
}
pub type GtkEventBoxPrivate = _GtkEventBoxPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkGrid {
    pub container: GtkContainer,
    pub priv_: *mut GtkGridPrivate,
}
#[test]
fn bindgen_test_layout__GtkGrid() {
    assert_eq!(::std::mem::size_of::<_GtkGrid>() , 48usize , concat ! (
               "Size of: " , stringify ! ( _GtkGrid ) ));
    assert_eq! (::std::mem::align_of::<_GtkGrid>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkGrid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkGrid ) ) . container as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkGrid ) , "::" ,
                stringify ! ( container ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkGrid ) ) . priv_ as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkGrid ) , "::" ,
                stringify ! ( priv_ ) ));
}
impl Clone for _GtkGrid {
    fn clone(&self) -> Self { *self }
}
pub type GtkGrid = _GtkGrid;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkGridPrivate {
    _unused: [u8; 0],
}
pub type GtkGridPrivate = _GtkGridPrivate;
/**
 * GtkGridClass:
 * @parent_class: The parent class.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkGridClass {
    pub parent_class: GtkContainerClass,
    pub _gtk_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved8: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GtkGridClass() {
    assert_eq!(::std::mem::size_of::<_GtkGridClass>() , 1040usize , concat ! (
               "Size of: " , stringify ! ( _GtkGridClass ) ));
    assert_eq! (::std::mem::align_of::<_GtkGridClass>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkGridClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkGridClass ) ) . parent_class as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkGridClass ) , "::"
                , stringify ! ( parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkGridClass ) ) . _gtk_reserved1 as *
                const _ as usize } , 976usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkGridClass ) , "::"
                , stringify ! ( _gtk_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkGridClass ) ) . _gtk_reserved2 as *
                const _ as usize } , 984usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkGridClass ) , "::"
                , stringify ! ( _gtk_reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkGridClass ) ) . _gtk_reserved3 as *
                const _ as usize } , 992usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkGridClass ) , "::"
                , stringify ! ( _gtk_reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkGridClass ) ) . _gtk_reserved4 as *
                const _ as usize } , 1000usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkGridClass ) , "::"
                , stringify ! ( _gtk_reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkGridClass ) ) . _gtk_reserved5 as *
                const _ as usize } , 1008usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkGridClass ) , "::"
                , stringify ! ( _gtk_reserved5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkGridClass ) ) . _gtk_reserved6 as *
                const _ as usize } , 1016usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkGridClass ) , "::"
                , stringify ! ( _gtk_reserved6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkGridClass ) ) . _gtk_reserved7 as *
                const _ as usize } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkGridClass ) , "::"
                , stringify ! ( _gtk_reserved7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkGridClass ) ) . _gtk_reserved8 as *
                const _ as usize } , 1032usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkGridClass ) , "::"
                , stringify ! ( _gtk_reserved8 ) ));
}
impl Clone for _GtkGridClass {
    fn clone(&self) -> Self { *self }
}
pub type GtkGridClass = _GtkGridClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkStyleContextPrivate {
    _unused: [u8; 0],
}
pub type GtkStyleContextPrivate = _GtkStyleContextPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkToolItem {
    pub parent: GtkBin,
    pub priv_: *mut GtkToolItemPrivate,
}
#[test]
fn bindgen_test_layout__GtkToolItem() {
    assert_eq!(::std::mem::size_of::<_GtkToolItem>() , 56usize , concat ! (
               "Size of: " , stringify ! ( _GtkToolItem ) ));
    assert_eq! (::std::mem::align_of::<_GtkToolItem>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkToolItem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolItem ) ) . parent as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolItem ) , "::" ,
                stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolItem ) ) . priv_ as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolItem ) , "::" ,
                stringify ! ( priv_ ) ));
}
impl Clone for _GtkToolItem {
    fn clone(&self) -> Self { *self }
}
pub type GtkToolItem = _GtkToolItem;
/**
 * GtkToolItemClass:
 * @parent_class: The parent class.
 * @create_menu_proxy: Signal emitted when the toolbar needs
 *    information from tool_item about whether the item should appear in
 *    the toolbar overflow menu.
 * @toolbar_reconfigured: Signal emitted when some property of the
 *    toolbar that the item is a child of changes.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkToolItemClass {
    pub parent_class: GtkBinClass,
    pub create_menu_proxy: ::std::option::Option<unsafe extern "C" fn(tool_item:
                                                                          *mut GtkToolItem)
                                                     -> gboolean>,
    pub toolbar_reconfigured: ::std::option::Option<unsafe extern "C" fn(tool_item:
                                                                             *mut GtkToolItem)>,
    pub _gtk_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GtkToolItemClass() {
    assert_eq!(::std::mem::size_of::<_GtkToolItemClass>() , 1056usize , concat
               ! ( "Size of: " , stringify ! ( _GtkToolItemClass ) ));
    assert_eq! (::std::mem::align_of::<_GtkToolItemClass>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _GtkToolItemClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolItemClass ) ) . parent_class as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolItemClass ) ,
                "::" , stringify ! ( parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolItemClass ) ) . create_menu_proxy
                as * const _ as usize } , 1008usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolItemClass ) ,
                "::" , stringify ! ( create_menu_proxy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolItemClass ) ) .
                toolbar_reconfigured as * const _ as usize } , 1016usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolItemClass ) ,
                "::" , stringify ! ( toolbar_reconfigured ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolItemClass ) ) . _gtk_reserved1 as
                * const _ as usize } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolItemClass ) ,
                "::" , stringify ! ( _gtk_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolItemClass ) ) . _gtk_reserved2 as
                * const _ as usize } , 1032usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolItemClass ) ,
                "::" , stringify ! ( _gtk_reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolItemClass ) ) . _gtk_reserved3 as
                * const _ as usize } , 1040usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolItemClass ) ,
                "::" , stringify ! ( _gtk_reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolItemClass ) ) . _gtk_reserved4 as
                * const _ as usize } , 1048usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolItemClass ) ,
                "::" , stringify ! ( _gtk_reserved4 ) ));
}
impl Clone for _GtkToolItemClass {
    fn clone(&self) -> Self { *self }
}
pub type GtkToolItemClass = _GtkToolItemClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkToolItemPrivate {
    _unused: [u8; 0],
}
pub type GtkToolItemPrivate = _GtkToolItemPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkToolButton {
    pub parent: GtkToolItem,
    pub priv_: *mut GtkToolButtonPrivate,
}
#[test]
fn bindgen_test_layout__GtkToolButton() {
    assert_eq!(::std::mem::size_of::<_GtkToolButton>() , 64usize , concat ! (
               "Size of: " , stringify ! ( _GtkToolButton ) ));
    assert_eq! (::std::mem::align_of::<_GtkToolButton>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkToolButton ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolButton ) ) . parent as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolButton ) , "::"
                , stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolButton ) ) . priv_ as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolButton ) , "::"
                , stringify ! ( priv_ ) ));
}
impl Clone for _GtkToolButton {
    fn clone(&self) -> Self { *self }
}
pub type GtkToolButton = _GtkToolButton;
/**
 * GtkToolButtonClass:
 * @parent_class: The parent class.
 * @button_type: 
 * @clicked: Signal emitted when the tool button is clicked with the
 *    mouse or activated with the keyboard.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkToolButtonClass {
    pub parent_class: GtkToolItemClass,
    pub button_type: GType,
    pub clicked: ::std::option::Option<unsafe extern "C" fn(tool_item:
                                                                *mut GtkToolButton)>,
    pub _gtk_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GtkToolButtonClass() {
    assert_eq!(::std::mem::size_of::<_GtkToolButtonClass>() , 1104usize ,
               concat ! ( "Size of: " , stringify ! ( _GtkToolButtonClass )
               ));
    assert_eq! (::std::mem::align_of::<_GtkToolButtonClass>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GtkToolButtonClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolButtonClass ) ) . parent_class as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolButtonClass ) ,
                "::" , stringify ! ( parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolButtonClass ) ) . button_type as
                * const _ as usize } , 1056usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolButtonClass ) ,
                "::" , stringify ! ( button_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolButtonClass ) ) . clicked as *
                const _ as usize } , 1064usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolButtonClass ) ,
                "::" , stringify ! ( clicked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolButtonClass ) ) . _gtk_reserved1
                as * const _ as usize } , 1072usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolButtonClass ) ,
                "::" , stringify ! ( _gtk_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolButtonClass ) ) . _gtk_reserved2
                as * const _ as usize } , 1080usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolButtonClass ) ,
                "::" , stringify ! ( _gtk_reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolButtonClass ) ) . _gtk_reserved3
                as * const _ as usize } , 1088usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolButtonClass ) ,
                "::" , stringify ! ( _gtk_reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolButtonClass ) ) . _gtk_reserved4
                as * const _ as usize } , 1096usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolButtonClass ) ,
                "::" , stringify ! ( _gtk_reserved4 ) ));
}
impl Clone for _GtkToolButtonClass {
    fn clone(&self) -> Self { *self }
}
pub type GtkToolButtonClass = _GtkToolButtonClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkToolButtonPrivate {
    _unused: [u8; 0],
}
pub type GtkToolButtonPrivate = _GtkToolButtonPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkOverlay {
    pub parent: GtkBin,
    pub priv_: *mut GtkOverlayPrivate,
}
#[test]
fn bindgen_test_layout__GtkOverlay() {
    assert_eq!(::std::mem::size_of::<_GtkOverlay>() , 56usize , concat ! (
               "Size of: " , stringify ! ( _GtkOverlay ) ));
    assert_eq! (::std::mem::align_of::<_GtkOverlay>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkOverlay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkOverlay ) ) . parent as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkOverlay ) , "::" ,
                stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkOverlay ) ) . priv_ as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkOverlay ) , "::" ,
                stringify ! ( priv_ ) ));
}
impl Clone for _GtkOverlay {
    fn clone(&self) -> Self { *self }
}
pub type GtkOverlay = _GtkOverlay;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkOverlayPrivate {
    _unused: [u8; 0],
}
pub type GtkOverlayPrivate = _GtkOverlayPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkPaned {
    pub container: GtkContainer,
    pub priv_: *mut GtkPanedPrivate,
}
#[test]
fn bindgen_test_layout__GtkPaned() {
    assert_eq!(::std::mem::size_of::<_GtkPaned>() , 48usize , concat ! (
               "Size of: " , stringify ! ( _GtkPaned ) ));
    assert_eq! (::std::mem::align_of::<_GtkPaned>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkPaned ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkPaned ) ) . container as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkPaned ) , "::" ,
                stringify ! ( container ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkPaned ) ) . priv_ as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkPaned ) , "::" ,
                stringify ! ( priv_ ) ));
}
impl Clone for _GtkPaned {
    fn clone(&self) -> Self { *self }
}
pub type GtkPaned = _GtkPaned;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkPanedClass {
    pub parent_class: GtkContainerClass,
    pub cycle_child_focus: ::std::option::Option<unsafe extern "C" fn(paned:
                                                                          *mut GtkPaned,
                                                                      reverse:
                                                                          gboolean)
                                                     -> gboolean>,
    pub toggle_handle_focus: ::std::option::Option<unsafe extern "C" fn(paned:
                                                                            *mut GtkPaned)
                                                       -> gboolean>,
    pub move_handle: ::std::option::Option<unsafe extern "C" fn(paned:
                                                                    *mut GtkPaned,
                                                                scroll:
                                                                    GtkScrollType)
                                               -> gboolean>,
    pub cycle_handle_focus: ::std::option::Option<unsafe extern "C" fn(paned:
                                                                           *mut GtkPaned,
                                                                       reverse:
                                                                           gboolean)
                                                      -> gboolean>,
    pub accept_position: ::std::option::Option<unsafe extern "C" fn(paned:
                                                                        *mut GtkPaned)
                                                   -> gboolean>,
    pub cancel_position: ::std::option::Option<unsafe extern "C" fn(paned:
                                                                        *mut GtkPaned)
                                                   -> gboolean>,
    pub _gtk_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GtkPanedClass() {
    assert_eq!(::std::mem::size_of::<_GtkPanedClass>() , 1056usize , concat !
               ( "Size of: " , stringify ! ( _GtkPanedClass ) ));
    assert_eq! (::std::mem::align_of::<_GtkPanedClass>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkPanedClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkPanedClass ) ) . parent_class as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkPanedClass ) , "::"
                , stringify ! ( parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkPanedClass ) ) . cycle_child_focus as
                * const _ as usize } , 976usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkPanedClass ) , "::"
                , stringify ! ( cycle_child_focus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkPanedClass ) ) . toggle_handle_focus
                as * const _ as usize } , 984usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkPanedClass ) , "::"
                , stringify ! ( toggle_handle_focus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkPanedClass ) ) . move_handle as *
                const _ as usize } , 992usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkPanedClass ) , "::"
                , stringify ! ( move_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkPanedClass ) ) . cycle_handle_focus
                as * const _ as usize } , 1000usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkPanedClass ) , "::"
                , stringify ! ( cycle_handle_focus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkPanedClass ) ) . accept_position as *
                const _ as usize } , 1008usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkPanedClass ) , "::"
                , stringify ! ( accept_position ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkPanedClass ) ) . cancel_position as *
                const _ as usize } , 1016usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkPanedClass ) , "::"
                , stringify ! ( cancel_position ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkPanedClass ) ) . _gtk_reserved1 as *
                const _ as usize } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkPanedClass ) , "::"
                , stringify ! ( _gtk_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkPanedClass ) ) . _gtk_reserved2 as *
                const _ as usize } , 1032usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkPanedClass ) , "::"
                , stringify ! ( _gtk_reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkPanedClass ) ) . _gtk_reserved3 as *
                const _ as usize } , 1040usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkPanedClass ) , "::"
                , stringify ! ( _gtk_reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkPanedClass ) ) . _gtk_reserved4 as *
                const _ as usize } , 1048usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkPanedClass ) , "::"
                , stringify ! ( _gtk_reserved4 ) ));
}
impl Clone for _GtkPanedClass {
    fn clone(&self) -> Self { *self }
}
pub type GtkPanedClass = _GtkPanedClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkPanedPrivate {
    _unused: [u8; 0],
}
pub type GtkPanedPrivate = _GtkPanedPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkToggleToolButton {
    pub parent: GtkToolButton,
    pub priv_: *mut GtkToggleToolButtonPrivate,
}
#[test]
fn bindgen_test_layout__GtkToggleToolButton() {
    assert_eq!(::std::mem::size_of::<_GtkToggleToolButton>() , 72usize ,
               concat ! ( "Size of: " , stringify ! ( _GtkToggleToolButton )
               ));
    assert_eq! (::std::mem::align_of::<_GtkToggleToolButton>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GtkToggleToolButton ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToggleToolButton ) ) . parent as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToggleToolButton )
                , "::" , stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToggleToolButton ) ) . priv_ as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToggleToolButton )
                , "::" , stringify ! ( priv_ ) ));
}
impl Clone for _GtkToggleToolButton {
    fn clone(&self) -> Self { *self }
}
pub type GtkToggleToolButton = _GtkToggleToolButton;
/**
 * GtkToggleToolButtonClass:
 * @parent_class: The parent class.
 * @toggled: Signal emitted whenever the toggle tool button changes state.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkToggleToolButtonClass {
    pub parent_class: GtkToolButtonClass,
    pub toggled: ::std::option::Option<unsafe extern "C" fn(button:
                                                                *mut GtkToggleToolButton)>,
    pub _gtk_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GtkToggleToolButtonClass() {
    assert_eq!(::std::mem::size_of::<_GtkToggleToolButtonClass>() , 1144usize
               , concat ! (
               "Size of: " , stringify ! ( _GtkToggleToolButtonClass ) ));
    assert_eq! (::std::mem::align_of::<_GtkToggleToolButtonClass>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GtkToggleToolButtonClass )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToggleToolButtonClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GtkToggleToolButtonClass ) , "::" , stringify ! (
                parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToggleToolButtonClass ) ) . toggled
                as * const _ as usize } , 1104usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GtkToggleToolButtonClass ) , "::" , stringify ! ( toggled )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToggleToolButtonClass ) ) .
                _gtk_reserved1 as * const _ as usize } , 1112usize , concat !
                (
                "Alignment of field: " , stringify ! (
                _GtkToggleToolButtonClass ) , "::" , stringify ! (
                _gtk_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToggleToolButtonClass ) ) .
                _gtk_reserved2 as * const _ as usize } , 1120usize , concat !
                (
                "Alignment of field: " , stringify ! (
                _GtkToggleToolButtonClass ) , "::" , stringify ! (
                _gtk_reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToggleToolButtonClass ) ) .
                _gtk_reserved3 as * const _ as usize } , 1128usize , concat !
                (
                "Alignment of field: " , stringify ! (
                _GtkToggleToolButtonClass ) , "::" , stringify ! (
                _gtk_reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToggleToolButtonClass ) ) .
                _gtk_reserved4 as * const _ as usize } , 1136usize , concat !
                (
                "Alignment of field: " , stringify ! (
                _GtkToggleToolButtonClass ) , "::" , stringify ! (
                _gtk_reserved4 ) ));
}
impl Clone for _GtkToggleToolButtonClass {
    fn clone(&self) -> Self { *self }
}
pub type GtkToggleToolButtonClass = _GtkToggleToolButtonClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkToggleToolButtonPrivate {
    _unused: [u8; 0],
}
pub type GtkToggleToolButtonPrivate = _GtkToggleToolButtonPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkRevealer {
    pub parent_instance: GtkBin,
}
#[test]
fn bindgen_test_layout__GtkRevealer() {
    assert_eq!(::std::mem::size_of::<_GtkRevealer>() , 48usize , concat ! (
               "Size of: " , stringify ! ( _GtkRevealer ) ));
    assert_eq! (::std::mem::align_of::<_GtkRevealer>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkRevealer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkRevealer ) ) . parent_instance as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkRevealer ) , "::" ,
                stringify ! ( parent_instance ) ));
}
impl Clone for _GtkRevealer {
    fn clone(&self) -> Self { *self }
}
pub type GtkRevealer = _GtkRevealer;
/**
 * GtkRevealerClass:
 * @parent_class: The parent class.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkRevealerClass {
    pub parent_class: GtkBinClass,
}
#[test]
fn bindgen_test_layout__GtkRevealerClass() {
    assert_eq!(::std::mem::size_of::<_GtkRevealerClass>() , 1008usize , concat
               ! ( "Size of: " , stringify ! ( _GtkRevealerClass ) ));
    assert_eq! (::std::mem::align_of::<_GtkRevealerClass>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _GtkRevealerClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkRevealerClass ) ) . parent_class as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkRevealerClass ) ,
                "::" , stringify ! ( parent_class ) ));
}
impl Clone for _GtkRevealerClass {
    fn clone(&self) -> Self { *self }
}
pub type GtkRevealerClass = _GtkRevealerClass;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkScrolledWindow {
    pub container: GtkBin,
    pub priv_: *mut GtkScrolledWindowPrivate,
}
#[test]
fn bindgen_test_layout__GtkScrolledWindow() {
    assert_eq!(::std::mem::size_of::<_GtkScrolledWindow>() , 56usize , concat
               ! ( "Size of: " , stringify ! ( _GtkScrolledWindow ) ));
    assert_eq! (::std::mem::align_of::<_GtkScrolledWindow>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _GtkScrolledWindow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkScrolledWindow ) ) . container as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkScrolledWindow ) ,
                "::" , stringify ! ( container ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkScrolledWindow ) ) . priv_ as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkScrolledWindow ) ,
                "::" , stringify ! ( priv_ ) ));
}
impl Clone for _GtkScrolledWindow {
    fn clone(&self) -> Self { *self }
}
pub type GtkScrolledWindow = _GtkScrolledWindow;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkScrolledWindowPrivate {
    _unused: [u8; 0],
}
pub type GtkScrolledWindowPrivate = _GtkScrolledWindowPrivate;
/**
 * GtkScrolledWindowClass:
 * @parent_class: The parent class.
 * @scrollbar_spacing: 
 * @scroll_child: Keybinding signal which gets emitted when a
 *    keybinding that scrolls is pressed.
 * @move_focus_out: Keybinding signal which gets emitted when focus is
 *    moved away from the scrolled window by a keybinding.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkScrolledWindowClass {
    pub parent_class: GtkBinClass,
    pub scrollbar_spacing: gint,
    pub scroll_child: ::std::option::Option<unsafe extern "C" fn(scrolled_window:
                                                                     *mut GtkScrolledWindow,
                                                                 scroll:
                                                                     GtkScrollType,
                                                                 horizontal:
                                                                     gboolean)
                                                -> gboolean>,
    pub move_focus_out: ::std::option::Option<unsafe extern "C" fn(scrolled_window:
                                                                       *mut GtkScrolledWindow,
                                                                   direction:
                                                                       GtkDirectionType)>,
    pub _gtk_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GtkScrolledWindowClass() {
    assert_eq!(::std::mem::size_of::<_GtkScrolledWindowClass>() , 1064usize ,
               concat ! (
               "Size of: " , stringify ! ( _GtkScrolledWindowClass ) ));
    assert_eq! (::std::mem::align_of::<_GtkScrolledWindowClass>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GtkScrolledWindowClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkScrolledWindowClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkScrolledWindowClass
                ) , "::" , stringify ! ( parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkScrolledWindowClass ) ) .
                scrollbar_spacing as * const _ as usize } , 1008usize , concat
                ! (
                "Alignment of field: " , stringify ! ( _GtkScrolledWindowClass
                ) , "::" , stringify ! ( scrollbar_spacing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkScrolledWindowClass ) ) .
                scroll_child as * const _ as usize } , 1016usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkScrolledWindowClass
                ) , "::" , stringify ! ( scroll_child ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkScrolledWindowClass ) ) .
                move_focus_out as * const _ as usize } , 1024usize , concat !
                (
                "Alignment of field: " , stringify ! ( _GtkScrolledWindowClass
                ) , "::" , stringify ! ( move_focus_out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkScrolledWindowClass ) ) .
                _gtk_reserved1 as * const _ as usize } , 1032usize , concat !
                (
                "Alignment of field: " , stringify ! ( _GtkScrolledWindowClass
                ) , "::" , stringify ! ( _gtk_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkScrolledWindowClass ) ) .
                _gtk_reserved2 as * const _ as usize } , 1040usize , concat !
                (
                "Alignment of field: " , stringify ! ( _GtkScrolledWindowClass
                ) , "::" , stringify ! ( _gtk_reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkScrolledWindowClass ) ) .
                _gtk_reserved3 as * const _ as usize } , 1048usize , concat !
                (
                "Alignment of field: " , stringify ! ( _GtkScrolledWindowClass
                ) , "::" , stringify ! ( _gtk_reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkScrolledWindowClass ) ) .
                _gtk_reserved4 as * const _ as usize } , 1056usize , concat !
                (
                "Alignment of field: " , stringify ! ( _GtkScrolledWindowClass
                ) , "::" , stringify ! ( _gtk_reserved4 ) ));
}
impl Clone for _GtkScrolledWindowClass {
    fn clone(&self) -> Self { *self }
}
pub type GtkScrolledWindowClass = _GtkScrolledWindowClass;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkToolbar {
    pub container: GtkContainer,
    pub priv_: *mut GtkToolbarPrivate,
}
#[test]
fn bindgen_test_layout__GtkToolbar() {
    assert_eq!(::std::mem::size_of::<_GtkToolbar>() , 48usize , concat ! (
               "Size of: " , stringify ! ( _GtkToolbar ) ));
    assert_eq! (::std::mem::align_of::<_GtkToolbar>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkToolbar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolbar ) ) . container as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolbar ) , "::" ,
                stringify ! ( container ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolbar ) ) . priv_ as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolbar ) , "::" ,
                stringify ! ( priv_ ) ));
}
impl Clone for _GtkToolbar {
    fn clone(&self) -> Self { *self }
}
pub type GtkToolbar = _GtkToolbar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkToolbarPrivate {
    _unused: [u8; 0],
}
pub type GtkToolbarPrivate = _GtkToolbarPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkToolbarClass {
    pub parent_class: GtkContainerClass,
    pub orientation_changed: ::std::option::Option<unsafe extern "C" fn(toolbar:
                                                                            *mut GtkToolbar,
                                                                        orientation:
                                                                            GtkOrientation)>,
    pub style_changed: ::std::option::Option<unsafe extern "C" fn(toolbar:
                                                                      *mut GtkToolbar,
                                                                  style:
                                                                      GtkToolbarStyle)>,
    pub popup_context_menu: ::std::option::Option<unsafe extern "C" fn(toolbar:
                                                                           *mut GtkToolbar,
                                                                       x:
                                                                           gint,
                                                                       y:
                                                                           gint,
                                                                       button_number:
                                                                           gint)
                                                      -> gboolean>,
    pub _gtk_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _gtk_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GtkToolbarClass() {
    assert_eq!(::std::mem::size_of::<_GtkToolbarClass>() , 1032usize , concat
               ! ( "Size of: " , stringify ! ( _GtkToolbarClass ) ));
    assert_eq! (::std::mem::align_of::<_GtkToolbarClass>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _GtkToolbarClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolbarClass ) ) . parent_class as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolbarClass ) ,
                "::" , stringify ! ( parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolbarClass ) ) .
                orientation_changed as * const _ as usize } , 976usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolbarClass ) ,
                "::" , stringify ! ( orientation_changed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolbarClass ) ) . style_changed as *
                const _ as usize } , 984usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolbarClass ) ,
                "::" , stringify ! ( style_changed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolbarClass ) ) . popup_context_menu
                as * const _ as usize } , 992usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolbarClass ) ,
                "::" , stringify ! ( popup_context_menu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolbarClass ) ) . _gtk_reserved1 as
                * const _ as usize } , 1000usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolbarClass ) ,
                "::" , stringify ! ( _gtk_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolbarClass ) ) . _gtk_reserved2 as
                * const _ as usize } , 1008usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolbarClass ) ,
                "::" , stringify ! ( _gtk_reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolbarClass ) ) . _gtk_reserved3 as
                * const _ as usize } , 1016usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolbarClass ) ,
                "::" , stringify ! ( _gtk_reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkToolbarClass ) ) . _gtk_reserved4 as
                * const _ as usize } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkToolbarClass ) ,
                "::" , stringify ! ( _gtk_reserved4 ) ));
}
impl Clone for _GtkToolbarClass {
    fn clone(&self) -> Self { *self }
}
pub type GtkToolbarClass = _GtkToolbarClass;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkAction {
    pub object: GObject,
    pub private_data: *mut GtkActionPrivate,
}
#[test]
fn bindgen_test_layout__GtkAction() {
    assert_eq!(::std::mem::size_of::<_GtkAction>() , 32usize , concat ! (
               "Size of: " , stringify ! ( _GtkAction ) ));
    assert_eq! (::std::mem::align_of::<_GtkAction>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _GtkAction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkAction ) ) . object as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkAction ) , "::" ,
                stringify ! ( object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GtkAction ) ) . private_data as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GtkAction ) , "::" ,
                stringify ! ( private_data ) ));
}
impl Clone for _GtkAction {
    fn clone(&self) -> Self { *self }
}
pub type GtkAction = _GtkAction;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GtkActionPrivate {
    _unused: [u8; 0],
}
pub type GtkActionPrivate = _GtkActionPrivate;
#[repr(u32)]
/**
 * GtkRcFlags:
 * @GTK_RC_FG :Deprecated
 * @GTK_RC_BG: Deprecated
 * @GTK_RC_TEXT: Deprecated
 * @GTK_RC_BASE: Deprecated
 *
 * Deprecated
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GtkRcFlags {
    GTK_RC_FG = 1,
    GTK_RC_BG = 2,
    GTK_RC_TEXT = 4,
    GTK_RC_BASE = 8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GeeCollection {
    _unused: [u8; 0],
}
pub type GeeCollection = _GeeCollection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GeeList {
    _unused: [u8; 0],
}
pub type GeeList = _GeeList;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteApplication {
    pub parent_instance: GtkApplication,
    pub priv_: *mut GraniteApplicationPrivate,
    pub build_data_dir: *mut gchar,
    pub build_pkg_data_dir: *mut gchar,
    pub build_release_name: *mut gchar,
    pub build_version: *mut gchar,
    pub build_version_info: *mut gchar,
    pub program_name: *mut gchar,
    pub exec_name: *mut gchar,
    pub app_copyright: *mut gchar,
    pub app_years: *mut gchar,
    pub app_icon: *mut gchar,
    pub app_launcher: *mut gchar,
    pub main_url: *mut gchar,
    pub bug_url: *mut gchar,
    pub help_url: *mut gchar,
    pub translate_url: *mut gchar,
    pub about_authors: *mut *mut gchar,
    pub about_authors_length1: gint,
    pub about_documenters: *mut *mut gchar,
    pub about_documenters_length1: gint,
    pub about_artists: *mut *mut gchar,
    pub about_artists_length1: gint,
    pub about_comments: *mut gchar,
    pub about_translators: *mut gchar,
    pub about_license: *mut gchar,
    pub about_license_type: GtkLicense,
    pub about_dlg: *mut GraniteWidgetsAboutDialog,
}
#[test]
fn bindgen_test_layout__GraniteApplication() {
    assert_eq!(::std::mem::size_of::<_GraniteApplication>() , 256usize ,
               concat ! ( "Size of: " , stringify ! ( _GraniteApplication )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteApplication>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteApplication ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) . parent_instance
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) . priv_ as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( priv_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) . build_data_dir
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( build_data_dir ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) .
                build_pkg_data_dir as * const _ as usize } , 56usize , concat
                ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( build_pkg_data_dir ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) .
                build_release_name as * const _ as usize } , 64usize , concat
                ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( build_release_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) . build_version
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( build_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) .
                build_version_info as * const _ as usize } , 80usize , concat
                ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( build_version_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) . program_name as
                * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( program_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) . exec_name as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( exec_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) . app_copyright
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( app_copyright ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) . app_years as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( app_years ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) . app_icon as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( app_icon ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) . app_launcher as
                * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( app_launcher ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) . main_url as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( main_url ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) . bug_url as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( bug_url ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) . help_url as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( help_url ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) . translate_url
                as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( translate_url ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) . about_authors
                as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( about_authors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) .
                about_authors_length1 as * const _ as usize } , 176usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( about_authors_length1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) .
                about_documenters as * const _ as usize } , 184usize , concat
                ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( about_documenters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) .
                about_documenters_length1 as * const _ as usize } , 192usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( about_documenters_length1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) . about_artists
                as * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( about_artists ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) .
                about_artists_length1 as * const _ as usize } , 208usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( about_artists_length1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) . about_comments
                as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( about_comments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) .
                about_translators as * const _ as usize } , 224usize , concat
                ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( about_translators ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) . about_license
                as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( about_license ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) .
                about_license_type as * const _ as usize } , 240usize , concat
                ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( about_license_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplication ) ) . about_dlg as *
                const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteApplication ) ,
                "::" , stringify ! ( about_dlg ) ));
}
impl Clone for _GraniteApplication {
    fn clone(&self) -> Self { *self }
}
pub type GraniteApplication = _GraniteApplication;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteApplicationClass {
    pub parent_class: GtkApplicationClass,
    pub set_options: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                    *mut GraniteApplication)>,
    pub show_about: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                   *mut GraniteApplication,
                                                               parent:
                                                                   *mut GtkWidget)>,
}
#[test]
fn bindgen_test_layout__GraniteApplicationClass() {
    assert_eq!(::std::mem::size_of::<_GraniteApplicationClass>() , 440usize ,
               concat ! (
               "Size of: " , stringify ! ( _GraniteApplicationClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteApplicationClass>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteApplicationClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplicationClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteApplicationClass ) , "::" , stringify ! ( parent_class
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplicationClass ) ) .
                set_options as * const _ as usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteApplicationClass ) , "::" , stringify ! ( set_options
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteApplicationClass ) ) . show_about
                as * const _ as usize } , 432usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteApplicationClass ) , "::" , stringify ! ( show_about )
                ));
}
impl Clone for _GraniteApplicationClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteApplicationClass = _GraniteApplicationClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteApplicationPrivate {
    _unused: [u8; 0],
}
pub type GraniteApplicationPrivate = _GraniteApplicationPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteGtkPatchAboutDialog {
    pub parent_instance: GtkDialog,
    pub priv_: *mut GraniteGtkPatchAboutDialogPrivate,
}
#[test]
fn bindgen_test_layout__GraniteGtkPatchAboutDialog() {
    assert_eq!(::std::mem::size_of::<_GraniteGtkPatchAboutDialog>() , 72usize
               , concat ! (
               "Size of: " , stringify ! ( _GraniteGtkPatchAboutDialog ) ));
    assert_eq! (::std::mem::align_of::<_GraniteGtkPatchAboutDialog>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _GraniteGtkPatchAboutDialog )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteGtkPatchAboutDialog ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteGtkPatchAboutDialog ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteGtkPatchAboutDialog ) ) . priv_
                as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteGtkPatchAboutDialog ) , "::" , stringify ! ( priv_ )
                ));
}
impl Clone for _GraniteGtkPatchAboutDialog {
    fn clone(&self) -> Self { *self }
}
pub type GraniteGtkPatchAboutDialog = _GraniteGtkPatchAboutDialog;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteGtkPatchAboutDialogClass {
    pub parent_class: GtkDialogClass,
    pub activate_link: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                      *mut GraniteGtkPatchAboutDialog,
                                                                  uri:
                                                                      *const gchar)
                                                 -> gboolean>,
}
#[test]
fn bindgen_test_layout__GraniteGtkPatchAboutDialogClass() {
    assert_eq!(::std::mem::size_of::<_GraniteGtkPatchAboutDialogClass>() ,
               1128usize , concat ! (
               "Size of: " , stringify ! ( _GraniteGtkPatchAboutDialogClass )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteGtkPatchAboutDialogClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteGtkPatchAboutDialogClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteGtkPatchAboutDialogClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteGtkPatchAboutDialogClass ) , "::" , stringify ! (
                parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteGtkPatchAboutDialogClass ) ) .
                activate_link as * const _ as usize } , 1120usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteGtkPatchAboutDialogClass ) , "::" , stringify ! (
                activate_link ) ));
}
impl Clone for _GraniteGtkPatchAboutDialogClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteGtkPatchAboutDialogClass = _GraniteGtkPatchAboutDialogClass;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsAboutDialog {
    pub parent_instance: GraniteGtkPatchAboutDialog,
    pub priv_: *mut GraniteWidgetsAboutDialogPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsAboutDialog() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsAboutDialog>() , 80usize ,
               concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsAboutDialog ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsAboutDialog>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsAboutDialog )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsAboutDialog ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsAboutDialog ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsAboutDialog ) ) . priv_ as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsAboutDialog ) , "::" , stringify ! ( priv_ )
                ));
}
impl Clone for _GraniteWidgetsAboutDialog {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsAboutDialog = _GraniteWidgetsAboutDialog;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsAboutDialogClass {
    pub parent_class: GraniteGtkPatchAboutDialogClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsAboutDialogClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsAboutDialogClass>() ,
               1128usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsAboutDialogClass )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsAboutDialogClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsAboutDialogClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsAboutDialogClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsAboutDialogClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsAboutDialogClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsAboutDialogClass = _GraniteWidgetsAboutDialogClass;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsToolButtonWithMenu {
    pub parent_instance: GtkToggleToolButton,
    pub priv_: *mut GraniteWidgetsToolButtonWithMenuPrivate,
    pub myaction: *mut GtkAction,
    pub toggled_sig_id: gulong,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsToolButtonWithMenu() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsToolButtonWithMenu>() ,
               96usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsToolButtonWithMenu )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsToolButtonWithMenu>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsToolButtonWithMenu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsToolButtonWithMenu ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsToolButtonWithMenu ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsToolButtonWithMenu ) ) .
                priv_ as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsToolButtonWithMenu ) , "::" , stringify ! (
                priv_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsToolButtonWithMenu ) ) .
                myaction as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsToolButtonWithMenu ) , "::" , stringify ! (
                myaction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsToolButtonWithMenu ) ) .
                toggled_sig_id as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsToolButtonWithMenu ) , "::" , stringify ! (
                toggled_sig_id ) ));
}
impl Clone for _GraniteWidgetsToolButtonWithMenu {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsToolButtonWithMenu = _GraniteWidgetsToolButtonWithMenu;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsToolButtonWithMenuClass {
    pub parent_class: GtkToggleToolButtonClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsToolButtonWithMenuClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsToolButtonWithMenuClass>()
               , 1144usize , concat ! (
               "Size of: " , stringify ! (
               _GraniteWidgetsToolButtonWithMenuClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsToolButtonWithMenuClass>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsToolButtonWithMenuClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsToolButtonWithMenuClass )
                ) . parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsToolButtonWithMenuClass ) , "::" , stringify !
                ( parent_class ) ));
}
impl Clone for _GraniteWidgetsToolButtonWithMenuClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsToolButtonWithMenuClass =
    _GraniteWidgetsToolButtonWithMenuClass;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsAppMenu {
    pub parent_instance: GraniteWidgetsToolButtonWithMenu,
    pub priv_: *mut GraniteWidgetsAppMenuPrivate,
    pub about_item: *mut GtkMenuItem,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsAppMenu() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsAppMenu>() , 112usize ,
               concat ! ( "Size of: " , stringify ! ( _GraniteWidgetsAppMenu )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsAppMenu>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsAppMenu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsAppMenu ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsAppMenu
                ) , "::" , stringify ! ( parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsAppMenu ) ) . priv_ as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsAppMenu
                ) , "::" , stringify ! ( priv_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsAppMenu ) ) . about_item
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsAppMenu
                ) , "::" , stringify ! ( about_item ) ));
}
impl Clone for _GraniteWidgetsAppMenu {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsAppMenu = _GraniteWidgetsAppMenu;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsAppMenuClass {
    pub parent_class: GraniteWidgetsToolButtonWithMenuClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsAppMenuClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsAppMenuClass>() ,
               1144usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsAppMenuClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsAppMenuClass>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsAppMenuClass )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsAppMenuClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsAppMenuClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsAppMenuClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsAppMenuClass = _GraniteWidgetsAppMenuClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteServicesSettingsSerializable {
    _unused: [u8; 0],
}
pub type GraniteServicesSettingsSerializable =
    _GraniteServicesSettingsSerializable;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteServicesSettingsSerializableIface {
    pub parent_iface: GTypeInterface,
    pub settings_serialize: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                           *mut GraniteServicesSettingsSerializable)
                                                      -> *mut gchar>,
    pub settings_deserialize: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                             *mut GraniteServicesSettingsSerializable,
                                                                         s:
                                                                             *const gchar)>,
}
#[test]
fn bindgen_test_layout__GraniteServicesSettingsSerializableIface() {
    assert_eq!(::std::mem::size_of::<_GraniteServicesSettingsSerializableIface>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               _GraniteServicesSettingsSerializableIface ) ));
    assert_eq! (::std::mem::align_of::<_GraniteServicesSettingsSerializableIface>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteServicesSettingsSerializableIface ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const _GraniteServicesSettingsSerializableIface ) )
                . parent_iface as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesSettingsSerializableIface ) , "::" , stringify
                ! ( parent_iface ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const _GraniteServicesSettingsSerializableIface ) )
                . settings_serialize as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesSettingsSerializableIface ) , "::" , stringify
                ! ( settings_serialize ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const _GraniteServicesSettingsSerializableIface ) )
                . settings_deserialize as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesSettingsSerializableIface ) , "::" , stringify
                ! ( settings_deserialize ) ));
}
impl Clone for _GraniteServicesSettingsSerializableIface {
    fn clone(&self) -> Self { *self }
}
pub type GraniteServicesSettingsSerializableIface =
    _GraniteServicesSettingsSerializableIface;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteDrawingColor {
    pub parent_instance: GObject,
    pub priv_: *mut GraniteDrawingColorPrivate,
    pub R: gdouble,
    pub G: gdouble,
    pub B: gdouble,
    pub A: gdouble,
}
#[test]
fn bindgen_test_layout__GraniteDrawingColor() {
    assert_eq!(::std::mem::size_of::<_GraniteDrawingColor>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( _GraniteDrawingColor )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteDrawingColor>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteDrawingColor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteDrawingColor ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteDrawingColor )
                , "::" , stringify ! ( parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteDrawingColor ) ) . priv_ as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteDrawingColor )
                , "::" , stringify ! ( priv_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteDrawingColor ) ) . R as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteDrawingColor )
                , "::" , stringify ! ( R ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteDrawingColor ) ) . G as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteDrawingColor )
                , "::" , stringify ! ( G ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteDrawingColor ) ) . B as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteDrawingColor )
                , "::" , stringify ! ( B ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteDrawingColor ) ) . A as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteDrawingColor )
                , "::" , stringify ! ( A ) ));
}
impl Clone for _GraniteDrawingColor {
    fn clone(&self) -> Self { *self }
}
pub type GraniteDrawingColor = _GraniteDrawingColor;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteDrawingColorClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GraniteDrawingColorClass() {
    assert_eq!(::std::mem::size_of::<_GraniteDrawingColorClass>() , 136usize ,
               concat ! (
               "Size of: " , stringify ! ( _GraniteDrawingColorClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteDrawingColorClass>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteDrawingColorClass )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteDrawingColorClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteDrawingColorClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteDrawingColorClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteDrawingColorClass = _GraniteDrawingColorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteDrawingColorPrivate {
    _unused: [u8; 0],
}
pub type GraniteDrawingColorPrivate = _GraniteDrawingColorPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteDrawingBufferSurface {
    pub parent_instance: GObject,
    pub priv_: *mut GraniteDrawingBufferSurfacePrivate,
}
#[test]
fn bindgen_test_layout__GraniteDrawingBufferSurface() {
    assert_eq!(::std::mem::size_of::<_GraniteDrawingBufferSurface>() , 32usize
               , concat ! (
               "Size of: " , stringify ! ( _GraniteDrawingBufferSurface ) ));
    assert_eq! (::std::mem::align_of::<_GraniteDrawingBufferSurface>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _GraniteDrawingBufferSurface )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteDrawingBufferSurface ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteDrawingBufferSurface ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteDrawingBufferSurface ) ) . priv_
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteDrawingBufferSurface ) , "::" , stringify ! ( priv_ )
                ));
}
impl Clone for _GraniteDrawingBufferSurface {
    fn clone(&self) -> Self { *self }
}
pub type GraniteDrawingBufferSurface = _GraniteDrawingBufferSurface;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteDrawingBufferSurfaceClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GraniteDrawingBufferSurfaceClass() {
    assert_eq!(::std::mem::size_of::<_GraniteDrawingBufferSurfaceClass>() ,
               136usize , concat ! (
               "Size of: " , stringify ! ( _GraniteDrawingBufferSurfaceClass )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteDrawingBufferSurfaceClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteDrawingBufferSurfaceClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteDrawingBufferSurfaceClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteDrawingBufferSurfaceClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteDrawingBufferSurfaceClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteDrawingBufferSurfaceClass = _GraniteDrawingBufferSurfaceClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteDrawingBufferSurfacePrivate {
    _unused: [u8; 0],
}
pub type GraniteDrawingBufferSurfacePrivate =
    _GraniteDrawingBufferSurfacePrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteDrawingUtilities {
    pub parent_instance: GObject,
    pub priv_: *mut GraniteDrawingUtilitiesPrivate,
}
#[test]
fn bindgen_test_layout__GraniteDrawingUtilities() {
    assert_eq!(::std::mem::size_of::<_GraniteDrawingUtilities>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( _GraniteDrawingUtilities ) ));
    assert_eq! (::std::mem::align_of::<_GraniteDrawingUtilities>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteDrawingUtilities ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteDrawingUtilities ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteDrawingUtilities ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteDrawingUtilities ) ) . priv_ as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteDrawingUtilities ) , "::" , stringify ! ( priv_ ) ));
}
impl Clone for _GraniteDrawingUtilities {
    fn clone(&self) -> Self { *self }
}
pub type GraniteDrawingUtilities = _GraniteDrawingUtilities;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteDrawingUtilitiesClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GraniteDrawingUtilitiesClass() {
    assert_eq!(::std::mem::size_of::<_GraniteDrawingUtilitiesClass>() ,
               136usize , concat ! (
               "Size of: " , stringify ! ( _GraniteDrawingUtilitiesClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteDrawingUtilitiesClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _GraniteDrawingUtilitiesClass
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteDrawingUtilitiesClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteDrawingUtilitiesClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteDrawingUtilitiesClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteDrawingUtilitiesClass = _GraniteDrawingUtilitiesClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteDrawingUtilitiesPrivate {
    _unused: [u8; 0],
}
pub type GraniteDrawingUtilitiesPrivate = _GraniteDrawingUtilitiesPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteGtkPatchAboutDialogPrivate {
    _unused: [u8; 0],
}
pub type GraniteGtkPatchAboutDialogPrivate =
    _GraniteGtkPatchAboutDialogPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteServicesSettings {
    pub parent_instance: GObject,
    pub priv_: *mut GraniteServicesSettingsPrivate,
}
#[test]
fn bindgen_test_layout__GraniteServicesSettings() {
    assert_eq!(::std::mem::size_of::<_GraniteServicesSettings>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( _GraniteServicesSettings ) ));
    assert_eq! (::std::mem::align_of::<_GraniteServicesSettings>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteServicesSettings ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesSettings ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesSettings ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesSettings ) ) . priv_ as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesSettings ) , "::" , stringify ! ( priv_ ) ));
}
impl Clone for _GraniteServicesSettings {
    fn clone(&self) -> Self { *self }
}
pub type GraniteServicesSettings = _GraniteServicesSettings;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteServicesSettingsClass {
    pub parent_class: GObjectClass,
    pub verify: ::std::option::Option<unsafe extern "C" fn(self_:
                                                               *mut GraniteServicesSettings,
                                                           key:
                                                               *const gchar)>,
}
#[test]
fn bindgen_test_layout__GraniteServicesSettingsClass() {
    assert_eq!(::std::mem::size_of::<_GraniteServicesSettingsClass>() ,
               144usize , concat ! (
               "Size of: " , stringify ! ( _GraniteServicesSettingsClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteServicesSettingsClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _GraniteServicesSettingsClass
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesSettingsClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesSettingsClass ) , "::" , stringify ! (
                parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesSettingsClass ) ) .
                verify as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesSettingsClass ) , "::" , stringify ! ( verify
                ) ));
}
impl Clone for _GraniteServicesSettingsClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteServicesSettingsClass = _GraniteServicesSettingsClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteServicesSettingsPrivate {
    _unused: [u8; 0],
}
pub type GraniteServicesSettingsPrivate = _GraniteServicesSettingsPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteServicesLogger {
    pub parent_instance: GObject,
    pub priv_: *mut GraniteServicesLoggerPrivate,
}
#[test]
fn bindgen_test_layout__GraniteServicesLogger() {
    assert_eq!(::std::mem::size_of::<_GraniteServicesLogger>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( _GraniteServicesLogger )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteServicesLogger>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteServicesLogger ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesLogger ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteServicesLogger
                ) , "::" , stringify ! ( parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesLogger ) ) . priv_ as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteServicesLogger
                ) , "::" , stringify ! ( priv_ ) ));
}
impl Clone for _GraniteServicesLogger {
    fn clone(&self) -> Self { *self }
}
pub type GraniteServicesLogger = _GraniteServicesLogger;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteServicesLoggerClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GraniteServicesLoggerClass() {
    assert_eq!(::std::mem::size_of::<_GraniteServicesLoggerClass>() , 136usize
               , concat ! (
               "Size of: " , stringify ! ( _GraniteServicesLoggerClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteServicesLoggerClass>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _GraniteServicesLoggerClass )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesLoggerClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesLoggerClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteServicesLoggerClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteServicesLoggerClass = _GraniteServicesLoggerClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteServicesLoggerPrivate {
    _unused: [u8; 0],
}
pub type GraniteServicesLoggerPrivate = _GraniteServicesLoggerPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteServicesPaths {
    pub parent_instance: GObject,
    pub priv_: *mut GraniteServicesPathsPrivate,
}
#[test]
fn bindgen_test_layout__GraniteServicesPaths() {
    assert_eq!(::std::mem::size_of::<_GraniteServicesPaths>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( _GraniteServicesPaths )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteServicesPaths>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteServicesPaths ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesPaths ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteServicesPaths )
                , "::" , stringify ! ( parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesPaths ) ) . priv_ as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteServicesPaths )
                , "::" , stringify ! ( priv_ ) ));
}
impl Clone for _GraniteServicesPaths {
    fn clone(&self) -> Self { *self }
}
pub type GraniteServicesPaths = _GraniteServicesPaths;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteServicesPathsClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GraniteServicesPathsClass() {
    assert_eq!(::std::mem::size_of::<_GraniteServicesPathsClass>() , 136usize
               , concat ! (
               "Size of: " , stringify ! ( _GraniteServicesPathsClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteServicesPathsClass>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _GraniteServicesPathsClass )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesPathsClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesPathsClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteServicesPathsClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteServicesPathsClass = _GraniteServicesPathsClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteServicesPathsPrivate {
    _unused: [u8; 0],
}
pub type GraniteServicesPathsPrivate = _GraniteServicesPathsPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteServicesSystem {
    pub parent_instance: GObject,
    pub priv_: *mut GraniteServicesSystemPrivate,
}
#[test]
fn bindgen_test_layout__GraniteServicesSystem() {
    assert_eq!(::std::mem::size_of::<_GraniteServicesSystem>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( _GraniteServicesSystem )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteServicesSystem>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteServicesSystem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesSystem ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteServicesSystem
                ) , "::" , stringify ! ( parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesSystem ) ) . priv_ as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteServicesSystem
                ) , "::" , stringify ! ( priv_ ) ));
}
impl Clone for _GraniteServicesSystem {
    fn clone(&self) -> Self { *self }
}
pub type GraniteServicesSystem = _GraniteServicesSystem;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteServicesSystemClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GraniteServicesSystemClass() {
    assert_eq!(::std::mem::size_of::<_GraniteServicesSystemClass>() , 136usize
               , concat ! (
               "Size of: " , stringify ! ( _GraniteServicesSystemClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteServicesSystemClass>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _GraniteServicesSystemClass )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesSystemClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesSystemClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteServicesSystemClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteServicesSystemClass = _GraniteServicesSystemClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteServicesSystemPrivate {
    _unused: [u8; 0],
}
pub type GraniteServicesSystemPrivate = _GraniteServicesSystemPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteServicesContractor {
    pub parent_instance: GObject,
    pub priv_: *mut GraniteServicesContractorPrivate,
    pub contract: *mut GraniteServicesContractorDBus,
}
#[test]
fn bindgen_test_layout__GraniteServicesContractor() {
    assert_eq!(::std::mem::size_of::<_GraniteServicesContractor>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( _GraniteServicesContractor ) ));
    assert_eq! (::std::mem::align_of::<_GraniteServicesContractor>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _GraniteServicesContractor )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesContractor ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesContractor ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesContractor ) ) . priv_ as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesContractor ) , "::" , stringify ! ( priv_ )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesContractor ) ) . contract
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesContractor ) , "::" , stringify ! ( contract )
                ));
}
impl Clone for _GraniteServicesContractor {
    fn clone(&self) -> Self { *self }
}
pub type GraniteServicesContractor = _GraniteServicesContractor;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteServicesContractorClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GraniteServicesContractorClass() {
    assert_eq!(::std::mem::size_of::<_GraniteServicesContractorClass>() ,
               136usize , concat ! (
               "Size of: " , stringify ! ( _GraniteServicesContractorClass )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteServicesContractorClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteServicesContractorClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesContractorClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesContractorClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteServicesContractorClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteServicesContractorClass = _GraniteServicesContractorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteServicesContractorPrivate {
    _unused: [u8; 0],
}
pub type GraniteServicesContractorPrivate = _GraniteServicesContractorPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteServicesContractorDBus {
    _unused: [u8; 0],
}
pub type GraniteServicesContractorDBus = _GraniteServicesContractorDBus;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteServicesContractorDBusIface {
    pub parent_iface: GTypeInterface,
    pub GetServicesByLocation: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                              *mut GraniteServicesContractorDBus,
                                                                          strlocation:
                                                                              *const gchar,
                                                                          file_mime:
                                                                              *const gchar,
                                                                          result_length1:
                                                                              *mut ::std::os::raw::c_int,
                                                                          error:
                                                                              *mut *mut GError)
                                                         ->
                                                             *mut *mut GHashTable>,
    pub GetServicesByLocationsList: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                                   *mut GraniteServicesContractorDBus,
                                                                               locations:
                                                                                   *mut *mut GHashTable,
                                                                               locations_length1:
                                                                                   ::std::os::raw::c_int,
                                                                               result_length1:
                                                                                   *mut ::std::os::raw::c_int,
                                                                               error:
                                                                                   *mut *mut GError)
                                                              ->
                                                                  *mut *mut GHashTable>,
}
#[test]
fn bindgen_test_layout__GraniteServicesContractorDBusIface() {
    assert_eq!(::std::mem::size_of::<_GraniteServicesContractorDBusIface>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( _GraniteServicesContractorDBusIface
               ) ));
    assert_eq! (::std::mem::align_of::<_GraniteServicesContractorDBusIface>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteServicesContractorDBusIface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesContractorDBusIface ) ) .
                parent_iface as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesContractorDBusIface ) , "::" , stringify ! (
                parent_iface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesContractorDBusIface ) ) .
                GetServicesByLocation as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesContractorDBusIface ) , "::" , stringify ! (
                GetServicesByLocation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesContractorDBusIface ) ) .
                GetServicesByLocationsList as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesContractorDBusIface ) , "::" , stringify ! (
                GetServicesByLocationsList ) ));
}
impl Clone for _GraniteServicesContractorDBusIface {
    fn clone(&self) -> Self { *self }
}
pub type GraniteServicesContractorDBusIface =
    _GraniteServicesContractorDBusIface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteServicesContract {
    _unused: [u8; 0],
}
pub type GraniteServicesContract = _GraniteServicesContract;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteServicesContractIface {
    pub parent_iface: GTypeInterface,
    pub get_display_name: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                         *mut GraniteServicesContract)
                                                    -> *mut gchar>,
    pub get_description: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                        *mut GraniteServicesContract)
                                                   -> *mut gchar>,
    pub get_icon: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                 *mut GraniteServicesContract)
                                            -> *mut GIcon>,
    pub execute_with_file: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                          *mut GraniteServicesContract,
                                                                      file:
                                                                          *mut GFile,
                                                                      error:
                                                                          *mut *mut GError)>,
    pub execute_with_files: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                           *mut GraniteServicesContract,
                                                                       files:
                                                                           *mut *mut GFile,
                                                                       files_length1:
                                                                           ::std::os::raw::c_int,
                                                                       error:
                                                                           *mut *mut GError)>,
}
#[test]
fn bindgen_test_layout__GraniteServicesContractIface() {
    assert_eq!(::std::mem::size_of::<_GraniteServicesContractIface>() ,
               56usize , concat ! (
               "Size of: " , stringify ! ( _GraniteServicesContractIface ) ));
    assert_eq! (::std::mem::align_of::<_GraniteServicesContractIface>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _GraniteServicesContractIface
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesContractIface ) ) .
                parent_iface as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesContractIface ) , "::" , stringify ! (
                parent_iface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesContractIface ) ) .
                get_display_name as * const _ as usize } , 16usize , concat !
                (
                "Alignment of field: " , stringify ! (
                _GraniteServicesContractIface ) , "::" , stringify ! (
                get_display_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesContractIface ) ) .
                get_description as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesContractIface ) , "::" , stringify ! (
                get_description ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesContractIface ) ) .
                get_icon as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesContractIface ) , "::" , stringify ! (
                get_icon ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesContractIface ) ) .
                execute_with_file as * const _ as usize } , 40usize , concat !
                (
                "Alignment of field: " , stringify ! (
                _GraniteServicesContractIface ) , "::" , stringify ! (
                execute_with_file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesContractIface ) ) .
                execute_with_files as * const _ as usize } , 48usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesContractIface ) , "::" , stringify ! (
                execute_with_files ) ));
}
impl Clone for _GraniteServicesContractIface {
    fn clone(&self) -> Self { *self }
}
pub type GraniteServicesContractIface = _GraniteServicesContractIface;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteServicesContractorProxy {
    pub parent_instance: GObject,
    pub priv_: *mut GraniteServicesContractorProxyPrivate,
}
#[test]
fn bindgen_test_layout__GraniteServicesContractorProxy() {
    assert_eq!(::std::mem::size_of::<_GraniteServicesContractorProxy>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( _GraniteServicesContractorProxy )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteServicesContractorProxy>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteServicesContractorProxy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesContractorProxy ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesContractorProxy ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesContractorProxy ) ) .
                priv_ as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesContractorProxy ) , "::" , stringify ! ( priv_
                ) ));
}
impl Clone for _GraniteServicesContractorProxy {
    fn clone(&self) -> Self { *self }
}
pub type GraniteServicesContractorProxy = _GraniteServicesContractorProxy;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteServicesContractorProxyClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GraniteServicesContractorProxyClass() {
    assert_eq!(::std::mem::size_of::<_GraniteServicesContractorProxyClass>() ,
               136usize , concat ! (
               "Size of: " , stringify ! (
               _GraniteServicesContractorProxyClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteServicesContractorProxyClass>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteServicesContractorProxyClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesContractorProxyClass ) )
                . parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesContractorProxyClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteServicesContractorProxyClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteServicesContractorProxyClass =
    _GraniteServicesContractorProxyClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteServicesContractorProxyPrivate {
    _unused: [u8; 0],
}
pub type GraniteServicesContractorProxyPrivate =
    _GraniteServicesContractorProxyPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteServicesIconFactory {
    pub parent_instance: GObject,
    pub priv_: *mut GraniteServicesIconFactoryPrivate,
}
#[test]
fn bindgen_test_layout__GraniteServicesIconFactory() {
    assert_eq!(::std::mem::size_of::<_GraniteServicesIconFactory>() , 32usize
               , concat ! (
               "Size of: " , stringify ! ( _GraniteServicesIconFactory ) ));
    assert_eq! (::std::mem::align_of::<_GraniteServicesIconFactory>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _GraniteServicesIconFactory )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesIconFactory ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesIconFactory ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesIconFactory ) ) . priv_
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesIconFactory ) , "::" , stringify ! ( priv_ )
                ));
}
impl Clone for _GraniteServicesIconFactory {
    fn clone(&self) -> Self { *self }
}
pub type GraniteServicesIconFactory = _GraniteServicesIconFactory;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteServicesIconFactoryClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GraniteServicesIconFactoryClass() {
    assert_eq!(::std::mem::size_of::<_GraniteServicesIconFactoryClass>() ,
               136usize , concat ! (
               "Size of: " , stringify ! ( _GraniteServicesIconFactoryClass )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteServicesIconFactoryClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteServicesIconFactoryClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesIconFactoryClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesIconFactoryClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteServicesIconFactoryClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteServicesIconFactoryClass = _GraniteServicesIconFactoryClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteServicesIconFactoryPrivate {
    _unused: [u8; 0],
}
pub type GraniteServicesIconFactoryPrivate =
    _GraniteServicesIconFactoryPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteServicesSimpleCommand {
    pub parent_instance: GObject,
    pub priv_: *mut GraniteServicesSimpleCommandPrivate,
    pub standard_output_str: *mut gchar,
    pub error_output_str: *mut gchar,
    pub output_str: *mut gchar,
}
#[test]
fn bindgen_test_layout__GraniteServicesSimpleCommand() {
    assert_eq!(::std::mem::size_of::<_GraniteServicesSimpleCommand>() ,
               56usize , concat ! (
               "Size of: " , stringify ! ( _GraniteServicesSimpleCommand ) ));
    assert_eq! (::std::mem::align_of::<_GraniteServicesSimpleCommand>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _GraniteServicesSimpleCommand
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesSimpleCommand ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesSimpleCommand ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesSimpleCommand ) ) . priv_
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesSimpleCommand ) , "::" , stringify ! ( priv_ )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesSimpleCommand ) ) .
                standard_output_str as * const _ as usize } , 32usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesSimpleCommand ) , "::" , stringify ! (
                standard_output_str ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesSimpleCommand ) ) .
                error_output_str as * const _ as usize } , 40usize , concat !
                (
                "Alignment of field: " , stringify ! (
                _GraniteServicesSimpleCommand ) , "::" , stringify ! (
                error_output_str ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesSimpleCommand ) ) .
                output_str as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesSimpleCommand ) , "::" , stringify ! (
                output_str ) ));
}
impl Clone for _GraniteServicesSimpleCommand {
    fn clone(&self) -> Self { *self }
}
pub type GraniteServicesSimpleCommand = _GraniteServicesSimpleCommand;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteServicesSimpleCommandClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GraniteServicesSimpleCommandClass() {
    assert_eq!(::std::mem::size_of::<_GraniteServicesSimpleCommandClass>() ,
               136usize , concat ! (
               "Size of: " , stringify ! ( _GraniteServicesSimpleCommandClass
               ) ));
    assert_eq! (::std::mem::align_of::<_GraniteServicesSimpleCommandClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteServicesSimpleCommandClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteServicesSimpleCommandClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteServicesSimpleCommandClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteServicesSimpleCommandClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteServicesSimpleCommandClass =
    _GraniteServicesSimpleCommandClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteServicesSimpleCommandPrivate {
    _unused: [u8; 0],
}
pub type GraniteServicesSimpleCommandPrivate =
    _GraniteServicesSimpleCommandPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsAlertView {
    pub parent_instance: GtkGrid,
    pub priv_: *mut GraniteWidgetsAlertViewPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsAlertView() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsAlertView>() , 56usize ,
               concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsAlertView ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsAlertView>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsAlertView ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsAlertView ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsAlertView ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsAlertView ) ) . priv_ as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsAlertView ) , "::" , stringify ! ( priv_ ) ));
}
impl Clone for _GraniteWidgetsAlertView {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsAlertView = _GraniteWidgetsAlertView;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsAlertViewClass {
    pub parent_class: GtkGridClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsAlertViewClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsAlertViewClass>() ,
               1040usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsAlertViewClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsAlertViewClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsAlertViewClass
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsAlertViewClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsAlertViewClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsAlertViewClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsAlertViewClass = _GraniteWidgetsAlertViewClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsAlertViewPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsAlertViewPrivate = _GraniteWidgetsAlertViewPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsAvatar {
    pub parent_instance: GtkEventBox,
    pub priv_: *mut GraniteWidgetsAvatarPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsAvatar() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsAvatar>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( _GraniteWidgetsAvatar )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsAvatar>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsAvatar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsAvatar ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsAvatar )
                , "::" , stringify ! ( parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsAvatar ) ) . priv_ as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsAvatar )
                , "::" , stringify ! ( priv_ ) ));
}
impl Clone for _GraniteWidgetsAvatar {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsAvatar = _GraniteWidgetsAvatar;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsAvatarClass {
    pub parent_class: GtkEventBoxClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsAvatarClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsAvatarClass>() , 1040usize
               , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsAvatarClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsAvatarClass>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsAvatarClass )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsAvatarClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsAvatarClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsAvatarClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsAvatarClass = _GraniteWidgetsAvatarClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsAvatarPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsAvatarPrivate = _GraniteWidgetsAvatarPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsWrapLabel {
    pub parent_instance: GtkLabel,
    pub priv_: *mut GraniteWidgetsWrapLabelPrivate,
    pub m_wrap_width: gint,
    pub m_wrap_height: gint,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsWrapLabel() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsWrapLabel>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsWrapLabel ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsWrapLabel>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsWrapLabel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsWrapLabel ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsWrapLabel ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsWrapLabel ) ) . priv_ as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsWrapLabel ) , "::" , stringify ! ( priv_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsWrapLabel ) ) .
                m_wrap_width as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsWrapLabel ) , "::" , stringify ! ( m_wrap_width
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsWrapLabel ) ) .
                m_wrap_height as * const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsWrapLabel ) , "::" , stringify ! (
                m_wrap_height ) ));
}
impl Clone for _GraniteWidgetsWrapLabel {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsWrapLabel = _GraniteWidgetsWrapLabel;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsWrapLabelClass {
    pub parent_class: GtkLabelClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsWrapLabelClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsWrapLabelClass>() ,
               952usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsWrapLabelClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsWrapLabelClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsWrapLabelClass
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsWrapLabelClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsWrapLabelClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsWrapLabelClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsWrapLabelClass = _GraniteWidgetsWrapLabelClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsWrapLabelPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsWrapLabelPrivate = _GraniteWidgetsWrapLabelPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsAboutDialogPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsAboutDialogPrivate = _GraniteWidgetsAboutDialogPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsModeButton {
    pub parent_instance: GtkBox,
    pub priv_: *mut GraniteWidgetsModeButtonPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsModeButton() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsModeButton>() , 56usize ,
               concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsModeButton ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsModeButton>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsModeButton )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsModeButton ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsModeButton ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsModeButton ) ) . priv_ as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsModeButton ) , "::" , stringify ! ( priv_ ) ));
}
impl Clone for _GraniteWidgetsModeButton {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsModeButton = _GraniteWidgetsModeButton;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsModeButtonClass {
    pub parent_class: GtkBoxClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsModeButtonClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsModeButtonClass>() ,
               1008usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsModeButtonClass )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsModeButtonClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsModeButtonClass
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsModeButtonClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsModeButtonClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsModeButtonClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsModeButtonClass = _GraniteWidgetsModeButtonClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsModeButtonPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsModeButtonPrivate = _GraniteWidgetsModeButtonPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsDatePicker {
    pub parent_instance: GtkEntry,
    pub priv_: *mut GraniteWidgetsDatePickerPrivate,
    pub dropdown: *mut GtkEventBox,
    pub calendar: *mut GtkCalendar,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsDatePicker() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsDatePicker>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsDatePicker ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsDatePicker>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsDatePicker )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsDatePicker ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsDatePicker ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsDatePicker ) ) . priv_ as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsDatePicker ) , "::" , stringify ! ( priv_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsDatePicker ) ) . dropdown
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsDatePicker ) , "::" , stringify ! ( dropdown )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsDatePicker ) ) . calendar
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsDatePicker ) , "::" , stringify ! ( calendar )
                ));
}
impl Clone for _GraniteWidgetsDatePicker {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsDatePicker = _GraniteWidgetsDatePicker;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsDatePickerClass {
    pub parent_class: GtkEntryClass,
    pub position_dropdown: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                          *mut GraniteWidgetsDatePicker,
                                                                      rect:
                                                                          *mut GdkRectangle)>,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsDatePickerClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsDatePickerClass>() ,
               984usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsDatePickerClass )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsDatePickerClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsDatePickerClass
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsDatePickerClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsDatePickerClass ) , "::" , stringify ! (
                parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsDatePickerClass ) ) .
                position_dropdown as * const _ as usize } , 976usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsDatePickerClass ) , "::" , stringify ! (
                position_dropdown ) ));
}
impl Clone for _GraniteWidgetsDatePickerClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsDatePickerClass = _GraniteWidgetsDatePickerClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsDatePickerPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsDatePickerPrivate = _GraniteWidgetsDatePickerPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsHintedEntry {
    pub parent_instance: GtkEntry,
    pub priv_: *mut GraniteWidgetsHintedEntryPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsHintedEntry() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsHintedEntry>() , 48usize ,
               concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsHintedEntry ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsHintedEntry>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsHintedEntry )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsHintedEntry ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsHintedEntry ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsHintedEntry ) ) . priv_ as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsHintedEntry ) , "::" , stringify ! ( priv_ )
                ));
}
impl Clone for _GraniteWidgetsHintedEntry {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsHintedEntry = _GraniteWidgetsHintedEntry;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsHintedEntryClass {
    pub parent_class: GtkEntryClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsHintedEntryClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsHintedEntryClass>() ,
               976usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsHintedEntryClass )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsHintedEntryClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsHintedEntryClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsHintedEntryClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsHintedEntryClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsHintedEntryClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsHintedEntryClass = _GraniteWidgetsHintedEntryClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsHintedEntryPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsHintedEntryPrivate = _GraniteWidgetsHintedEntryPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsSearchBar {
    pub parent_instance: GraniteWidgetsHintedEntry,
    pub priv_: *mut GraniteWidgetsSearchBarPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsSearchBar() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsSearchBar>() , 56usize ,
               concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsSearchBar ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsSearchBar>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsSearchBar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsSearchBar ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSearchBar ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsSearchBar ) ) . priv_ as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSearchBar ) , "::" , stringify ! ( priv_ ) ));
}
impl Clone for _GraniteWidgetsSearchBar {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsSearchBar = _GraniteWidgetsSearchBar;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsSearchBarClass {
    pub parent_class: GraniteWidgetsHintedEntryClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsSearchBarClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsSearchBarClass>() ,
               976usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsSearchBarClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsSearchBarClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsSearchBarClass
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsSearchBarClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSearchBarClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsSearchBarClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsSearchBarClass = _GraniteWidgetsSearchBarClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsSearchBarPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsSearchBarPrivate = _GraniteWidgetsSearchBarPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsTimePicker {
    pub parent_instance: GtkEntry,
    pub priv_: *mut GraniteWidgetsTimePickerPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsTimePicker() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsTimePicker>() , 48usize ,
               concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsTimePicker ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsTimePicker>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsTimePicker )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsTimePicker ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsTimePicker ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsTimePicker ) ) . priv_ as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsTimePicker ) , "::" , stringify ! ( priv_ ) ));
}
impl Clone for _GraniteWidgetsTimePicker {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsTimePicker = _GraniteWidgetsTimePicker;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsTimePickerClass {
    pub parent_class: GtkEntryClass,
    pub position_dropdown: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                          *mut GraniteWidgetsTimePicker,
                                                                      x:
                                                                          *mut gint,
                                                                      y:
                                                                          *mut gint)>,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsTimePickerClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsTimePickerClass>() ,
               984usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsTimePickerClass )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsTimePickerClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsTimePickerClass
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsTimePickerClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsTimePickerClass ) , "::" , stringify ! (
                parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsTimePickerClass ) ) .
                position_dropdown as * const _ as usize } , 976usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsTimePickerClass ) , "::" , stringify ! (
                position_dropdown ) ));
}
impl Clone for _GraniteWidgetsTimePickerClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsTimePickerClass = _GraniteWidgetsTimePickerClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsTimePickerPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsTimePickerPrivate = _GraniteWidgetsTimePickerPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsCollapsiblePaned {
    pub parent_instance: GtkPaned,
    pub priv_: *mut GraniteWidgetsCollapsiblePanedPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsCollapsiblePaned() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsCollapsiblePaned>() ,
               56usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsCollapsiblePaned )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsCollapsiblePaned>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsCollapsiblePaned ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsCollapsiblePaned ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsCollapsiblePaned ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsCollapsiblePaned ) ) .
                priv_ as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsCollapsiblePaned ) , "::" , stringify ! ( priv_
                ) ));
}
impl Clone for _GraniteWidgetsCollapsiblePaned {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsCollapsiblePaned = _GraniteWidgetsCollapsiblePaned;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsCollapsiblePanedClass {
    pub parent_class: GtkPanedClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsCollapsiblePanedClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsCollapsiblePanedClass>() ,
               1056usize , concat ! (
               "Size of: " , stringify ! (
               _GraniteWidgetsCollapsiblePanedClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsCollapsiblePanedClass>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsCollapsiblePanedClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsCollapsiblePanedClass ) )
                . parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsCollapsiblePanedClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsCollapsiblePanedClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsCollapsiblePanedClass =
    _GraniteWidgetsCollapsiblePanedClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsCollapsiblePanedPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsCollapsiblePanedPrivate =
    _GraniteWidgetsCollapsiblePanedPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsHCollapsablePaned {
    pub parent_instance: GraniteWidgetsCollapsiblePaned,
    pub priv_: *mut GraniteWidgetsHCollapsablePanedPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsHCollapsablePaned() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsHCollapsablePaned>() ,
               64usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsHCollapsablePaned )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsHCollapsablePaned>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsHCollapsablePaned ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsHCollapsablePaned ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsHCollapsablePaned ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsHCollapsablePaned ) ) .
                priv_ as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsHCollapsablePaned ) , "::" , stringify ! (
                priv_ ) ));
}
impl Clone for _GraniteWidgetsHCollapsablePaned {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsHCollapsablePaned = _GraniteWidgetsHCollapsablePaned;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsHCollapsablePanedClass {
    pub parent_class: GraniteWidgetsCollapsiblePanedClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsHCollapsablePanedClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsHCollapsablePanedClass>()
               , 1056usize , concat ! (
               "Size of: " , stringify ! (
               _GraniteWidgetsHCollapsablePanedClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsHCollapsablePanedClass>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsHCollapsablePanedClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsHCollapsablePanedClass ) )
                . parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsHCollapsablePanedClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsHCollapsablePanedClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsHCollapsablePanedClass =
    _GraniteWidgetsHCollapsablePanedClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsHCollapsablePanedPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsHCollapsablePanedPrivate =
    _GraniteWidgetsHCollapsablePanedPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsVCollapsablePaned {
    pub parent_instance: GraniteWidgetsCollapsiblePaned,
    pub priv_: *mut GraniteWidgetsVCollapsablePanedPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsVCollapsablePaned() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsVCollapsablePaned>() ,
               64usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsVCollapsablePaned )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsVCollapsablePaned>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsVCollapsablePaned ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsVCollapsablePaned ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsVCollapsablePaned ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsVCollapsablePaned ) ) .
                priv_ as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsVCollapsablePaned ) , "::" , stringify ! (
                priv_ ) ));
}
impl Clone for _GraniteWidgetsVCollapsablePaned {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsVCollapsablePaned = _GraniteWidgetsVCollapsablePaned;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsVCollapsablePanedClass {
    pub parent_class: GraniteWidgetsCollapsiblePanedClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsVCollapsablePanedClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsVCollapsablePanedClass>()
               , 1056usize , concat ! (
               "Size of: " , stringify ! (
               _GraniteWidgetsVCollapsablePanedClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsVCollapsablePanedClass>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsVCollapsablePanedClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsVCollapsablePanedClass ) )
                . parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsVCollapsablePanedClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsVCollapsablePanedClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsVCollapsablePanedClass =
    _GraniteWidgetsVCollapsablePanedClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsVCollapsablePanedPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsVCollapsablePanedPrivate =
    _GraniteWidgetsVCollapsablePanedPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsStaticNotebook {
    pub parent_instance: GtkBox,
    pub priv_: *mut GraniteWidgetsStaticNotebookPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsStaticNotebook() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsStaticNotebook>() ,
               56usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsStaticNotebook ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsStaticNotebook>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsStaticNotebook
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsStaticNotebook ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsStaticNotebook ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsStaticNotebook ) ) . priv_
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsStaticNotebook ) , "::" , stringify ! ( priv_ )
                ));
}
impl Clone for _GraniteWidgetsStaticNotebook {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsStaticNotebook = _GraniteWidgetsStaticNotebook;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsStaticNotebookClass {
    pub parent_class: GtkBoxClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsStaticNotebookClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsStaticNotebookClass>() ,
               1008usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsStaticNotebookClass
               ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsStaticNotebookClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsStaticNotebookClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsStaticNotebookClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsStaticNotebookClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsStaticNotebookClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsStaticNotebookClass =
    _GraniteWidgetsStaticNotebookClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsStaticNotebookPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsStaticNotebookPrivate =
    _GraniteWidgetsStaticNotebookPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsTab {
    pub parent_instance: GtkEventBox,
    pub priv_: *mut GraniteWidgetsTabPrivate,
    pub dropped_callback: GraniteWidgetsDroppedDelegate,
    pub dropped_callback_target: gpointer,
    pub dropped_callback_target_destroy_notify: GDestroyNotify,
    pub page_container: *mut GraniteWidgetsTabPageContainer,
    pub _icon: *mut GtkImage,
    pub new_window_m: *mut GtkMenuItem,
    pub duplicate_m: *mut GtkMenuItem,
    pub pin_m: *mut GtkMenuItem,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsTab() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsTab>() , 128usize , concat
               ! ( "Size of: " , stringify ! ( _GraniteWidgetsTab ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsTab>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _GraniteWidgetsTab ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsTab ) ) . parent_instance
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsTab ) ,
                "::" , stringify ! ( parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsTab ) ) . priv_ as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsTab ) ,
                "::" , stringify ! ( priv_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsTab ) ) . dropped_callback
                as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsTab ) ,
                "::" , stringify ! ( dropped_callback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsTab ) ) .
                dropped_callback_target as * const _ as usize } , 72usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsTab ) ,
                "::" , stringify ! ( dropped_callback_target ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsTab ) ) .
                dropped_callback_target_destroy_notify as * const _ as usize }
                , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsTab ) ,
                "::" , stringify ! ( dropped_callback_target_destroy_notify )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsTab ) ) . page_container
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsTab ) ,
                "::" , stringify ! ( page_container ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsTab ) ) . _icon as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsTab ) ,
                "::" , stringify ! ( _icon ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsTab ) ) . new_window_m as
                * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsTab ) ,
                "::" , stringify ! ( new_window_m ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsTab ) ) . duplicate_m as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsTab ) ,
                "::" , stringify ! ( duplicate_m ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsTab ) ) . pin_m as * const
                _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsTab ) ,
                "::" , stringify ! ( pin_m ) ));
}
impl Clone for _GraniteWidgetsTab {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsTab = _GraniteWidgetsTab;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsTabClass {
    pub parent_class: GtkEventBoxClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsTabClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsTabClass>() , 1040usize ,
               concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsTabClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsTabClass>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsTabClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsTabClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsTabClass
                ) , "::" , stringify ! ( parent_class ) ));
}
impl Clone for _GraniteWidgetsTabClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsTabClass = _GraniteWidgetsTabClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsTabPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsTabPrivate = _GraniteWidgetsTabPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsTabPageContainer {
    _unused: [u8; 0],
}
pub type GraniteWidgetsTabPageContainer = _GraniteWidgetsTabPageContainer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsTabPageContainerClass {
    _unused: [u8; 0],
}
pub type GraniteWidgetsTabPageContainerClass =
    _GraniteWidgetsTabPageContainerClass;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsDynamicNotebook {
    pub parent_instance: GtkEventBox,
    pub priv_: *mut GraniteWidgetsDynamicNotebookPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsDynamicNotebook() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsDynamicNotebook>() ,
               64usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsDynamicNotebook )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsDynamicNotebook>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsDynamicNotebook
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsDynamicNotebook ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsDynamicNotebook ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsDynamicNotebook ) ) .
                priv_ as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsDynamicNotebook ) , "::" , stringify ! ( priv_
                ) ));
}
impl Clone for _GraniteWidgetsDynamicNotebook {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsDynamicNotebook = _GraniteWidgetsDynamicNotebook;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsDynamicNotebookClass {
    pub parent_class: GtkEventBoxClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsDynamicNotebookClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsDynamicNotebookClass>() ,
               1040usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsDynamicNotebookClass
               ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsDynamicNotebookClass>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsDynamicNotebookClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsDynamicNotebookClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsDynamicNotebookClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsDynamicNotebookClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsDynamicNotebookClass =
    _GraniteWidgetsDynamicNotebookClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsDynamicNotebookPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsDynamicNotebookPrivate =
    _GraniteWidgetsDynamicNotebookPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsCompositedWindow {
    pub parent_instance: GtkWindow,
    pub priv_: *mut GraniteWidgetsCompositedWindowPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsCompositedWindow() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsCompositedWindow>() ,
               64usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsCompositedWindow )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsCompositedWindow>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsCompositedWindow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsCompositedWindow ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsCompositedWindow ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsCompositedWindow ) ) .
                priv_ as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsCompositedWindow ) , "::" , stringify ! ( priv_
                ) ));
}
impl Clone for _GraniteWidgetsCompositedWindow {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsCompositedWindow = _GraniteWidgetsCompositedWindow;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsCompositedWindowClass {
    pub parent_class: GtkWindowClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsCompositedWindowClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsCompositedWindowClass>() ,
               1072usize , concat ! (
               "Size of: " , stringify ! (
               _GraniteWidgetsCompositedWindowClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsCompositedWindowClass>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsCompositedWindowClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsCompositedWindowClass ) )
                . parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsCompositedWindowClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsCompositedWindowClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsCompositedWindowClass =
    _GraniteWidgetsCompositedWindowClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsCompositedWindowPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsCompositedWindowPrivate =
    _GraniteWidgetsCompositedWindowPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsToolButtonWithMenuPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsToolButtonWithMenuPrivate =
    _GraniteWidgetsToolButtonWithMenuPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsAppMenuPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsAppMenuPrivate = _GraniteWidgetsAppMenuPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsWelcome {
    pub parent_instance: GtkEventBox,
    pub priv_: *mut GraniteWidgetsWelcomePrivate,
    pub children: *mut GList,
    pub options: *mut GtkBox,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsWelcome() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsWelcome>() , 80usize ,
               concat ! ( "Size of: " , stringify ! ( _GraniteWidgetsWelcome )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsWelcome>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsWelcome ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsWelcome ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsWelcome
                ) , "::" , stringify ! ( parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsWelcome ) ) . priv_ as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsWelcome
                ) , "::" , stringify ! ( priv_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsWelcome ) ) . children as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsWelcome
                ) , "::" , stringify ! ( children ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsWelcome ) ) . options as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsWelcome
                ) , "::" , stringify ! ( options ) ));
}
impl Clone for _GraniteWidgetsWelcome {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsWelcome = _GraniteWidgetsWelcome;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsWelcomeClass {
    pub parent_class: GtkEventBoxClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsWelcomeClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsWelcomeClass>() ,
               1040usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsWelcomeClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsWelcomeClass>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsWelcomeClass )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsWelcomeClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsWelcomeClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsWelcomeClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsWelcomeClass = _GraniteWidgetsWelcomeClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsWelcomePrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsWelcomePrivate = _GraniteWidgetsWelcomePrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsWelcomeButton {
    pub parent_instance: GtkButton,
    pub priv_: *mut GraniteWidgetsWelcomeButtonPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsWelcomeButton() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsWelcomeButton>() , 64usize
               , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsWelcomeButton ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsWelcomeButton>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsWelcomeButton )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsWelcomeButton ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsWelcomeButton ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsWelcomeButton ) ) . priv_
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsWelcomeButton ) , "::" , stringify ! ( priv_ )
                ));
}
impl Clone for _GraniteWidgetsWelcomeButton {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsWelcomeButton = _GraniteWidgetsWelcomeButton;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsWelcomeButtonClass {
    pub parent_class: GtkButtonClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsWelcomeButtonClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsWelcomeButtonClass>() ,
               1088usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsWelcomeButtonClass )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsWelcomeButtonClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsWelcomeButtonClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsWelcomeButtonClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsWelcomeButtonClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsWelcomeButtonClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsWelcomeButtonClass = _GraniteWidgetsWelcomeButtonClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsWelcomeButtonPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsWelcomeButtonPrivate =
    _GraniteWidgetsWelcomeButtonPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsToast {
    pub parent_instance: GtkRevealer,
    pub priv_: *mut GraniteWidgetsToastPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsToast() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsToast>() , 56usize ,
               concat ! ( "Size of: " , stringify ! ( _GraniteWidgetsToast )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsToast>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsToast ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsToast ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsToast )
                , "::" , stringify ! ( parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsToast ) ) . priv_ as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsToast )
                , "::" , stringify ! ( priv_ ) ));
}
impl Clone for _GraniteWidgetsToast {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsToast = _GraniteWidgetsToast;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsToastClass {
    pub parent_class: GtkRevealerClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsToastClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsToastClass>() , 1008usize
               , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsToastClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsToastClass>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsToastClass )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsToastClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsToastClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsToastClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsToastClass = _GraniteWidgetsToastClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsToastPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsToastPrivate = _GraniteWidgetsToastPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsPopOver {
    pub parent_instance: GtkDialog,
    pub priv_: *mut GraniteWidgetsPopOverPrivate,
    pub BORDER_RADIUS: gint,
    pub BORDER_WIDTH: gint,
    pub SHADOW_SIZE: gint,
    pub ARROW_HEIGHT: gint,
    pub ARROW_WIDTH: gint,
    pub PADDINGS: GtkBorder,
    pub arrow_up: gboolean,
    pub arrow_offset: gdouble,
    pub main_buffer: *mut GraniteDrawingBufferSurface,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsPopOver() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsPopOver>() , 120usize ,
               concat ! ( "Size of: " , stringify ! ( _GraniteWidgetsPopOver )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsPopOver>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsPopOver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsPopOver ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsPopOver
                ) , "::" , stringify ! ( parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsPopOver ) ) . priv_ as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsPopOver
                ) , "::" , stringify ! ( priv_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsPopOver ) ) .
                BORDER_RADIUS as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsPopOver
                ) , "::" , stringify ! ( BORDER_RADIUS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsPopOver ) ) . BORDER_WIDTH
                as * const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsPopOver
                ) , "::" , stringify ! ( BORDER_WIDTH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsPopOver ) ) . SHADOW_SIZE
                as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsPopOver
                ) , "::" , stringify ! ( SHADOW_SIZE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsPopOver ) ) . ARROW_HEIGHT
                as * const _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsPopOver
                ) , "::" , stringify ! ( ARROW_HEIGHT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsPopOver ) ) . ARROW_WIDTH
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsPopOver
                ) , "::" , stringify ! ( ARROW_WIDTH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsPopOver ) ) . PADDINGS as
                * const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsPopOver
                ) , "::" , stringify ! ( PADDINGS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsPopOver ) ) . arrow_up as
                * const _ as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsPopOver
                ) , "::" , stringify ! ( arrow_up ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsPopOver ) ) . arrow_offset
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsPopOver
                ) , "::" , stringify ! ( arrow_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsPopOver ) ) . main_buffer
                as * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( _GraniteWidgetsPopOver
                ) , "::" , stringify ! ( main_buffer ) ));
}
impl Clone for _GraniteWidgetsPopOver {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsPopOver = _GraniteWidgetsPopOver;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsPopOverClass {
    pub parent_class: GtkDialogClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsPopOverClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsPopOverClass>() ,
               1120usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsPopOverClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsPopOverClass>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsPopOverClass )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsPopOverClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsPopOverClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsPopOverClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsPopOverClass = _GraniteWidgetsPopOverClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsPopOverPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsPopOverPrivate = _GraniteWidgetsPopOverPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsContractorView {
    pub parent_instance: GtkTreeView,
    pub priv_: *mut GraniteWidgetsContractorViewPrivate,
    pub contractor_available: gboolean,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsContractorView() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsContractorView>() ,
               64usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsContractorView ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsContractorView>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsContractorView
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsContractorView ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsContractorView ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsContractorView ) ) . priv_
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsContractorView ) , "::" , stringify ! ( priv_ )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsContractorView ) ) .
                contractor_available as * const _ as usize } , 56usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsContractorView ) , "::" , stringify ! (
                contractor_available ) ));
}
impl Clone for _GraniteWidgetsContractorView {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsContractorView = _GraniteWidgetsContractorView;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsContractorViewClass {
    pub parent_class: GtkTreeViewClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsContractorViewClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsContractorViewClass>() ,
               1160usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsContractorViewClass
               ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsContractorViewClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsContractorViewClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsContractorViewClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsContractorViewClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsContractorViewClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsContractorViewClass =
    _GraniteWidgetsContractorViewClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsContractorViewPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsContractorViewPrivate =
    _GraniteWidgetsContractorViewPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsContractorMenu {
    pub parent_instance: GtkMenu,
    pub priv_: *mut GraniteWidgetsContractorMenuPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsContractorMenu() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsContractorMenu>() ,
               64usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsContractorMenu ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsContractorMenu>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsContractorMenu
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsContractorMenu ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsContractorMenu ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsContractorMenu ) ) . priv_
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsContractorMenu ) , "::" , stringify ! ( priv_ )
                ));
}
impl Clone for _GraniteWidgetsContractorMenu {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsContractorMenu = _GraniteWidgetsContractorMenu;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsContractorMenuClass {
    pub parent_class: GtkMenuClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsContractorMenuClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsContractorMenuClass>() ,
               1120usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsContractorMenuClass
               ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsContractorMenuClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsContractorMenuClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsContractorMenuClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsContractorMenuClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsContractorMenuClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsContractorMenuClass =
    _GraniteWidgetsContractorMenuClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsContractorMenuPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsContractorMenuPrivate =
    _GraniteWidgetsContractorMenuPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsDecoratedWindow {
    pub parent_instance: GraniteWidgetsCompositedWindow,
    pub priv_: *mut GraniteWidgetsDecoratedWindowPrivate,
    pub close_img: *mut GdkPixbuf,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsDecoratedWindow() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsDecoratedWindow>() ,
               80usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsDecoratedWindow )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsDecoratedWindow>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsDecoratedWindow
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsDecoratedWindow ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsDecoratedWindow ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsDecoratedWindow ) ) .
                priv_ as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsDecoratedWindow ) , "::" , stringify ! ( priv_
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsDecoratedWindow ) ) .
                close_img as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsDecoratedWindow ) , "::" , stringify ! (
                close_img ) ));
}
impl Clone for _GraniteWidgetsDecoratedWindow {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsDecoratedWindow = _GraniteWidgetsDecoratedWindow;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsDecoratedWindowClass {
    pub parent_class: GraniteWidgetsCompositedWindowClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsDecoratedWindowClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsDecoratedWindowClass>() ,
               1072usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsDecoratedWindowClass
               ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsDecoratedWindowClass>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsDecoratedWindowClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsDecoratedWindowClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsDecoratedWindowClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsDecoratedWindowClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsDecoratedWindowClass =
    _GraniteWidgetsDecoratedWindowClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsDecoratedWindowPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsDecoratedWindowPrivate =
    _GraniteWidgetsDecoratedWindowPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsLightWindow {
    pub parent_instance: GraniteWidgetsDecoratedWindow,
    pub priv_: *mut GraniteWidgetsLightWindowPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsLightWindow() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsLightWindow>() , 88usize ,
               concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsLightWindow ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsLightWindow>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsLightWindow )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsLightWindow ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsLightWindow ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsLightWindow ) ) . priv_ as
                * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsLightWindow ) , "::" , stringify ! ( priv_ )
                ));
}
impl Clone for _GraniteWidgetsLightWindow {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsLightWindow = _GraniteWidgetsLightWindow;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsLightWindowClass {
    pub parent_class: GraniteWidgetsDecoratedWindowClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsLightWindowClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsLightWindowClass>() ,
               1072usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsLightWindowClass )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsLightWindowClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsLightWindowClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsLightWindowClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsLightWindowClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsLightWindowClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsLightWindowClass = _GraniteWidgetsLightWindowClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsLightWindowPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsLightWindowPrivate = _GraniteWidgetsLightWindowPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsStatusBar {
    pub parent_instance: GtkToolbar,
    pub priv_: *mut GraniteWidgetsStatusBarPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsStatusBar() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsStatusBar>() , 56usize ,
               concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsStatusBar ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsStatusBar>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsStatusBar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsStatusBar ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsStatusBar ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsStatusBar ) ) . priv_ as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsStatusBar ) , "::" , stringify ! ( priv_ ) ));
}
impl Clone for _GraniteWidgetsStatusBar {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsStatusBar = _GraniteWidgetsStatusBar;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsStatusBarClass {
    pub parent_class: GtkToolbarClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsStatusBarClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsStatusBarClass>() ,
               1032usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsStatusBarClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsStatusBarClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsStatusBarClass
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsStatusBarClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsStatusBarClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsStatusBarClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsStatusBarClass = _GraniteWidgetsStatusBarClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsStatusBarPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsStatusBarPrivate = _GraniteWidgetsStatusBarPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsThinPaned {
    pub parent_instance: GtkPaned,
    pub priv_: *mut GraniteWidgetsThinPanedPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsThinPaned() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsThinPaned>() , 56usize ,
               concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsThinPaned ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsThinPaned>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsThinPaned ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsThinPaned ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsThinPaned ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsThinPaned ) ) . priv_ as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsThinPaned ) , "::" , stringify ! ( priv_ ) ));
}
impl Clone for _GraniteWidgetsThinPaned {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsThinPaned = _GraniteWidgetsThinPaned;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsThinPanedClass {
    pub parent_class: GtkPanedClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsThinPanedClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsThinPanedClass>() ,
               1056usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsThinPanedClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsThinPanedClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsThinPanedClass
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsThinPanedClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsThinPanedClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsThinPanedClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsThinPanedClass = _GraniteWidgetsThinPanedClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsThinPanedPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsThinPanedPrivate = _GraniteWidgetsThinPanedPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsSidebarPaned {
    pub parent_instance: GraniteWidgetsThinPaned,
    pub priv_: *mut GraniteWidgetsSidebarPanedPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsSidebarPaned() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsSidebarPaned>() , 64usize
               , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsSidebarPaned ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsSidebarPaned>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsSidebarPaned )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsSidebarPaned ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSidebarPaned ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsSidebarPaned ) ) . priv_
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSidebarPaned ) , "::" , stringify ! ( priv_ )
                ));
}
impl Clone for _GraniteWidgetsSidebarPaned {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsSidebarPaned = _GraniteWidgetsSidebarPaned;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsSidebarPanedClass {
    pub parent_class: GraniteWidgetsThinPanedClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsSidebarPanedClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsSidebarPanedClass>() ,
               1056usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsSidebarPanedClass )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsSidebarPanedClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsSidebarPanedClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsSidebarPanedClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSidebarPanedClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsSidebarPanedClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsSidebarPanedClass = _GraniteWidgetsSidebarPanedClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsSidebarPanedPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsSidebarPanedPrivate =
    _GraniteWidgetsSidebarPanedPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsStorageBar {
    pub parent_instance: GtkBox,
    pub priv_: *mut GraniteWidgetsStorageBarPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsStorageBar() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsStorageBar>() , 56usize ,
               concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsStorageBar ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsStorageBar>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsStorageBar )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsStorageBar ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsStorageBar ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsStorageBar ) ) . priv_ as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsStorageBar ) , "::" , stringify ! ( priv_ ) ));
}
impl Clone for _GraniteWidgetsStorageBar {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsStorageBar = _GraniteWidgetsStorageBar;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsStorageBarClass {
    pub parent_class: GtkBoxClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsStorageBarClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsStorageBarClass>() ,
               1008usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsStorageBarClass )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsStorageBarClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsStorageBarClass
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsStorageBarClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsStorageBarClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsStorageBarClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsStorageBarClass = _GraniteWidgetsStorageBarClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsStorageBarPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsStorageBarPrivate = _GraniteWidgetsStorageBarPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsSourceListItem {
    pub parent_instance: GObject,
    pub priv_: *mut GraniteWidgetsSourceListItemPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsSourceListItem() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsSourceListItem>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsSourceListItem ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsSourceListItem>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsSourceListItem
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsSourceListItem ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSourceListItem ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsSourceListItem ) ) . priv_
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSourceListItem ) , "::" , stringify ! ( priv_ )
                ));
}
impl Clone for _GraniteWidgetsSourceListItem {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsSourceListItem = _GraniteWidgetsSourceListItem;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsSourceListItemClass {
    pub parent_class: GObjectClass,
    pub get_context_menu: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                         *mut GraniteWidgetsSourceListItem)
                                                    -> *mut GtkMenu>,
    pub edited: ::std::option::Option<unsafe extern "C" fn(self_:
                                                               *mut GraniteWidgetsSourceListItem,
                                                           new_name:
                                                               *const gchar)>,
    pub action_activated: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                         *mut GraniteWidgetsSourceListItem)>,
    pub activated: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                  *mut GraniteWidgetsSourceListItem)>,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsSourceListItemClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsSourceListItemClass>() ,
               168usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsSourceListItemClass
               ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsSourceListItemClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsSourceListItemClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsSourceListItemClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSourceListItemClass ) , "::" , stringify ! (
                parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsSourceListItemClass ) ) .
                get_context_menu as * const _ as usize } , 136usize , concat !
                (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSourceListItemClass ) , "::" , stringify ! (
                get_context_menu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsSourceListItemClass ) ) .
                edited as * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSourceListItemClass ) , "::" , stringify ! (
                edited ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsSourceListItemClass ) ) .
                action_activated as * const _ as usize } , 152usize , concat !
                (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSourceListItemClass ) , "::" , stringify ! (
                action_activated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsSourceListItemClass ) ) .
                activated as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSourceListItemClass ) , "::" , stringify ! (
                activated ) ));
}
impl Clone for _GraniteWidgetsSourceListItemClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsSourceListItemClass =
    _GraniteWidgetsSourceListItemClass;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsSourceListExpandableItem {
    pub parent_instance: GraniteWidgetsSourceListItem,
    pub priv_: *mut GraniteWidgetsSourceListExpandableItemPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsSourceListExpandableItem() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsSourceListExpandableItem>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               _GraniteWidgetsSourceListExpandableItem ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsSourceListExpandableItem>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsSourceListExpandableItem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsSourceListExpandableItem )
                ) . parent_instance as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSourceListExpandableItem ) , "::" , stringify !
                ( parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsSourceListExpandableItem )
                ) . priv_ as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSourceListExpandableItem ) , "::" , stringify !
                ( priv_ ) ));
}
impl Clone for _GraniteWidgetsSourceListExpandableItem {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsSourceListExpandableItem =
    _GraniteWidgetsSourceListExpandableItem;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsSourceListExpandableItemClass {
    pub parent_class: GraniteWidgetsSourceListItemClass,
    pub toggled: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                *mut GraniteWidgetsSourceListExpandableItem)>,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsSourceListExpandableItemClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsSourceListExpandableItemClass>()
               , 176usize , concat ! (
               "Size of: " , stringify ! (
               _GraniteWidgetsSourceListExpandableItemClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsSourceListExpandableItemClass>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsSourceListExpandableItemClass ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const _GraniteWidgetsSourceListExpandableItemClass
                ) ) . parent_class as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSourceListExpandableItemClass ) , "::" ,
                stringify ! ( parent_class ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const _GraniteWidgetsSourceListExpandableItemClass
                ) ) . toggled as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSourceListExpandableItemClass ) , "::" ,
                stringify ! ( toggled ) ));
}
impl Clone for _GraniteWidgetsSourceListExpandableItemClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsSourceListExpandableItemClass =
    _GraniteWidgetsSourceListExpandableItemClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsSourceListSortable {
    _unused: [u8; 0],
}
pub type GraniteWidgetsSourceListSortable = _GraniteWidgetsSourceListSortable;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsSourceListSortableIface {
    pub parent_iface: GTypeInterface,
    pub allow_dnd_sorting: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                          *mut GraniteWidgetsSourceListSortable)
                                                     -> gboolean>,
    pub compare: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                *mut GraniteWidgetsSourceListSortable,
                                                            a:
                                                                *mut GraniteWidgetsSourceListItem,
                                                            b:
                                                                *mut GraniteWidgetsSourceListItem)
                                           -> gint>,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsSourceListSortableIface() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsSourceListSortableIface>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               _GraniteWidgetsSourceListSortableIface ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsSourceListSortableIface>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsSourceListSortableIface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsSourceListSortableIface )
                ) . parent_iface as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSourceListSortableIface ) , "::" , stringify !
                ( parent_iface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsSourceListSortableIface )
                ) . allow_dnd_sorting as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSourceListSortableIface ) , "::" , stringify !
                ( allow_dnd_sorting ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsSourceListSortableIface )
                ) . compare as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSourceListSortableIface ) , "::" , stringify !
                ( compare ) ));
}
impl Clone for _GraniteWidgetsSourceListSortableIface {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsSourceListSortableIface =
    _GraniteWidgetsSourceListSortableIface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsSourceListDragSource {
    _unused: [u8; 0],
}
pub type GraniteWidgetsSourceListDragSource =
    _GraniteWidgetsSourceListDragSource;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsSourceListDragSourceIface {
    pub parent_iface: GTypeInterface,
    pub draggable: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                  *mut GraniteWidgetsSourceListDragSource)
                                             -> gboolean>,
    pub prepare_selection_data: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                               *mut GraniteWidgetsSourceListDragSource,
                                                                           selection_data:
                                                                               *mut GtkSelectionData)>,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsSourceListDragSourceIface() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsSourceListDragSourceIface>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               _GraniteWidgetsSourceListDragSourceIface ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsSourceListDragSourceIface>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsSourceListDragSourceIface ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const _GraniteWidgetsSourceListDragSourceIface ) )
                . parent_iface as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSourceListDragSourceIface ) , "::" , stringify
                ! ( parent_iface ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const _GraniteWidgetsSourceListDragSourceIface ) )
                . draggable as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSourceListDragSourceIface ) , "::" , stringify
                ! ( draggable ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const _GraniteWidgetsSourceListDragSourceIface ) )
                . prepare_selection_data as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSourceListDragSourceIface ) , "::" , stringify
                ! ( prepare_selection_data ) ));
}
impl Clone for _GraniteWidgetsSourceListDragSourceIface {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsSourceListDragSourceIface =
    _GraniteWidgetsSourceListDragSourceIface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsSourceListDragDest {
    _unused: [u8; 0],
}
pub type GraniteWidgetsSourceListDragDest = _GraniteWidgetsSourceListDragDest;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsSourceListDragDestIface {
    pub parent_iface: GTypeInterface,
    pub data_drop_possible: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                           *mut GraniteWidgetsSourceListDragDest,
                                                                       context:
                                                                           *mut GdkDragContext,
                                                                       data:
                                                                           *mut GtkSelectionData)
                                                      -> gboolean>,
    pub data_received: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                      *mut GraniteWidgetsSourceListDragDest,
                                                                  context:
                                                                      *mut GdkDragContext,
                                                                  data:
                                                                      *mut GtkSelectionData)
                                                 -> GdkDragAction>,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsSourceListDragDestIface() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsSourceListDragDestIface>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               _GraniteWidgetsSourceListDragDestIface ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsSourceListDragDestIface>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsSourceListDragDestIface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsSourceListDragDestIface )
                ) . parent_iface as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSourceListDragDestIface ) , "::" , stringify !
                ( parent_iface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsSourceListDragDestIface )
                ) . data_drop_possible as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSourceListDragDestIface ) , "::" , stringify !
                ( data_drop_possible ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsSourceListDragDestIface )
                ) . data_received as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSourceListDragDestIface ) , "::" , stringify !
                ( data_received ) ));
}
impl Clone for _GraniteWidgetsSourceListDragDestIface {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsSourceListDragDestIface =
    _GraniteWidgetsSourceListDragDestIface;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsSourceList {
    pub parent_instance: GtkScrolledWindow,
    pub priv_: *mut GraniteWidgetsSourceListPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsSourceList() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsSourceList>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsSourceList ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsSourceList>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsSourceList )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsSourceList ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSourceList ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsSourceList ) ) . priv_ as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSourceList ) , "::" , stringify ! ( priv_ ) ));
}
impl Clone for _GraniteWidgetsSourceList {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsSourceList = _GraniteWidgetsSourceList;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsSourceListClass {
    pub parent_class: GtkScrolledWindowClass,
    pub item_selected: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                      *mut GraniteWidgetsSourceList,
                                                                  item:
                                                                      *mut GraniteWidgetsSourceListItem)>,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsSourceListClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsSourceListClass>() ,
               1072usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsSourceListClass )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsSourceListClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsSourceListClass
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsSourceListClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSourceListClass ) , "::" , stringify ! (
                parent_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsSourceListClass ) ) .
                item_selected as * const _ as usize } , 1064usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsSourceListClass ) , "::" , stringify ! (
                item_selected ) ));
}
impl Clone for _GraniteWidgetsSourceListClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsSourceListClass = _GraniteWidgetsSourceListClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsSourceListPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsSourceListPrivate = _GraniteWidgetsSourceListPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsSourceListItemPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsSourceListItemPrivate =
    _GraniteWidgetsSourceListItemPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsSourceListExpandableItemPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsSourceListExpandableItemPrivate =
    _GraniteWidgetsSourceListExpandableItemPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsCellRendererExpander {
    pub parent_instance: GtkCellRenderer,
    pub priv_: *mut GraniteWidgetsCellRendererExpanderPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsCellRendererExpander() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsCellRendererExpander>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsCellRendererExpander
               ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsCellRendererExpander>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsCellRendererExpander ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsCellRendererExpander ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsCellRendererExpander ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsCellRendererExpander ) ) .
                priv_ as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsCellRendererExpander ) , "::" , stringify ! (
                priv_ ) ));
}
impl Clone for _GraniteWidgetsCellRendererExpander {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsCellRendererExpander =
    _GraniteWidgetsCellRendererExpander;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsCellRendererExpanderClass {
    pub parent_class: GtkCellRendererClass,
    pub get_arrow_size: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                       *mut GraniteWidgetsCellRendererExpander,
                                                                   widget:
                                                                       *mut GtkWidget)
                                                  -> gint>,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsCellRendererExpanderClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsCellRendererExpanderClass>()
               , 272usize , concat ! (
               "Size of: " , stringify ! (
               _GraniteWidgetsCellRendererExpanderClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsCellRendererExpanderClass>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsCellRendererExpanderClass ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const _GraniteWidgetsCellRendererExpanderClass ) )
                . parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsCellRendererExpanderClass ) , "::" , stringify
                ! ( parent_class ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const _GraniteWidgetsCellRendererExpanderClass ) )
                . get_arrow_size as * const _ as usize } , 264usize , concat !
                (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsCellRendererExpanderClass ) , "::" , stringify
                ! ( get_arrow_size ) ));
}
impl Clone for _GraniteWidgetsCellRendererExpanderClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsCellRendererExpanderClass =
    _GraniteWidgetsCellRendererExpanderClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsCellRendererExpanderPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsCellRendererExpanderPrivate =
    _GraniteWidgetsCellRendererExpanderPrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsCellRendererBadge {
    pub parent_instance: GtkCellRenderer,
    pub priv_: *mut GraniteWidgetsCellRendererBadgePrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsCellRendererBadge() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsCellRendererBadge>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsCellRendererBadge )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsCellRendererBadge>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsCellRendererBadge ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsCellRendererBadge ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsCellRendererBadge ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsCellRendererBadge ) ) .
                priv_ as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsCellRendererBadge ) , "::" , stringify ! (
                priv_ ) ));
}
impl Clone for _GraniteWidgetsCellRendererBadge {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsCellRendererBadge = _GraniteWidgetsCellRendererBadge;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsCellRendererBadgeClass {
    pub parent_class: GtkCellRendererClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsCellRendererBadgeClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsCellRendererBadgeClass>()
               , 264usize , concat ! (
               "Size of: " , stringify ! (
               _GraniteWidgetsCellRendererBadgeClass ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsCellRendererBadgeClass>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                _GraniteWidgetsCellRendererBadgeClass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsCellRendererBadgeClass ) )
                . parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsCellRendererBadgeClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsCellRendererBadgeClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsCellRendererBadgeClass =
    _GraniteWidgetsCellRendererBadgeClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsCellRendererBadgePrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsCellRendererBadgePrivate =
    _GraniteWidgetsCellRendererBadgePrivate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsOverlayBar {
    pub parent_instance: GtkEventBox,
    pub priv_: *mut GraniteWidgetsOverlayBarPrivate,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsOverlayBar() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsOverlayBar>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsOverlayBar ) ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsOverlayBar>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsOverlayBar )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsOverlayBar ) ) .
                parent_instance as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsOverlayBar ) , "::" , stringify ! (
                parent_instance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsOverlayBar ) ) . priv_ as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsOverlayBar ) , "::" , stringify ! ( priv_ ) ));
}
impl Clone for _GraniteWidgetsOverlayBar {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsOverlayBar = _GraniteWidgetsOverlayBar;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GraniteWidgetsOverlayBarClass {
    pub parent_class: GtkEventBoxClass,
}
#[test]
fn bindgen_test_layout__GraniteWidgetsOverlayBarClass() {
    assert_eq!(::std::mem::size_of::<_GraniteWidgetsOverlayBarClass>() ,
               1040usize , concat ! (
               "Size of: " , stringify ! ( _GraniteWidgetsOverlayBarClass )
               ));
    assert_eq! (::std::mem::align_of::<_GraniteWidgetsOverlayBarClass>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _GraniteWidgetsOverlayBarClass
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _GraniteWidgetsOverlayBarClass ) ) .
                parent_class as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _GraniteWidgetsOverlayBarClass ) , "::" , stringify ! (
                parent_class ) ));
}
impl Clone for _GraniteWidgetsOverlayBarClass {
    fn clone(&self) -> Self { *self }
}
pub type GraniteWidgetsOverlayBarClass = _GraniteWidgetsOverlayBarClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GraniteWidgetsOverlayBarPrivate {
    _unused: [u8; 0],
}
pub type GraniteWidgetsOverlayBarPrivate = _GraniteWidgetsOverlayBarPrivate;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GraniteServicesLogLevel {
    GRANITE_SERVICES_LOG_LEVEL_DEBUG = 0,
    GRANITE_SERVICES_LOG_LEVEL_INFO = 1,
    GRANITE_SERVICES_LOG_LEVEL_NOTIFY = 2,
    GRANITE_SERVICES_LOG_LEVEL_WARN = 3,
    GRANITE_SERVICES_LOG_LEVEL_ERROR = 4,
    GRANITE_SERVICES_LOG_LEVEL_FATAL = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GraniteServicesContractorError {
    GRANITE_SERVICES_CONTRACTOR_ERROR_SERVICE_NOT_AVAILABLE = 0,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GraniteTextStyle {
    GRANITE_TEXT_STYLE_TITLE = 0,
    GRANITE_TEXT_STYLE_H1 = 1,
    GRANITE_TEXT_STYLE_H2 = 2,
    GRANITE_TEXT_STYLE_H3 = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GraniteCloseButtonPosition {
    GRANITE_CLOSE_BUTTON_POSITION_LEFT = 0,
    GRANITE_CLOSE_BUTTON_POSITION_RIGHT = 1,
}
pub const GraniteCollapseMode_GRANITE_COLLAPSE_MODE_TOP: GraniteCollapseMode =
    GraniteCollapseMode::GRANITE_COLLAPSE_MODE_LEFT;
pub const GraniteCollapseMode_GRANITE_COLLAPSE_MODE_FIRST: GraniteCollapseMode
          =
    GraniteCollapseMode::GRANITE_COLLAPSE_MODE_LEFT;
pub const GraniteCollapseMode_GRANITE_COLLAPSE_MODE_BOTTOM:
          GraniteCollapseMode =
    GraniteCollapseMode::GRANITE_COLLAPSE_MODE_RIGHT;
pub const GraniteCollapseMode_GRANITE_COLLAPSE_MODE_LAST: GraniteCollapseMode
          =
    GraniteCollapseMode::GRANITE_COLLAPSE_MODE_RIGHT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GraniteCollapseMode {
    GRANITE_COLLAPSE_MODE_NONE = 0,
    GRANITE_COLLAPSE_MODE_LEFT = 1,
    GRANITE_COLLAPSE_MODE_RIGHT = 2,
}
pub type GraniteWidgetsDroppedDelegate =
    ::std::option::Option<unsafe extern "C" fn(user_data:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GraniteWidgetsDynamicNotebookTabBarBehavior {
    GRANITE_WIDGETS_DYNAMIC_NOTEBOOK_TAB_BAR_BEHAVIOR_ALWAYS = 0,
    GRANITE_WIDGETS_DYNAMIC_NOTEBOOK_TAB_BAR_BEHAVIOR_SINGLE = 1,
    GRANITE_WIDGETS_DYNAMIC_NOTEBOOK_TAB_BAR_BEHAVIOR_NEVER = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GraniteWidgetsToolButtonWithMenuVMenuPosition {
    GRANITE_WIDGETS_TOOL_BUTTON_WITH_MENU_VMENU_POSITION_TOP = 0,
    GRANITE_WIDGETS_TOOL_BUTTON_WITH_MENU_VMENU_POSITION_BOTTOM = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GraniteWidgetsToolButtonWithMenuHMenuPosition {
    GRANITE_WIDGETS_TOOL_BUTTON_WITH_MENU_HMENU_POSITION_LEFT = 0,
    GRANITE_WIDGETS_TOOL_BUTTON_WITH_MENU_HMENU_POSITION_CENTER = 1,
    GRANITE_WIDGETS_TOOL_BUTTON_WITH_MENU_HMENU_POSITION_RIGHT = 2,
    GRANITE_WIDGETS_TOOL_BUTTON_WITH_MENU_HMENU_POSITION_INSIDE_WINDOW = 3,
}
pub type GraniteWidgetsToolButtonWithMenuMenuFetcher =
    ::std::option::Option<unsafe extern "C" fn(user_data:
                                                   *mut ::std::os::raw::c_void)
                              -> *mut GtkMenu>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GraniteWidgetsPopOverPopPosition {
    GRANITE_WIDGETS_POP_OVER_POP_POSITION_NONE = 0,
    GRANITE_WIDGETS_POP_OVER_POP_POSITION_TOPLEFT = 1,
    GRANITE_WIDGETS_POP_OVER_POP_POSITION_TOPRIGHT = 2,
    GRANITE_WIDGETS_POP_OVER_POP_POSITION_BOTTOMLEFT = 3,
    GRANITE_WIDGETS_POP_OVER_POP_POSITION_BOTTOMRIGHT = 4,
}
pub type GraniteWidgetsContractorViewContractCallback =
    ::std::option::Option<unsafe extern "C" fn(user_data:
                                                   *mut ::std::os::raw::c_void)>;
pub type GraniteWidgetsContractorMenuContractCallback =
    ::std::option::Option<unsafe extern "C" fn(user_data:
                                                   *mut ::std::os::raw::c_void)>;
pub const GraniteWidgetsStorageBarItemDescription_GRANITE_WIDGETS_STORAGE_BAR_ITEM_DESCRIPTION_FILES:
          GraniteWidgetsStorageBarItemDescription =
    GraniteWidgetsStorageBarItemDescription::GRANITE_WIDGETS_STORAGE_BAR_ITEM_DESCRIPTION_OTHER;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GraniteWidgetsStorageBarItemDescription {
    GRANITE_WIDGETS_STORAGE_BAR_ITEM_DESCRIPTION_OTHER = 0,
    GRANITE_WIDGETS_STORAGE_BAR_ITEM_DESCRIPTION_AUDIO = 1,
    GRANITE_WIDGETS_STORAGE_BAR_ITEM_DESCRIPTION_VIDEO = 2,
    GRANITE_WIDGETS_STORAGE_BAR_ITEM_DESCRIPTION_PHOTO = 3,
    GRANITE_WIDGETS_STORAGE_BAR_ITEM_DESCRIPTION_APP = 4,
}
pub type GraniteWidgetsSourceListSortFunc =
    ::std::option::Option<unsafe extern "C" fn(a:
                                                   *mut GraniteWidgetsSourceListItem,
                                               b:
                                                   *mut GraniteWidgetsSourceListItem,
                                               user_data:
                                                   *mut ::std::os::raw::c_void)
                              -> gint>;
pub type GraniteWidgetsSourceListVisibleFunc =
    ::std::option::Option<unsafe extern "C" fn(item:
                                                   *mut GraniteWidgetsSourceListItem,
                                               user_data:
                                                   *mut ::std::os::raw::c_void)
                              -> gboolean>;
extern "C" {
    pub fn granite_application_get_type() -> GType;
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_about_dialog_get_type() -> GType;
}
extern "C" {
    pub fn granite_application_construct(object_type: GType)
     -> *mut GraniteApplication;
}
extern "C" {
    pub fn granite_application_run(self_: *mut GraniteApplication,
                                   args: *mut *mut gchar,
                                   args_length1: ::std::os::raw::c_int)
     -> gint;
}
extern "C" {
    pub fn granite_application_set_options(self_: *mut GraniteApplication);
}
extern "C" {
    pub fn granite_widgets_tool_button_with_menu_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_app_menu_get_type() -> GType;
}
extern "C" {
    pub fn granite_application_create_appmenu(self_: *mut GraniteApplication,
                                              menu: *mut GtkMenu)
     -> *mut GraniteWidgetsAppMenu;
}
extern "C" {
    pub fn granite_application_show_about(self_: *mut GraniteApplication,
                                          parent: *mut GtkWidget);
}
extern "C" {
    pub fn granite_services_settings_serializable_get_type() -> GType;
}
extern "C" {
    pub fn granite_drawing_color_get_type() -> GType;
}
extern "C" {
    pub fn granite_drawing_color_new(R: gdouble, G: gdouble, B: gdouble,
                                     A: gdouble) -> *mut GraniteDrawingColor;
}
extern "C" {
    pub fn granite_drawing_color_construct(object_type: GType, R: gdouble,
                                           G: gdouble, B: gdouble, A: gdouble)
     -> *mut GraniteDrawingColor;
}
extern "C" {
    pub fn granite_drawing_color_new_from_gdk(color: *mut GdkColor)
     -> *mut GraniteDrawingColor;
}
extern "C" {
    pub fn granite_drawing_color_construct_from_gdk(object_type: GType,
                                                    color: *mut GdkColor)
     -> *mut GraniteDrawingColor;
}
extern "C" {
    pub fn granite_drawing_color_set_hue(self_: *mut GraniteDrawingColor,
                                         hue: gdouble)
     -> *mut GraniteDrawingColor;
}
extern "C" {
    pub fn granite_drawing_color_set_sat(self_: *mut GraniteDrawingColor,
                                         sat: gdouble)
     -> *mut GraniteDrawingColor;
}
extern "C" {
    pub fn granite_drawing_color_set_val(self_: *mut GraniteDrawingColor,
                                         val: gdouble)
     -> *mut GraniteDrawingColor;
}
extern "C" {
    pub fn granite_drawing_color_set_alpha(self_: *mut GraniteDrawingColor,
                                           alpha: gdouble)
     -> *mut GraniteDrawingColor;
}
extern "C" {
    pub fn granite_drawing_color_get_hue(self_: *mut GraniteDrawingColor)
     -> gdouble;
}
extern "C" {
    pub fn granite_drawing_color_get_sat(self_: *mut GraniteDrawingColor)
     -> gdouble;
}
extern "C" {
    pub fn granite_drawing_color_get_val(self_: *mut GraniteDrawingColor)
     -> gdouble;
}
extern "C" {
    pub fn granite_drawing_color_add_hue(self_: *mut GraniteDrawingColor,
                                         val: gdouble)
     -> *mut GraniteDrawingColor;
}
extern "C" {
    pub fn granite_drawing_color_set_min_sat(self_: *mut GraniteDrawingColor,
                                             sat: gdouble)
     -> *mut GraniteDrawingColor;
}
extern "C" {
    pub fn granite_drawing_color_set_min_value(self_:
                                                   *mut GraniteDrawingColor,
                                               val: gdouble)
     -> *mut GraniteDrawingColor;
}
extern "C" {
    pub fn granite_drawing_color_set_max_sat(self_: *mut GraniteDrawingColor,
                                             sat: gdouble)
     -> *mut GraniteDrawingColor;
}
extern "C" {
    pub fn granite_drawing_color_set_max_val(self_: *mut GraniteDrawingColor,
                                             val: gdouble)
     -> *mut GraniteDrawingColor;
}
extern "C" {
    pub fn granite_drawing_color_multiply_sat(self_: *mut GraniteDrawingColor,
                                              amount: gdouble)
     -> *mut GraniteDrawingColor;
}
extern "C" {
    pub fn granite_drawing_color_brighten_val(self_: *mut GraniteDrawingColor,
                                              amount: gdouble)
     -> *mut GraniteDrawingColor;
}
extern "C" {
    pub fn granite_drawing_color_darken_val(self_: *mut GraniteDrawingColor,
                                            amount: gdouble)
     -> *mut GraniteDrawingColor;
}
extern "C" {
    pub fn granite_drawing_color_darken_by_sat(self_:
                                                   *mut GraniteDrawingColor,
                                               amount: gdouble)
     -> *mut GraniteDrawingColor;
}
extern "C" {
    pub fn granite_drawing_buffer_surface_get_type() -> GType;
}
extern "C" {
    pub fn granite_drawing_buffer_surface_new(width: gint, height: gint)
     -> *mut GraniteDrawingBufferSurface;
}
extern "C" {
    pub fn granite_drawing_buffer_surface_construct(object_type: GType,
                                                    width: gint, height: gint)
     -> *mut GraniteDrawingBufferSurface;
}
extern "C" {
    pub fn granite_drawing_buffer_surface_new_with_surface(width: gint,
                                                           height: gint,
                                                           model:
                                                               *mut cairo_surface_t)
     -> *mut GraniteDrawingBufferSurface;
}
extern "C" {
    pub fn granite_drawing_buffer_surface_construct_with_surface(object_type:
                                                                     GType,
                                                                 width: gint,
                                                                 height: gint,
                                                                 model:
                                                                     *mut cairo_surface_t)
     -> *mut GraniteDrawingBufferSurface;
}
extern "C" {
    pub fn granite_drawing_buffer_surface_new_with_buffer_surface(width: gint,
                                                                  height:
                                                                      gint,
                                                                  model:
                                                                      *mut GraniteDrawingBufferSurface)
     -> *mut GraniteDrawingBufferSurface;
}
extern "C" {
    pub fn granite_drawing_buffer_surface_construct_with_buffer_surface(object_type:
                                                                            GType,
                                                                        width:
                                                                            gint,
                                                                        height:
                                                                            gint,
                                                                        model:
                                                                            *mut GraniteDrawingBufferSurface)
     -> *mut GraniteDrawingBufferSurface;
}
extern "C" {
    pub fn granite_drawing_buffer_surface_clear(self_:
                                                    *mut GraniteDrawingBufferSurface);
}
extern "C" {
    pub fn granite_drawing_buffer_surface_load_to_pixbuf(self_:
                                                             *mut GraniteDrawingBufferSurface)
     -> *mut GdkPixbuf;
}
extern "C" {
    pub fn granite_drawing_buffer_surface_average_color(self_:
                                                            *mut GraniteDrawingBufferSurface)
     -> *mut GraniteDrawingColor;
}
extern "C" {
    pub fn granite_drawing_buffer_surface_fast_blur(self_:
                                                        *mut GraniteDrawingBufferSurface,
                                                    radius: gint,
                                                    process_count: gint);
}
extern "C" {
    pub fn granite_drawing_buffer_surface_exponential_blur(self_:
                                                               *mut GraniteDrawingBufferSurface,
                                                           radius: gint);
}
extern "C" {
    pub fn granite_drawing_buffer_surface_gaussian_blur(self_:
                                                            *mut GraniteDrawingBufferSurface,
                                                        radius: gint);
}
extern "C" {
    pub fn granite_drawing_buffer_surface_get_surface(self_:
                                                          *mut GraniteDrawingBufferSurface)
     -> *mut cairo_surface_t;
}
extern "C" {
    pub fn granite_drawing_buffer_surface_get_width(self_:
                                                        *mut GraniteDrawingBufferSurface)
     -> gint;
}
extern "C" {
    pub fn granite_drawing_buffer_surface_get_height(self_:
                                                         *mut GraniteDrawingBufferSurface)
     -> gint;
}
extern "C" {
    pub fn granite_drawing_buffer_surface_get_context(self_:
                                                          *mut GraniteDrawingBufferSurface)
     -> *mut cairo_t;
}
extern "C" {
    pub fn granite_drawing_utilities_get_type() -> GType;
}
extern "C" {
    pub fn granite_drawing_utilities_cairo_rounded_rectangle(cr: *mut cairo_t,
                                                             x: gdouble,
                                                             y: gdouble,
                                                             width: gdouble,
                                                             height: gdouble,
                                                             radius: gdouble);
}
extern "C" {
    pub fn granite_drawing_utilities_average_color(source: *mut GdkPixbuf)
     -> *mut GraniteDrawingColor;
}
extern "C" {
    pub fn granite_drawing_utilities_new() -> *mut GraniteDrawingUtilities;
}
extern "C" {
    pub fn granite_drawing_utilities_construct(object_type: GType)
     -> *mut GraniteDrawingUtilities;
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_new()
     -> *mut GraniteGtkPatchAboutDialog;
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_construct(object_type: GType)
     -> *mut GraniteGtkPatchAboutDialog;
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_get_artists(self_:
                                                          *mut GraniteGtkPatchAboutDialog,
                                                      result_length1:
                                                          *mut ::std::os::raw::c_int)
     -> *mut *mut gchar;
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_set_artists(self_:
                                                          *mut GraniteGtkPatchAboutDialog,
                                                      value: *mut *mut gchar,
                                                      value_length1:
                                                          ::std::os::raw::c_int);
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_get_authors(self_:
                                                          *mut GraniteGtkPatchAboutDialog,
                                                      result_length1:
                                                          *mut ::std::os::raw::c_int)
     -> *mut *mut gchar;
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_set_authors(self_:
                                                          *mut GraniteGtkPatchAboutDialog,
                                                      value: *mut *mut gchar,
                                                      value_length1:
                                                          ::std::os::raw::c_int);
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_get_comments(self_:
                                                           *mut GraniteGtkPatchAboutDialog)
     -> *const gchar;
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_set_comments(self_:
                                                           *mut GraniteGtkPatchAboutDialog,
                                                       value: *const gchar);
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_get_copyright(self_:
                                                            *mut GraniteGtkPatchAboutDialog)
     -> *const gchar;
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_set_copyright(self_:
                                                            *mut GraniteGtkPatchAboutDialog,
                                                        value: *const gchar);
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_get_documenters(self_:
                                                              *mut GraniteGtkPatchAboutDialog,
                                                          result_length1:
                                                              *mut ::std::os::raw::c_int)
     -> *mut *mut gchar;
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_set_documenters(self_:
                                                              *mut GraniteGtkPatchAboutDialog,
                                                          value:
                                                              *mut *mut gchar,
                                                          value_length1:
                                                              ::std::os::raw::c_int);
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_get_license(self_:
                                                          *mut GraniteGtkPatchAboutDialog)
     -> *const gchar;
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_set_license(self_:
                                                          *mut GraniteGtkPatchAboutDialog,
                                                      value: *const gchar);
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_get_license_type(self_:
                                                               *mut GraniteGtkPatchAboutDialog)
     -> GtkLicense;
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_set_license_type(self_:
                                                               *mut GraniteGtkPatchAboutDialog,
                                                           value: GtkLicense);
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_get_logo(self_:
                                                       *mut GraniteGtkPatchAboutDialog)
     -> *mut GdkPixbuf;
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_set_logo(self_:
                                                       *mut GraniteGtkPatchAboutDialog,
                                                   value: *mut GdkPixbuf);
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_get_logo_icon_name(self_:
                                                                 *mut GraniteGtkPatchAboutDialog)
     -> *const gchar;
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_set_logo_icon_name(self_:
                                                                 *mut GraniteGtkPatchAboutDialog,
                                                             value:
                                                                 *const gchar);
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_get_program_name(self_:
                                                               *mut GraniteGtkPatchAboutDialog)
     -> *const gchar;
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_set_program_name(self_:
                                                               *mut GraniteGtkPatchAboutDialog,
                                                           value:
                                                               *const gchar);
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_get_translator_credits(self_:
                                                                     *mut GraniteGtkPatchAboutDialog)
     -> *const gchar;
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_set_translator_credits(self_:
                                                                     *mut GraniteGtkPatchAboutDialog,
                                                                 value:
                                                                     *const gchar);
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_get_version(self_:
                                                          *mut GraniteGtkPatchAboutDialog)
     -> *const gchar;
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_set_version(self_:
                                                          *mut GraniteGtkPatchAboutDialog,
                                                      value: *const gchar);
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_get_website(self_:
                                                          *mut GraniteGtkPatchAboutDialog)
     -> *const gchar;
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_set_website(self_:
                                                          *mut GraniteGtkPatchAboutDialog,
                                                      value: *const gchar);
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_get_website_label(self_:
                                                                *mut GraniteGtkPatchAboutDialog)
     -> *const gchar;
}
extern "C" {
    pub fn granite_gtk_patch_about_dialog_set_website_label(self_:
                                                                *mut GraniteGtkPatchAboutDialog,
                                                            value:
                                                                *const gchar);
}
extern "C" {
    pub fn granite_services_settings_serializable_settings_serialize(self_:
                                                                         *mut GraniteServicesSettingsSerializable)
     -> *mut gchar;
}
extern "C" {
    pub fn granite_services_settings_serializable_settings_deserialize(self_:
                                                                           *mut GraniteServicesSettingsSerializable,
                                                                       s:
                                                                           *const gchar);
}
extern "C" {
    pub fn granite_services_settings_get_type() -> GType;
}
extern "C" {
    pub fn granite_services_settings_construct(object_type: GType,
                                               schema: *const gchar)
     -> *mut GraniteServicesSettings;
}
extern "C" {
    pub fn granite_services_settings_construct_with_backend(object_type:
                                                                GType,
                                                            schema:
                                                                *const gchar,
                                                            backend:
                                                                *mut GSettingsBackend)
     -> *mut GraniteServicesSettings;
}
extern "C" {
    pub fn granite_services_settings_construct_with_backend_and_path(object_type:
                                                                         GType,
                                                                     schema:
                                                                         *const gchar,
                                                                     backend:
                                                                         *mut GSettingsBackend,
                                                                     path:
                                                                         *const gchar)
     -> *mut GraniteServicesSettings;
}
extern "C" {
    pub fn granite_services_settings_construct_with_path(object_type: GType,
                                                         schema: *const gchar,
                                                         path: *const gchar)
     -> *mut GraniteServicesSettings;
}
extern "C" {
    pub fn granite_services_settings_verify(self_:
                                                *mut GraniteServicesSettings,
                                            key: *const gchar);
}
extern "C" {
    pub fn granite_services_settings_get_schema(self_:
                                                    *mut GraniteServicesSettings)
     -> *mut GSettings;
}
extern "C" {
    pub fn granite_services_log_level_get_type() -> GType;
}
extern "C" {
    pub fn granite_services_logger_get_type() -> GType;
}
extern "C" {
    pub fn granite_services_logger_initialize(app_name: *const gchar);
}
extern "C" {
    pub fn granite_services_logger_notification(msg: *const gchar);
}
extern "C" {
    pub fn granite_services_logger_new() -> *mut GraniteServicesLogger;
}
extern "C" {
    pub fn granite_services_logger_construct(object_type: GType)
     -> *mut GraniteServicesLogger;
}
extern "C" {
    pub fn granite_services_logger_get_DisplayLevel()
     -> GraniteServicesLogLevel;
}
extern "C" {
    pub fn granite_services_logger_set_DisplayLevel(value:
                                                        GraniteServicesLogLevel);
}
extern "C" {
    pub fn granite_services_paths_get_type() -> GType;
}
extern "C" {
    pub fn granite_services_paths_initialize(app_name: *const gchar,
                                             data_folder_path: *const gchar);
}
extern "C" {
    pub fn granite_services_paths_ensure_directory_exists(dir: *mut GFile)
     -> gboolean;
}
extern "C" {
    pub fn granite_services_paths_new() -> *mut GraniteServicesPaths;
}
extern "C" {
    pub fn granite_services_paths_construct(object_type: GType)
     -> *mut GraniteServicesPaths;
}
extern "C" {
    pub fn granite_services_paths_get_home_folder() -> *mut GFile;
}
extern "C" {
    pub fn granite_services_paths_set_home_folder(value: *mut GFile);
}
extern "C" {
    pub fn granite_services_paths_get_data_folder() -> *mut GFile;
}
extern "C" {
    pub fn granite_services_paths_set_data_folder(value: *mut GFile);
}
extern "C" {
    pub fn granite_services_paths_get_xdg_config_home_folder() -> *mut GFile;
}
extern "C" {
    pub fn granite_services_paths_set_xdg_config_home_folder(value:
                                                                 *mut GFile);
}
extern "C" {
    pub fn granite_services_paths_get_xdg_data_home_folder() -> *mut GFile;
}
extern "C" {
    pub fn granite_services_paths_set_xdg_data_home_folder(value: *mut GFile);
}
extern "C" {
    pub fn granite_services_paths_get_xdg_cache_home_folder() -> *mut GFile;
}
extern "C" {
    pub fn granite_services_paths_set_xdg_cache_home_folder(value:
                                                                *mut GFile);
}
extern "C" {
    pub fn granite_services_paths_get_xdg_data_dir_folders() -> *mut GList;
}
extern "C" {
    pub fn granite_services_paths_set_xdg_data_dir_folders(value: *mut GList);
}
extern "C" {
    pub fn granite_services_paths_get_user_config_folder() -> *mut GFile;
}
extern "C" {
    pub fn granite_services_paths_set_user_config_folder(value: *mut GFile);
}
extern "C" {
    pub fn granite_services_paths_get_user_data_folder() -> *mut GFile;
}
extern "C" {
    pub fn granite_services_paths_set_user_data_folder(value: *mut GFile);
}
extern "C" {
    pub fn granite_services_paths_get_user_cache_folder() -> *mut GFile;
}
extern "C" {
    pub fn granite_services_paths_set_user_cache_folder(value: *mut GFile);
}
extern "C" {
    pub fn granite_services_system_get_type() -> GType;
}
extern "C" {
    pub fn granite_services_system_open_uri(uri: *const gchar);
}
extern "C" {
    pub fn granite_services_system_open(file: *mut GFile);
}
extern "C" {
    pub fn granite_services_system_open_files(files: *mut *mut GFile,
                                              files_length1:
                                                  ::std::os::raw::c_int);
}
extern "C" {
    pub fn granite_services_system_launch(app: *mut GFile);
}
extern "C" {
    pub fn granite_services_system_execute_command(command: *const gchar)
     -> gboolean;
}
extern "C" {
    pub fn granite_services_system_launch_with_files(app: *mut GFile,
                                                     files: *mut *mut GFile,
                                                     files_length1:
                                                         ::std::os::raw::c_int);
}
extern "C" {
    pub fn granite_services_system_new() -> *mut GraniteServicesSystem;
}
extern "C" {
    pub fn granite_services_system_construct(object_type: GType)
     -> *mut GraniteServicesSystem;
}
extern "C" {
    pub fn granite_services_contractor_get_type() -> GType;
}
extern "C" {
    pub fn granite_services_contractor_dbus_proxy_get_type() -> GType;
}
extern "C" {
    pub fn granite_services_contractor_dbus_register_object(object:
                                                                *mut ::std::os::raw::c_void,
                                                            connection:
                                                                *mut GDBusConnection,
                                                            path:
                                                                *const gchar,
                                                            error:
                                                                *mut *mut GError)
     -> guint;
}
extern "C" {
    pub fn granite_services_contractor_dbus_get_type() -> GType;
}
extern "C" {
    pub fn granite_services_contractor_new()
     -> *mut GraniteServicesContractor;
}
extern "C" {
    pub fn granite_services_contractor_construct(object_type: GType)
     -> *mut GraniteServicesContractor;
}
extern "C" {
    pub fn granite_services_contractor_get_contract(uri: *const gchar,
                                                    mime: *const gchar,
                                                    result_length1:
                                                        *mut ::std::os::raw::c_int)
     -> *mut *mut GHashTable;
}
extern "C" {
    pub fn granite_services_contractor_get_selection_contracts(locations:
                                                                   *mut *mut GHashTable,
                                                               locations_length1:
                                                                   ::std::os::raw::c_int,
                                                               result_length1:
                                                                   *mut ::std::os::raw::c_int)
     -> *mut *mut GHashTable;
}
extern "C" {
    pub fn granite_services_contract_get_type() -> GType;
}
extern "C" {
    pub fn granite_services_contract_get_display_name(self_:
                                                          *mut GraniteServicesContract)
     -> *mut gchar;
}
extern "C" {
    pub fn granite_services_contract_get_description(self_:
                                                         *mut GraniteServicesContract)
     -> *mut gchar;
}
extern "C" {
    pub fn granite_services_contract_get_icon(self_:
                                                  *mut GraniteServicesContract)
     -> *mut GIcon;
}
extern "C" {
    pub fn granite_services_contract_execute_with_file(self_:
                                                           *mut GraniteServicesContract,
                                                       file: *mut GFile,
                                                       error:
                                                           *mut *mut GError);
}
extern "C" {
    pub fn granite_services_contract_execute_with_files(self_:
                                                            *mut GraniteServicesContract,
                                                        files:
                                                            *mut *mut GFile,
                                                        files_length1:
                                                            ::std::os::raw::c_int,
                                                        error:
                                                            *mut *mut GError);
}
extern "C" {
    pub fn granite_services_contractor_error_quark() -> GQuark;
}
extern "C" {
    pub fn granite_services_contractor_proxy_get_type() -> GType;
}
extern "C" {
    pub fn granite_services_contractor_proxy_get_instance(error:
                                                              *mut *mut GError)
     -> *mut GraniteServicesContractorProxy;
}
extern "C" {
    pub fn granite_services_contractor_proxy_get_all_contracts(error:
                                                                   *mut *mut GError)
     -> *mut GeeList;
}
extern "C" {
    pub fn granite_services_contractor_proxy_get_contracts_by_mime(mime_type:
                                                                       *const gchar,
                                                                   error:
                                                                       *mut *mut GError)
     -> *mut GeeList;
}
extern "C" {
    pub fn granite_services_contractor_proxy_get_contracts_by_mimelist(mime_types:
                                                                           *mut *mut gchar,
                                                                       mime_types_length1:
                                                                           ::std::os::raw::c_int,
                                                                       error:
                                                                           *mut *mut GError)
     -> *mut GeeList;
}
extern "C" {
    pub fn granite_services_contractor_proxy_get_contracts_for_file(file:
                                                                        *mut GFile,
                                                                    error:
                                                                        *mut *mut GError)
     -> *mut GeeList;
}
extern "C" {
    pub fn granite_services_contractor_proxy_get_contracts_for_files(files:
                                                                         *mut *mut GFile,
                                                                     files_length1:
                                                                         ::std::os::raw::c_int,
                                                                     error:
                                                                         *mut *mut GError)
     -> *mut GeeList;
}
extern "C" {
    pub fn granite_services_icon_factory_get_type() -> GType;
}
extern "C" {
    pub fn granite_services_icon_factory_new()
     -> *mut GraniteServicesIconFactory;
}
extern "C" {
    pub fn granite_services_icon_factory_construct(object_type: GType)
     -> *mut GraniteServicesIconFactory;
}
extern "C" {
    pub fn granite_services_icon_factory_get_default()
     -> *mut GraniteServicesIconFactory;
}
extern "C" {
    pub fn granite_services_icon_factory_load_symbolic_icon_from_gicon(self_:
                                                                           *mut GraniteServicesIconFactory,
                                                                       style:
                                                                           *mut GtkStyleContext,
                                                                       gicon:
                                                                           *mut GIcon,
                                                                       size:
                                                                           gint)
     -> *mut GdkPixbuf;
}
extern "C" {
    pub fn granite_services_icon_factory_load_symbolic_icon(self_:
                                                                *mut GraniteServicesIconFactory,
                                                            style:
                                                                *mut GtkStyleContext,
                                                            iconname:
                                                                *const gchar,
                                                            size: gint)
     -> *mut GdkPixbuf;
}
extern "C" {
    pub fn granite_services_simple_command_get_type() -> GType;
}
extern "C" {
    pub fn granite_services_simple_command_new(dir: *const gchar,
                                               command: *const gchar)
     -> *mut GraniteServicesSimpleCommand;
}
extern "C" {
    pub fn granite_services_simple_command_construct(object_type: GType,
                                                     dir: *const gchar,
                                                     command: *const gchar)
     -> *mut GraniteServicesSimpleCommand;
}
extern "C" {
    pub fn granite_services_simple_command_run(self_:
                                                   *mut GraniteServicesSimpleCommand);
}
extern "C" {
    pub fn granite_widgets_alert_view_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_alert_view_new(title: *const gchar,
                                          description: *const gchar,
                                          icon_name: *const gchar)
     -> *mut GraniteWidgetsAlertView;
}
extern "C" {
    pub fn granite_widgets_alert_view_construct(object_type: GType,
                                                title: *const gchar,
                                                description: *const gchar,
                                                icon_name: *const gchar)
     -> *mut GraniteWidgetsAlertView;
}
extern "C" {
    pub fn granite_widgets_alert_view_show_action(self_:
                                                      *mut GraniteWidgetsAlertView,
                                                  label: *const gchar);
}
extern "C" {
    pub fn granite_widgets_alert_view_hide_action(self_:
                                                      *mut GraniteWidgetsAlertView);
}
extern "C" {
    pub fn granite_widgets_alert_view_get_title(self_:
                                                    *mut GraniteWidgetsAlertView)
     -> *const gchar;
}
extern "C" {
    pub fn granite_widgets_alert_view_set_title(self_:
                                                    *mut GraniteWidgetsAlertView,
                                                value: *const gchar);
}
extern "C" {
    pub fn granite_widgets_alert_view_get_description(self_:
                                                          *mut GraniteWidgetsAlertView)
     -> *const gchar;
}
extern "C" {
    pub fn granite_widgets_alert_view_set_description(self_:
                                                          *mut GraniteWidgetsAlertView,
                                                      value: *const gchar);
}
extern "C" {
    pub fn granite_widgets_alert_view_get_icon_name(self_:
                                                        *mut GraniteWidgetsAlertView)
     -> *mut gchar;
}
extern "C" {
    pub fn granite_widgets_alert_view_set_icon_name(self_:
                                                        *mut GraniteWidgetsAlertView,
                                                    value: *const gchar);
}
extern "C" {
    pub fn granite_widgets_avatar_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_avatar_new() -> *mut GraniteWidgetsAvatar;
}
extern "C" {
    pub fn granite_widgets_avatar_construct(object_type: GType)
     -> *mut GraniteWidgetsAvatar;
}
extern "C" {
    pub fn granite_widgets_avatar_new_from_pixbuf(pixbuf: *mut GdkPixbuf)
     -> *mut GraniteWidgetsAvatar;
}
extern "C" {
    pub fn granite_widgets_avatar_construct_from_pixbuf(object_type: GType,
                                                        pixbuf:
                                                            *mut GdkPixbuf)
     -> *mut GraniteWidgetsAvatar;
}
extern "C" {
    pub fn granite_widgets_avatar_new_from_file(filepath: *const gchar,
                                                pixel_size: gint)
     -> *mut GraniteWidgetsAvatar;
}
extern "C" {
    pub fn granite_widgets_avatar_construct_from_file(object_type: GType,
                                                      filepath: *const gchar,
                                                      pixel_size: gint)
     -> *mut GraniteWidgetsAvatar;
}
extern "C" {
    pub fn granite_widgets_avatar_new_with_default_icon(pixel_size: gint)
     -> *mut GraniteWidgetsAvatar;
}
extern "C" {
    pub fn granite_widgets_avatar_construct_with_default_icon(object_type:
                                                                  GType,
                                                              pixel_size:
                                                                  gint)
     -> *mut GraniteWidgetsAvatar;
}
extern "C" {
    pub fn granite_widgets_avatar_show_default(self_:
                                                   *mut GraniteWidgetsAvatar,
                                               pixel_size: gint);
}
extern "C" {
    pub fn granite_widgets_avatar_get_pixbuf(self_: *mut GraniteWidgetsAvatar)
     -> *mut GdkPixbuf;
}
extern "C" {
    pub fn granite_widgets_avatar_set_pixbuf(self_: *mut GraniteWidgetsAvatar,
                                             value: *mut GdkPixbuf);
}
extern "C" {
    pub fn granite_text_style_get_type() -> GType;
}
extern "C" {
    pub fn granite_text_style_get_stylesheet(self_: GraniteTextStyle,
                                             style_class: *mut *mut gchar)
     -> *mut gchar;
}
extern "C" {
    pub fn granite_close_button_position_get_type() -> GType;
}
extern "C" {
    pub fn granite_date_time_get_default_time_format(is_12h: gboolean,
                                                     with_second: gboolean)
     -> *mut gchar;
}
extern "C" {
    pub fn granite_date_time_get_default_date_format(with_weekday: gboolean,
                                                     with_day: gboolean,
                                                     with_year: gboolean)
     -> *mut gchar;
}
extern "C" {
    pub fn granite_widgets_utils_set_color_primary(window: *mut GtkWidget,
                                                   color: *mut GdkRGBA,
                                                   priority: gint)
     -> *mut GtkCssProvider;
}
extern "C" {
    pub fn granite_widgets_utils_set_theming(widget: *mut GtkWidget,
                                             stylesheet: *const gchar,
                                             class_name: *const gchar,
                                             priority: gint)
     -> *mut GtkCssProvider;
}
extern "C" {
    pub fn granite_widgets_utils_set_theming_for_screen(screen:
                                                            *mut GdkScreen,
                                                        stylesheet:
                                                            *const gchar,
                                                        priority: gint)
     -> *mut GtkCssProvider;
}
extern "C" {
    pub fn granite_widgets_utils_get_css_provider(stylesheet: *const gchar)
     -> *mut GtkCssProvider;
}
extern "C" {
    pub fn granite_widgets_utils_apply_text_style_to_label(text_style:
                                                               GraniteTextStyle,
                                                           label:
                                                               *mut GtkLabel);
}
extern "C" {
    pub fn granite_widgets_utils_get_default_close_button_position(position:
                                                                       *mut GraniteCloseButtonPosition)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_utils_get_button_layout_schema() -> *mut gchar;
}
extern "C" {
    pub fn granite_widgets_wrap_label_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_wrap_label_new(str: *const gchar)
     -> *mut GraniteWidgetsWrapLabel;
}
extern "C" {
    pub fn granite_widgets_wrap_label_construct(object_type: GType,
                                                str: *const gchar)
     -> *mut GraniteWidgetsWrapLabel;
}
extern "C" {
    pub fn granite_widgets_about_dialog_new()
     -> *mut GraniteWidgetsAboutDialog;
}
extern "C" {
    pub fn granite_widgets_about_dialog_construct(object_type: GType)
     -> *mut GraniteWidgetsAboutDialog;
}
extern "C" {
    pub fn granite_widgets_about_dialog_get_help(self_:
                                                     *mut GraniteWidgetsAboutDialog)
     -> *const gchar;
}
extern "C" {
    pub fn granite_widgets_about_dialog_set_help(self_:
                                                     *mut GraniteWidgetsAboutDialog,
                                                 value: *const gchar);
}
extern "C" {
    pub fn granite_widgets_about_dialog_get_translate(self_:
                                                          *mut GraniteWidgetsAboutDialog)
     -> *const gchar;
}
extern "C" {
    pub fn granite_widgets_about_dialog_set_translate(self_:
                                                          *mut GraniteWidgetsAboutDialog,
                                                      value: *const gchar);
}
extern "C" {
    pub fn granite_widgets_about_dialog_get_bug(self_:
                                                    *mut GraniteWidgetsAboutDialog)
     -> *const gchar;
}
extern "C" {
    pub fn granite_widgets_about_dialog_set_bug(self_:
                                                    *mut GraniteWidgetsAboutDialog,
                                                value: *const gchar);
}
extern "C" {
    pub fn granite_widgets_show_about_dialog(parent: *mut GtkWindow,
                                             first: *const gchar, ...);
}
extern "C" {
    pub fn granite_widgets_mode_button_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_mode_button_new() -> *mut GraniteWidgetsModeButton;
}
extern "C" {
    pub fn granite_widgets_mode_button_construct(object_type: GType)
     -> *mut GraniteWidgetsModeButton;
}
extern "C" {
    pub fn granite_widgets_mode_button_append_pixbuf(self_:
                                                         *mut GraniteWidgetsModeButton,
                                                     pixbuf: *mut GdkPixbuf)
     -> gint;
}
extern "C" {
    pub fn granite_widgets_mode_button_append_text(self_:
                                                       *mut GraniteWidgetsModeButton,
                                                   text: *const gchar)
     -> gint;
}
extern "C" {
    pub fn granite_widgets_mode_button_append_icon(self_:
                                                       *mut GraniteWidgetsModeButton,
                                                   icon_name: *const gchar,
                                                   size: GtkIconSize) -> gint;
}
extern "C" {
    pub fn granite_widgets_mode_button_append(self_:
                                                  *mut GraniteWidgetsModeButton,
                                              w: *mut GtkWidget) -> gint;
}
extern "C" {
    pub fn granite_widgets_mode_button_set_active(self_:
                                                      *mut GraniteWidgetsModeButton,
                                                  new_active_index: gint);
}
extern "C" {
    pub fn granite_widgets_mode_button_set_item_visible(self_:
                                                            *mut GraniteWidgetsModeButton,
                                                        index: gint,
                                                        val: gboolean);
}
extern "C" {
    pub fn granite_widgets_mode_button_remove(self_:
                                                  *mut GraniteWidgetsModeButton,
                                              index: gint);
}
extern "C" {
    pub fn granite_widgets_mode_button_clear_children(self_:
                                                          *mut GraniteWidgetsModeButton);
}
extern "C" {
    pub fn granite_widgets_mode_button_get_selected(self_:
                                                        *mut GraniteWidgetsModeButton)
     -> gint;
}
extern "C" {
    pub fn granite_widgets_mode_button_set_selected(self_:
                                                        *mut GraniteWidgetsModeButton,
                                                    value: gint);
}
extern "C" {
    pub fn granite_widgets_mode_button_get_n_items(self_:
                                                       *mut GraniteWidgetsModeButton)
     -> guint;
}
extern "C" {
    pub fn granite_widgets_date_picker_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_date_picker_new_with_format(format: *const gchar)
     -> *mut GraniteWidgetsDatePicker;
}
extern "C" {
    pub fn granite_widgets_date_picker_construct_with_format(object_type:
                                                                 GType,
                                                             format:
                                                                 *const gchar)
     -> *mut GraniteWidgetsDatePicker;
}
extern "C" {
    pub fn granite_widgets_date_picker_position_dropdown(self_:
                                                             *mut GraniteWidgetsDatePicker,
                                                         rect:
                                                             *mut GdkRectangle);
}
extern "C" {
    pub fn granite_widgets_date_picker_new() -> *mut GraniteWidgetsDatePicker;
}
extern "C" {
    pub fn granite_widgets_date_picker_construct(object_type: GType)
     -> *mut GraniteWidgetsDatePicker;
}
extern "C" {
    pub fn granite_widgets_date_picker_get_format(self_:
                                                      *mut GraniteWidgetsDatePicker)
     -> *const gchar;
}
extern "C" {
    pub fn granite_widgets_date_picker_get_date(self_:
                                                    *mut GraniteWidgetsDatePicker)
     -> *mut GDateTime;
}
extern "C" {
    pub fn granite_widgets_date_picker_set_date(self_:
                                                    *mut GraniteWidgetsDatePicker,
                                                value: *mut GDateTime);
}
extern "C" {
    pub fn granite_widgets_hinted_entry_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_hinted_entry_new(hint_string: *const gchar)
     -> *mut GraniteWidgetsHintedEntry;
}
extern "C" {
    pub fn granite_widgets_hinted_entry_construct(object_type: GType,
                                                  hint_string: *const gchar)
     -> *mut GraniteWidgetsHintedEntry;
}
extern "C" {
    pub fn granite_widgets_hinted_entry_hint(self_:
                                                 *mut GraniteWidgetsHintedEntry);
}
extern "C" {
    pub fn granite_widgets_hinted_entry_unhint(self_:
                                                   *mut GraniteWidgetsHintedEntry);
}
extern "C" {
    pub fn granite_widgets_hinted_entry_get_text(self_:
                                                     *mut GraniteWidgetsHintedEntry)
     -> *mut gchar;
}
extern "C" {
    pub fn granite_widgets_hinted_entry_set_text(self_:
                                                     *mut GraniteWidgetsHintedEntry,
                                                 text: *const gchar);
}
extern "C" {
    pub fn granite_widgets_hinted_entry_get_has_clear_icon(self_:
                                                               *mut GraniteWidgetsHintedEntry)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_hinted_entry_set_has_clear_icon(self_:
                                                               *mut GraniteWidgetsHintedEntry,
                                                           value: gboolean);
}
extern "C" {
    pub fn granite_widgets_hinted_entry_get_hint_string(self_:
                                                            *mut GraniteWidgetsHintedEntry)
     -> *const gchar;
}
extern "C" {
    pub fn granite_widgets_hinted_entry_set_hint_string(self_:
                                                            *mut GraniteWidgetsHintedEntry,
                                                        value: *const gchar);
}
extern "C" {
    pub fn granite_widgets_search_bar_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_search_bar_new(hint_string: *const gchar)
     -> *mut GraniteWidgetsSearchBar;
}
extern "C" {
    pub fn granite_widgets_search_bar_construct(object_type: GType,
                                                hint_string: *const gchar)
     -> *mut GraniteWidgetsSearchBar;
}
extern "C" {
    pub fn granite_widgets_search_bar_get_pause_delay(self_:
                                                          *mut GraniteWidgetsSearchBar)
     -> gint;
}
extern "C" {
    pub fn granite_widgets_search_bar_set_pause_delay(self_:
                                                          *mut GraniteWidgetsSearchBar,
                                                      value: gint);
}
extern "C" {
    pub fn granite_widgets_time_picker_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_time_picker_new_with_format(format_12:
                                                           *const gchar,
                                                       format_24:
                                                           *const gchar)
     -> *mut GraniteWidgetsTimePicker;
}
extern "C" {
    pub fn granite_widgets_time_picker_construct_with_format(object_type:
                                                                 GType,
                                                             format_12:
                                                                 *const gchar,
                                                             format_24:
                                                                 *const gchar)
     -> *mut GraniteWidgetsTimePicker;
}
extern "C" {
    pub fn granite_widgets_time_picker_position_dropdown(self_:
                                                             *mut GraniteWidgetsTimePicker,
                                                         x: *mut gint,
                                                         y: *mut gint);
}
extern "C" {
    pub fn granite_widgets_time_picker_new() -> *mut GraniteWidgetsTimePicker;
}
extern "C" {
    pub fn granite_widgets_time_picker_construct(object_type: GType)
     -> *mut GraniteWidgetsTimePicker;
}
extern "C" {
    pub fn granite_widgets_time_picker_get_format_12(self_:
                                                         *mut GraniteWidgetsTimePicker)
     -> *const gchar;
}
extern "C" {
    pub fn granite_widgets_time_picker_get_format_24(self_:
                                                         *mut GraniteWidgetsTimePicker)
     -> *const gchar;
}
extern "C" {
    pub fn granite_widgets_time_picker_get_time(self_:
                                                    *mut GraniteWidgetsTimePicker)
     -> *mut GDateTime;
}
extern "C" {
    pub fn granite_widgets_time_picker_set_time(self_:
                                                    *mut GraniteWidgetsTimePicker,
                                                value: *mut GDateTime);
}
extern "C" {
    pub fn granite_collapse_mode_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_collapsible_paned_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_collapsible_paned_new(orientation: GtkOrientation)
     -> *mut GraniteWidgetsCollapsiblePaned;
}
extern "C" {
    pub fn granite_widgets_collapsible_paned_construct(object_type: GType,
                                                       orientation:
                                                           GtkOrientation)
     -> *mut GraniteWidgetsCollapsiblePaned;
}
extern "C" {
    pub fn granite_widgets_collapsible_paned_get_collapse_mode(self_:
                                                                   *mut GraniteWidgetsCollapsiblePaned)
     -> GraniteCollapseMode;
}
extern "C" {
    pub fn granite_widgets_collapsible_paned_set_collapse_mode(self_:
                                                                   *mut GraniteWidgetsCollapsiblePaned,
                                                               value:
                                                                   GraniteCollapseMode);
}
extern "C" {
    pub fn granite_widgets_hcollapsable_paned_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_hcollapsable_paned_new()
     -> *mut GraniteWidgetsHCollapsablePaned;
}
extern "C" {
    pub fn granite_widgets_hcollapsable_paned_construct(object_type: GType)
     -> *mut GraniteWidgetsHCollapsablePaned;
}
extern "C" {
    pub fn granite_widgets_vcollapsable_paned_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_vcollapsable_paned_new()
     -> *mut GraniteWidgetsVCollapsablePaned;
}
extern "C" {
    pub fn granite_widgets_vcollapsable_paned_construct(object_type: GType)
     -> *mut GraniteWidgetsVCollapsablePaned;
}
extern "C" {
    pub fn granite_widgets_static_notebook_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_static_notebook_new(show_separator: gboolean)
     -> *mut GraniteWidgetsStaticNotebook;
}
extern "C" {
    pub fn granite_widgets_static_notebook_construct(object_type: GType,
                                                     show_separator: gboolean)
     -> *mut GraniteWidgetsStaticNotebook;
}
extern "C" {
    pub fn granite_widgets_static_notebook_set_switcher_visible(self_:
                                                                    *mut GraniteWidgetsStaticNotebook,
                                                                val:
                                                                    gboolean);
}
extern "C" {
    pub fn granite_widgets_static_notebook_append_page(self_:
                                                           *mut GraniteWidgetsStaticNotebook,
                                                       widget: *mut GtkWidget,
                                                       label: *mut GtkLabel)
     -> gint;
}
extern "C" {
    pub fn granite_widgets_static_notebook_remove_page(self_:
                                                           *mut GraniteWidgetsStaticNotebook,
                                                       number: gint);
}
extern "C" {
    pub fn granite_widgets_static_notebook_get_page(self_:
                                                        *mut GraniteWidgetsStaticNotebook)
     -> gint;
}
extern "C" {
    pub fn granite_widgets_static_notebook_set_page(self_:
                                                        *mut GraniteWidgetsStaticNotebook,
                                                    value: gint);
}
extern "C" {
    pub fn granite_widgets_tab_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_tab_page_container_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_tab_new(label: *const gchar, icon: *mut GIcon,
                                   page: *mut GtkWidget)
     -> *mut GraniteWidgetsTab;
}
extern "C" {
    pub fn granite_widgets_tab_construct(object_type: GType,
                                         label: *const gchar,
                                         icon: *mut GIcon,
                                         page: *mut GtkWidget)
     -> *mut GraniteWidgetsTab;
}
extern "C" {
    pub fn granite_widgets_tab_close(self_: *mut GraniteWidgetsTab);
}
extern "C" {
    pub fn granite_widgets_tab_get_label(self_: *mut GraniteWidgetsTab)
     -> *const gchar;
}
extern "C" {
    pub fn granite_widgets_tab_set_label(self_: *mut GraniteWidgetsTab,
                                         value: *const gchar);
}
extern "C" {
    pub fn granite_widgets_tab_get_pinned(self_: *mut GraniteWidgetsTab)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_tab_set_pinned(self_: *mut GraniteWidgetsTab,
                                          value: gboolean);
}
extern "C" {
    pub fn granite_widgets_tab_get_pinnable(self_: *mut GraniteWidgetsTab)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_tab_set_pinnable(self_: *mut GraniteWidgetsTab,
                                            value: gboolean);
}
extern "C" {
    pub fn granite_widgets_tab_get_restore_data(self_: *mut GraniteWidgetsTab)
     -> *const gchar;
}
extern "C" {
    pub fn granite_widgets_tab_set_restore_data(self_: *mut GraniteWidgetsTab,
                                                value: *const gchar);
}
extern "C" {
    pub fn granite_widgets_tab_get_page(self_: *mut GraniteWidgetsTab)
     -> *mut GtkWidget;
}
extern "C" {
    pub fn granite_widgets_tab_set_page(self_: *mut GraniteWidgetsTab,
                                        value: *mut GtkWidget);
}
extern "C" {
    pub fn granite_widgets_tab_get_icon(self_: *mut GraniteWidgetsTab)
     -> *mut GIcon;
}
extern "C" {
    pub fn granite_widgets_tab_set_icon(self_: *mut GraniteWidgetsTab,
                                        value: *mut GIcon);
}
extern "C" {
    pub fn granite_widgets_tab_get_working(self_: *mut GraniteWidgetsTab)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_tab_set_working(self_: *mut GraniteWidgetsTab,
                                           value: gboolean);
}
extern "C" {
    pub fn granite_widgets_tab_get_ellipsize_mode(self_:
                                                      *mut GraniteWidgetsTab)
     -> PangoEllipsizeMode;
}
extern "C" {
    pub fn granite_widgets_tab_set_ellipsize_mode(self_:
                                                      *mut GraniteWidgetsTab,
                                                  value: PangoEllipsizeMode);
}
extern "C" {
    pub fn granite_widgets_tab_get_fixed(self_: *mut GraniteWidgetsTab)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_tab_set_fixed(self_: *mut GraniteWidgetsTab,
                                         value: gboolean);
}
extern "C" {
    pub fn granite_widgets_tab_get_menu(self_: *mut GraniteWidgetsTab)
     -> *mut GtkMenu;
}
extern "C" {
    pub fn granite_widgets_tab_set_menu(self_: *mut GraniteWidgetsTab,
                                        value: *mut GtkMenu);
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_tab_bar_behavior_get_type()
     -> GType;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_new()
     -> *mut GraniteWidgetsDynamicNotebook;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_construct(object_type: GType)
     -> *mut GraniteWidgetsDynamicNotebook;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_remove_tab(self_:
                                                           *mut GraniteWidgetsDynamicNotebook,
                                                       tab:
                                                           *mut GraniteWidgetsTab);
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_next_page(self_:
                                                          *mut GraniteWidgetsDynamicNotebook);
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_previous_page(self_:
                                                              *mut GraniteWidgetsDynamicNotebook);
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_get_children(self_:
                                                             *mut GraniteWidgetsDynamicNotebook)
     -> *mut GList;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_get_tab_position(self_:
                                                                 *mut GraniteWidgetsDynamicNotebook,
                                                             tab:
                                                                 *mut GraniteWidgetsTab)
     -> gint;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_set_tab_position(self_:
                                                                 *mut GraniteWidgetsDynamicNotebook,
                                                             tab:
                                                                 *mut GraniteWidgetsTab,
                                                             position: gint);
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_get_tab_by_index(self_:
                                                                 *mut GraniteWidgetsDynamicNotebook,
                                                             index: gint)
     -> *mut GraniteWidgetsTab;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_get_tab_by_widget(self_:
                                                                  *mut GraniteWidgetsDynamicNotebook,
                                                              widget:
                                                                  *mut GtkWidget)
     -> *mut GraniteWidgetsTab;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_get_nth_page(self_:
                                                             *mut GraniteWidgetsDynamicNotebook,
                                                         index: gint)
     -> *mut GtkWidget;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_insert_tab(self_:
                                                           *mut GraniteWidgetsDynamicNotebook,
                                                       tab:
                                                           *mut GraniteWidgetsTab,
                                                       index: gint) -> guint;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_get_n_tabs(self_:
                                                           *mut GraniteWidgetsDynamicNotebook)
     -> gint;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_get_show_tabs(self_:
                                                              *mut GraniteWidgetsDynamicNotebook)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_set_show_tabs(self_:
                                                              *mut GraniteWidgetsDynamicNotebook,
                                                          value: gboolean);
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_get_show_icons(self_:
                                                               *mut GraniteWidgetsDynamicNotebook)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_set_show_icons(self_:
                                                               *mut GraniteWidgetsDynamicNotebook,
                                                           value: gboolean);
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_get_tabs_closable(self_:
                                                                  *mut GraniteWidgetsDynamicNotebook)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_set_tabs_closable(self_:
                                                                  *mut GraniteWidgetsDynamicNotebook,
                                                              value:
                                                                  gboolean);
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_get_allow_drag(self_:
                                                               *mut GraniteWidgetsDynamicNotebook)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_set_allow_drag(self_:
                                                               *mut GraniteWidgetsDynamicNotebook,
                                                           value: gboolean);
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_get_allow_new_window(self_:
                                                                     *mut GraniteWidgetsDynamicNotebook)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_set_allow_new_window(self_:
                                                                     *mut GraniteWidgetsDynamicNotebook,
                                                                 value:
                                                                     gboolean);
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_get_allow_duplication(self_:
                                                                      *mut GraniteWidgetsDynamicNotebook)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_set_allow_duplication(self_:
                                                                      *mut GraniteWidgetsDynamicNotebook,
                                                                  value:
                                                                      gboolean);
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_get_allow_restoring(self_:
                                                                    *mut GraniteWidgetsDynamicNotebook)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_set_allow_restoring(self_:
                                                                    *mut GraniteWidgetsDynamicNotebook,
                                                                value:
                                                                    gboolean);
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_get_max_restorable_tabs(self_:
                                                                        *mut GraniteWidgetsDynamicNotebook)
     -> gint;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_set_max_restorable_tabs(self_:
                                                                        *mut GraniteWidgetsDynamicNotebook,
                                                                    value:
                                                                        gint);
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_get_add_button_visible(self_:
                                                                       *mut GraniteWidgetsDynamicNotebook)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_set_add_button_visible(self_:
                                                                       *mut GraniteWidgetsDynamicNotebook,
                                                                   value:
                                                                       gboolean);
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_get_allow_pinning(self_:
                                                                  *mut GraniteWidgetsDynamicNotebook)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_set_allow_pinning(self_:
                                                                  *mut GraniteWidgetsDynamicNotebook,
                                                              value:
                                                                  gboolean);
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_get_force_left(self_:
                                                               *mut GraniteWidgetsDynamicNotebook)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_set_force_left(self_:
                                                               *mut GraniteWidgetsDynamicNotebook,
                                                           value: gboolean);
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_get_add_button_tooltip(self_:
                                                                       *mut GraniteWidgetsDynamicNotebook)
     -> *const gchar;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_set_add_button_tooltip(self_:
                                                                       *mut GraniteWidgetsDynamicNotebook,
                                                                   value:
                                                                       *const gchar);
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_get_current(self_:
                                                            *mut GraniteWidgetsDynamicNotebook)
     -> *mut GraniteWidgetsTab;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_set_current(self_:
                                                            *mut GraniteWidgetsDynamicNotebook,
                                                        value:
                                                            *mut GraniteWidgetsTab);
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_get_tabs(self_:
                                                         *mut GraniteWidgetsDynamicNotebook)
     -> *mut GList;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_get_group_name(self_:
                                                               *mut GraniteWidgetsDynamicNotebook)
     -> *const gchar;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_set_group_name(self_:
                                                               *mut GraniteWidgetsDynamicNotebook,
                                                           value:
                                                               *const gchar);
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_get_tab_bar_behavior(self_:
                                                                     *mut GraniteWidgetsDynamicNotebook)
     -> GraniteWidgetsDynamicNotebookTabBarBehavior;
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_set_tab_bar_behavior(self_:
                                                                     *mut GraniteWidgetsDynamicNotebook,
                                                                 value:
                                                                     GraniteWidgetsDynamicNotebookTabBarBehavior);
}
extern "C" {
    pub fn granite_widgets_dynamic_notebook_get_menu(self_:
                                                         *mut GraniteWidgetsDynamicNotebook)
     -> *mut GtkMenu;
}
extern "C" {
    pub fn granite_widgets_composited_window_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_composited_window_new()
     -> *mut GraniteWidgetsCompositedWindow;
}
extern "C" {
    pub fn granite_widgets_composited_window_construct(object_type: GType)
     -> *mut GraniteWidgetsCompositedWindow;
}
extern "C" {
    pub fn granite_widgets_app_menu_new(menu: *mut GtkMenu)
     -> *mut GraniteWidgetsAppMenu;
}
extern "C" {
    pub fn granite_widgets_app_menu_construct(object_type: GType,
                                              menu: *mut GtkMenu)
     -> *mut GraniteWidgetsAppMenu;
}
extern "C" {
    pub fn granite_widgets_app_menu_new_with_app(application:
                                                     *mut GraniteApplication,
                                                 menu: *mut GtkMenu)
     -> *mut GraniteWidgetsAppMenu;
}
extern "C" {
    pub fn granite_widgets_app_menu_construct_with_app(object_type: GType,
                                                       application:
                                                           *mut GraniteApplication,
                                                       menu: *mut GtkMenu)
     -> *mut GraniteWidgetsAppMenu;
}
extern "C" {
    pub fn granite_widgets_app_menu_new_with_urls(menu: *mut GtkMenu,
                                                  help_url: *const gchar,
                                                  translate_url: *const gchar,
                                                  bug_url: *const gchar)
     -> *mut GraniteWidgetsAppMenu;
}
extern "C" {
    pub fn granite_widgets_app_menu_construct_with_urls(object_type: GType,
                                                        menu: *mut GtkMenu,
                                                        help_url:
                                                            *const gchar,
                                                        translate_url:
                                                            *const gchar,
                                                        bug_url: *const gchar)
     -> *mut GraniteWidgetsAppMenu;
}
extern "C" {
    pub fn granite_widgets_app_menu_add_items(self_:
                                                  *mut GraniteWidgetsAppMenu,
                                              menu: *mut GtkMenu);
}
extern "C" {
    pub fn granite_widgets_welcome_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_welcome_new(title_text: *const gchar,
                                       subtitle_text: *const gchar)
     -> *mut GraniteWidgetsWelcome;
}
extern "C" {
    pub fn granite_widgets_welcome_construct(object_type: GType,
                                             title_text: *const gchar,
                                             subtitle_text: *const gchar)
     -> *mut GraniteWidgetsWelcome;
}
extern "C" {
    pub fn granite_widgets_welcome_set_item_visible(self_:
                                                        *mut GraniteWidgetsWelcome,
                                                    index: guint,
                                                    val: gboolean);
}
extern "C" {
    pub fn granite_widgets_welcome_remove_item(self_:
                                                   *mut GraniteWidgetsWelcome,
                                               index: guint);
}
extern "C" {
    pub fn granite_widgets_welcome_set_item_sensitivity(self_:
                                                            *mut GraniteWidgetsWelcome,
                                                        index: guint,
                                                        val: gboolean);
}
extern "C" {
    pub fn granite_widgets_welcome_append(self_: *mut GraniteWidgetsWelcome,
                                          icon_name: *const gchar,
                                          option_text: *const gchar,
                                          description_text: *const gchar)
     -> gint;
}
extern "C" {
    pub fn granite_widgets_welcome_append_with_pixbuf(self_:
                                                          *mut GraniteWidgetsWelcome,
                                                      pixbuf: *mut GdkPixbuf,
                                                      option_text:
                                                          *const gchar,
                                                      description_text:
                                                          *const gchar)
     -> gint;
}
extern "C" {
    pub fn granite_widgets_welcome_append_with_image(self_:
                                                         *mut GraniteWidgetsWelcome,
                                                     image: *mut GtkImage,
                                                     option_text:
                                                         *const gchar,
                                                     description_text:
                                                         *const gchar)
     -> gint;
}
extern "C" {
    pub fn granite_widgets_welcome_button_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_welcome_get_button_from_index(self_:
                                                             *mut GraniteWidgetsWelcome,
                                                         index: gint)
     -> *mut GraniteWidgetsWelcomeButton;
}
extern "C" {
    pub fn granite_widgets_welcome_get_title(self_:
                                                 *mut GraniteWidgetsWelcome)
     -> *const gchar;
}
extern "C" {
    pub fn granite_widgets_welcome_set_title(self_:
                                                 *mut GraniteWidgetsWelcome,
                                             value: *const gchar);
}
extern "C" {
    pub fn granite_widgets_welcome_get_subtitle(self_:
                                                    *mut GraniteWidgetsWelcome)
     -> *const gchar;
}
extern "C" {
    pub fn granite_widgets_welcome_set_subtitle(self_:
                                                    *mut GraniteWidgetsWelcome,
                                                value: *const gchar);
}
extern "C" {
    pub fn granite_widgets_welcome_button_new(image: *mut GtkImage,
                                              option_text: *const gchar,
                                              description_text: *const gchar)
     -> *mut GraniteWidgetsWelcomeButton;
}
extern "C" {
    pub fn granite_widgets_welcome_button_construct(object_type: GType,
                                                    image: *mut GtkImage,
                                                    option_text: *const gchar,
                                                    description_text:
                                                        *const gchar)
     -> *mut GraniteWidgetsWelcomeButton;
}
extern "C" {
    pub fn granite_widgets_welcome_button_get_title(self_:
                                                        *mut GraniteWidgetsWelcomeButton)
     -> *const gchar;
}
extern "C" {
    pub fn granite_widgets_welcome_button_set_title(self_:
                                                        *mut GraniteWidgetsWelcomeButton,
                                                    value: *const gchar);
}
extern "C" {
    pub fn granite_widgets_welcome_button_get_description(self_:
                                                              *mut GraniteWidgetsWelcomeButton)
     -> *const gchar;
}
extern "C" {
    pub fn granite_widgets_welcome_button_set_description(self_:
                                                              *mut GraniteWidgetsWelcomeButton,
                                                          value:
                                                              *const gchar);
}
extern "C" {
    pub fn granite_widgets_welcome_button_get_icon(self_:
                                                       *mut GraniteWidgetsWelcomeButton)
     -> *mut GtkImage;
}
extern "C" {
    pub fn granite_widgets_welcome_button_set_icon(self_:
                                                       *mut GraniteWidgetsWelcomeButton,
                                                   value: *mut GtkImage);
}
extern "C" {
    pub fn granite_widgets_toast_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_toast_new(title: *const gchar)
     -> *mut GraniteWidgetsToast;
}
extern "C" {
    pub fn granite_widgets_toast_construct(object_type: GType,
                                           title: *const gchar)
     -> *mut GraniteWidgetsToast;
}
extern "C" {
    pub fn granite_widgets_toast_set_default_action(self_:
                                                        *mut GraniteWidgetsToast,
                                                    label: *const gchar);
}
extern "C" {
    pub fn granite_widgets_toast_send_notification(self_:
                                                       *mut GraniteWidgetsToast);
}
extern "C" {
    pub fn granite_widgets_toast_get_title(self_: *mut GraniteWidgetsToast)
     -> *const gchar;
}
extern "C" {
    pub fn granite_widgets_toast_set_title(self_: *mut GraniteWidgetsToast,
                                           value: *const gchar);
}
extern "C" {
    pub fn granite_widgets_tool_button_with_menu_vmenu_position_get_type()
     -> GType;
}
extern "C" {
    pub fn granite_widgets_tool_button_with_menu_hmenu_position_get_type()
     -> GType;
}
extern "C" {
    pub fn granite_widgets_tool_button_with_menu_new_from_action(action:
                                                                     *mut GtkAction)
     -> *mut GraniteWidgetsToolButtonWithMenu;
}
extern "C" {
    pub fn granite_widgets_tool_button_with_menu_construct_from_action(object_type:
                                                                           GType,
                                                                       action:
                                                                           *mut GtkAction)
     -> *mut GraniteWidgetsToolButtonWithMenu;
}
extern "C" {
    pub fn granite_widgets_tool_button_with_menu_new_from_stock(stock_image:
                                                                    *const gchar,
                                                                size:
                                                                    GtkIconSize,
                                                                label:
                                                                    *const gchar,
                                                                menu:
                                                                    *mut GtkMenu)
     -> *mut GraniteWidgetsToolButtonWithMenu;
}
extern "C" {
    pub fn granite_widgets_tool_button_with_menu_construct_from_stock(object_type:
                                                                          GType,
                                                                      stock_image:
                                                                          *const gchar,
                                                                      size:
                                                                          GtkIconSize,
                                                                      label:
                                                                          *const gchar,
                                                                      menu:
                                                                          *mut GtkMenu)
     -> *mut GraniteWidgetsToolButtonWithMenu;
}
extern "C" {
    pub fn granite_widgets_tool_button_with_menu_new(image: *mut GtkImage,
                                                     label: *const gchar,
                                                     menu: *mut GtkMenu)
     -> *mut GraniteWidgetsToolButtonWithMenu;
}
extern "C" {
    pub fn granite_widgets_tool_button_with_menu_construct(object_type: GType,
                                                           image:
                                                               *mut GtkImage,
                                                           label:
                                                               *const gchar,
                                                           menu: *mut GtkMenu)
     -> *mut GraniteWidgetsToolButtonWithMenu;
}
extern "C" {
    pub fn granite_widgets_tool_button_with_menu_popup_menu(self_:
                                                                *mut GraniteWidgetsToolButtonWithMenu,
                                                            ev:
                                                                *mut GdkEventButton);
}
extern "C" {
    pub fn granite_widgets_tool_button_with_menu_popdown_menu(self_:
                                                                  *mut GraniteWidgetsToolButtonWithMenu);
}
extern "C" {
    pub fn granite_widgets_tool_button_with_menu_get_horizontal_menu_position(self_:
                                                                                  *mut GraniteWidgetsToolButtonWithMenu)
     -> GraniteWidgetsToolButtonWithMenuHMenuPosition;
}
extern "C" {
    pub fn granite_widgets_tool_button_with_menu_set_horizontal_menu_position(self_:
                                                                                  *mut GraniteWidgetsToolButtonWithMenu,
                                                                              value:
                                                                                  GraniteWidgetsToolButtonWithMenuHMenuPosition);
}
extern "C" {
    pub fn granite_widgets_tool_button_with_menu_get_vertical_menu_position(self_:
                                                                                *mut GraniteWidgetsToolButtonWithMenu)
     -> GraniteWidgetsToolButtonWithMenuVMenuPosition;
}
extern "C" {
    pub fn granite_widgets_tool_button_with_menu_set_vertical_menu_position(self_:
                                                                                *mut GraniteWidgetsToolButtonWithMenu,
                                                                            value:
                                                                                GraniteWidgetsToolButtonWithMenuVMenuPosition);
}
extern "C" {
    pub fn granite_widgets_tool_button_with_menu_get_fetcher(self_:
                                                                 *mut GraniteWidgetsToolButtonWithMenu,
                                                             result_target:
                                                                 *mut gpointer)
     -> GraniteWidgetsToolButtonWithMenuMenuFetcher;
}
extern "C" {
    pub fn granite_widgets_tool_button_with_menu_set_fetcher(self_:
                                                                 *mut GraniteWidgetsToolButtonWithMenu,
                                                             value:
                                                                 GraniteWidgetsToolButtonWithMenuMenuFetcher,
                                                             value_target:
                                                                 gpointer);
}
extern "C" {
    pub fn granite_widgets_tool_button_with_menu_get_menu(self_:
                                                              *mut GraniteWidgetsToolButtonWithMenu)
     -> *mut GtkMenu;
}
extern "C" {
    pub fn granite_widgets_tool_button_with_menu_set_menu(self_:
                                                              *mut GraniteWidgetsToolButtonWithMenu,
                                                          value:
                                                              *mut GtkMenu);
}
extern "C" {
    pub fn granite_widgets_pop_over_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_pop_over_pop_position_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_pop_over_new() -> *mut GraniteWidgetsPopOver;
}
extern "C" {
    pub fn granite_widgets_pop_over_construct(object_type: GType)
     -> *mut GraniteWidgetsPopOver;
}
extern "C" {
    pub fn granite_widgets_pop_over_reset_buffers(self_:
                                                      *mut GraniteWidgetsPopOver);
}
extern "C" {
    pub fn granite_widgets_pop_over_set_parent_pop(self_:
                                                       *mut GraniteWidgetsPopOver,
                                                   win: *mut GtkWindow);
}
extern "C" {
    pub fn granite_widgets_pop_over_move_to_widget(self_:
                                                       *mut GraniteWidgetsPopOver,
                                                   w: *mut GtkWidget,
                                                   show: gboolean);
}
extern "C" {
    pub fn granite_widgets_pop_over_move_to_coords(self_:
                                                       *mut GraniteWidgetsPopOver,
                                                   x: gint, y: gint,
                                                   show: gboolean);
}
extern "C" {
    pub fn granite_widgets_pop_over_move_to_rect(self_:
                                                     *mut GraniteWidgetsPopOver,
                                                 rect: *mut GdkRectangle,
                                                 show: gboolean);
}
extern "C" {
    pub fn granite_widgets_pop_over_move_to_window(self_:
                                                       *mut GraniteWidgetsPopOver,
                                                   window: *mut GdkWindow);
}
extern "C" {
    pub fn granite_widgets_pop_over_cairo_popover(self_:
                                                      *mut GraniteWidgetsPopOver,
                                                  cr: *mut cairo_t,
                                                  x: gdouble, y: gdouble,
                                                  width: gdouble,
                                                  height: gdouble,
                                                  border_radius: gdouble);
}
extern "C" {
    pub fn granite_widgets_contractor_view_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_contractor_view_new(filename: *const gchar,
                                               mime: *const gchar,
                                               icon_size: gint,
                                               show_contract_name: gboolean)
     -> *mut GraniteWidgetsContractorView;
}
extern "C" {
    pub fn granite_widgets_contractor_view_construct(object_type: GType,
                                                     filename: *const gchar,
                                                     mime: *const gchar,
                                                     icon_size: gint,
                                                     show_contract_name:
                                                         gboolean)
     -> *mut GraniteWidgetsContractorView;
}
extern "C" {
    pub fn granite_widgets_contractor_view_add_item(self_:
                                                        *mut GraniteWidgetsContractorView,
                                                    name: *const gchar,
                                                    desc: *const gchar,
                                                    icon_name: *const gchar,
                                                    icon_size: gint,
                                                    position: gint,
                                                    method:
                                                        GraniteWidgetsContractorViewContractCallback,
                                                    method_target:
                                                        *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn granite_widgets_contractor_view_name_blacklist(self_:
                                                              *mut GraniteWidgetsContractorView,
                                                          names:
                                                              *mut *mut gchar,
                                                          names_length1:
                                                              ::std::os::raw::c_int);
}
extern "C" {
    pub fn granite_widgets_contractor_view_run_selected(self_:
                                                            *mut GraniteWidgetsContractorView);
}
extern "C" {
    pub fn granite_widgets_contractor_view_get_selected(self_:
                                                            *mut GraniteWidgetsContractorView)
     -> gint;
}
extern "C" {
    pub fn granite_widgets_contractor_view_set_selected(self_:
                                                            *mut GraniteWidgetsContractorView,
                                                        value: gint);
}
extern "C" {
    pub fn granite_widgets_contractor_menu_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_contractor_menu_new(filename: *const gchar,
                                               mime: *const gchar)
     -> *mut GraniteWidgetsContractorMenu;
}
extern "C" {
    pub fn granite_widgets_contractor_menu_construct(object_type: GType,
                                                     filename: *const gchar,
                                                     mime: *const gchar)
     -> *mut GraniteWidgetsContractorMenu;
}
extern "C" {
    pub fn granite_widgets_contractor_menu_add_item(self_:
                                                        *mut GraniteWidgetsContractorMenu,
                                                    name: *const gchar,
                                                    icon_name: *const gchar,
                                                    position: gint,
                                                    method:
                                                        GraniteWidgetsContractorMenuContractCallback,
                                                    method_target:
                                                        *mut ::std::os::raw::c_void,
                                                    use_stock: gboolean);
}
extern "C" {
    pub fn granite_widgets_contractor_menu_name_blacklist(self_:
                                                              *mut GraniteWidgetsContractorMenu,
                                                          names:
                                                              *mut *mut gchar,
                                                          names_length1:
                                                              ::std::os::raw::c_int);
}
extern "C" {
    pub fn granite_widgets_contractor_menu_update(self_:
                                                      *mut GraniteWidgetsContractorMenu,
                                                  filename: *const gchar,
                                                  mime: *const gchar);
}
extern "C" {
    pub fn granite_widgets_decorated_window_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_decorated_window_set_default_theming(ref_window:
                                                                    *mut GtkWindow);
}
extern "C" {
    pub fn granite_widgets_decorated_window_new(title: *const gchar,
                                                window_style: *const gchar,
                                                content_style: *const gchar)
     -> *mut GraniteWidgetsDecoratedWindow;
}
extern "C" {
    pub fn granite_widgets_decorated_window_construct(object_type: GType,
                                                      title: *const gchar,
                                                      window_style:
                                                          *const gchar,
                                                      content_style:
                                                          *const gchar)
     -> *mut GraniteWidgetsDecoratedWindow;
}
extern "C" {
    pub fn granite_widgets_decorated_window_add(self_:
                                                    *mut GraniteWidgetsDecoratedWindow,
                                                w: *mut GtkWidget);
}
extern "C" {
    pub fn granite_widgets_decorated_window_remove(self_:
                                                       *mut GraniteWidgetsDecoratedWindow,
                                                   w: *mut GtkWidget);
}
extern "C" {
    pub fn granite_widgets_decorated_window_get_show_title(self_:
                                                               *mut GraniteWidgetsDecoratedWindow)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_decorated_window_set_show_title(self_:
                                                               *mut GraniteWidgetsDecoratedWindow,
                                                           value: gboolean);
}
extern "C" {
    pub fn granite_widgets_decorated_window_get_box(self_:
                                                        *mut GraniteWidgetsDecoratedWindow)
     -> *mut GtkBox;
}
extern "C" {
    pub fn granite_widgets_decorated_window_get_draw_ref(self_:
                                                             *mut GraniteWidgetsDecoratedWindow)
     -> *mut GtkWindow;
}
extern "C" {
    pub fn granite_widgets_light_window_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_light_window_new(title: *const gchar)
     -> *mut GraniteWidgetsLightWindow;
}
extern "C" {
    pub fn granite_widgets_light_window_construct(object_type: GType,
                                                  title: *const gchar)
     -> *mut GraniteWidgetsLightWindow;
}
extern "C" {
    pub fn granite_widgets_status_bar_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_status_bar_new() -> *mut GraniteWidgetsStatusBar;
}
extern "C" {
    pub fn granite_widgets_status_bar_construct(object_type: GType)
     -> *mut GraniteWidgetsStatusBar;
}
extern "C" {
    pub fn granite_widgets_status_bar_insert_widget(self_:
                                                        *mut GraniteWidgetsStatusBar,
                                                    widget: *mut GtkWidget,
                                                    use_left_side: gboolean);
}
extern "C" {
    pub fn granite_widgets_status_bar_set_text(self_:
                                                   *mut GraniteWidgetsStatusBar,
                                               text: *const gchar);
}
extern "C" {
    pub fn granite_widgets_thin_paned_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_sidebar_paned_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_sidebar_paned_new()
     -> *mut GraniteWidgetsSidebarPaned;
}
extern "C" {
    pub fn granite_widgets_sidebar_paned_construct(object_type: GType)
     -> *mut GraniteWidgetsSidebarPaned;
}
extern "C" {
    pub fn granite_widgets_storage_bar_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_storage_bar_item_description_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_storage_bar_item_description_get_class(description:
                                                                      GraniteWidgetsStorageBarItemDescription)
     -> *mut gchar;
}
extern "C" {
    pub fn granite_widgets_storage_bar_item_description_get_name(description:
                                                                     GraniteWidgetsStorageBarItemDescription)
     -> *mut gchar;
}
extern "C" {
    pub fn granite_widgets_storage_bar_new(storage: guint64)
     -> *mut GraniteWidgetsStorageBar;
}
extern "C" {
    pub fn granite_widgets_storage_bar_construct(object_type: GType,
                                                 storage: guint64)
     -> *mut GraniteWidgetsStorageBar;
}
extern "C" {
    pub fn granite_widgets_storage_bar_new_with_total_usage(storage: guint64,
                                                            total_usage:
                                                                guint64)
     -> *mut GraniteWidgetsStorageBar;
}
extern "C" {
    pub fn granite_widgets_storage_bar_construct_with_total_usage(object_type:
                                                                      GType,
                                                                  storage:
                                                                      guint64,
                                                                  total_usage:
                                                                      guint64)
     -> *mut GraniteWidgetsStorageBar;
}
extern "C" {
    pub fn granite_widgets_storage_bar_update_block_size(self_:
                                                             *mut GraniteWidgetsStorageBar,
                                                         description:
                                                             GraniteWidgetsStorageBarItemDescription,
                                                         size: guint64);
}
extern "C" {
    pub fn granite_widgets_storage_bar_get_storage(self_:
                                                       *mut GraniteWidgetsStorageBar)
     -> guint64;
}
extern "C" {
    pub fn granite_widgets_storage_bar_set_storage(self_:
                                                       *mut GraniteWidgetsStorageBar,
                                                   value: guint64);
}
extern "C" {
    pub fn granite_widgets_storage_bar_get_total_usage(self_:
                                                           *mut GraniteWidgetsStorageBar)
     -> guint64;
}
extern "C" {
    pub fn granite_widgets_storage_bar_set_total_usage(self_:
                                                           *mut GraniteWidgetsStorageBar,
                                                       value: guint64);
}
extern "C" {
    pub fn granite_widgets_storage_bar_get_inner_margin_sides(self_:
                                                                  *mut GraniteWidgetsStorageBar)
     -> gint;
}
extern "C" {
    pub fn granite_widgets_storage_bar_set_inner_margin_sides(self_:
                                                                  *mut GraniteWidgetsStorageBar,
                                                              value: gint);
}
extern "C" {
    pub fn granite_widgets_source_list_item_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_source_list_expandable_item_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_source_list_sortable_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_source_list_sortable_allow_dnd_sorting(self_:
                                                                      *mut GraniteWidgetsSourceListSortable)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_source_list_sortable_compare(self_:
                                                            *mut GraniteWidgetsSourceListSortable,
                                                        a:
                                                            *mut GraniteWidgetsSourceListItem,
                                                        b:
                                                            *mut GraniteWidgetsSourceListItem)
     -> gint;
}
extern "C" {
    pub fn granite_widgets_source_list_drag_source_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_source_list_drag_source_draggable(self_:
                                                                 *mut GraniteWidgetsSourceListDragSource)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_source_list_drag_source_prepare_selection_data(self_:
                                                                              *mut GraniteWidgetsSourceListDragSource,
                                                                          selection_data:
                                                                              *mut GtkSelectionData);
}
extern "C" {
    pub fn granite_widgets_source_list_drag_dest_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_source_list_drag_dest_data_drop_possible(self_:
                                                                        *mut GraniteWidgetsSourceListDragDest,
                                                                    context:
                                                                        *mut GdkDragContext,
                                                                    data:
                                                                        *mut GtkSelectionData)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_source_list_drag_dest_data_received(self_:
                                                                   *mut GraniteWidgetsSourceListDragDest,
                                                               context:
                                                                   *mut GdkDragContext,
                                                               data:
                                                                   *mut GtkSelectionData)
     -> GdkDragAction;
}
extern "C" {
    pub fn granite_widgets_source_list_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_source_list_new(root:
                                               *mut GraniteWidgetsSourceListExpandableItem)
     -> *mut GraniteWidgetsSourceList;
}
extern "C" {
    pub fn granite_widgets_source_list_construct(object_type: GType,
                                                 root:
                                                     *mut GraniteWidgetsSourceListExpandableItem)
     -> *mut GraniteWidgetsSourceList;
}
extern "C" {
    pub fn granite_widgets_source_list_has_item(self_:
                                                    *mut GraniteWidgetsSourceList,
                                                item:
                                                    *mut GraniteWidgetsSourceListItem)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_source_list_set_sort_func(self_:
                                                         *mut GraniteWidgetsSourceList,
                                                     sort_func:
                                                         GraniteWidgetsSourceListSortFunc,
                                                     sort_func_target:
                                                         *mut ::std::os::raw::c_void,
                                                     sort_func_target_destroy_notify:
                                                         GDestroyNotify);
}
extern "C" {
    pub fn granite_widgets_source_list_set_filter_func(self_:
                                                           *mut GraniteWidgetsSourceList,
                                                       visible_func:
                                                           GraniteWidgetsSourceListVisibleFunc,
                                                       visible_func_target:
                                                           *mut ::std::os::raw::c_void,
                                                       refilter: gboolean);
}
extern "C" {
    pub fn granite_widgets_source_list_refilter(self_:
                                                    *mut GraniteWidgetsSourceList);
}
extern "C" {
    pub fn granite_widgets_source_list_is_item_expanded(self_:
                                                            *mut GraniteWidgetsSourceList,
                                                        item:
                                                            *mut GraniteWidgetsSourceListItem)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_source_list_start_editing_item(self_:
                                                              *mut GraniteWidgetsSourceList,
                                                          item:
                                                              *mut GraniteWidgetsSourceListItem)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_source_list_stop_editing(self_:
                                                        *mut GraniteWidgetsSourceList);
}
extern "C" {
    pub fn granite_widgets_source_list_enable_drag_source(self_:
                                                              *mut GraniteWidgetsSourceList,
                                                          src_entries:
                                                              *mut GtkTargetEntry,
                                                          src_entries_length1:
                                                              ::std::os::raw::c_int);
}
extern "C" {
    pub fn granite_widgets_source_list_disable_drag_source(self_:
                                                               *mut GraniteWidgetsSourceList);
}
extern "C" {
    pub fn granite_widgets_source_list_enable_drag_dest(self_:
                                                            *mut GraniteWidgetsSourceList,
                                                        dest_entries:
                                                            *mut GtkTargetEntry,
                                                        dest_entries_length1:
                                                            ::std::os::raw::c_int,
                                                        actions:
                                                            GdkDragAction);
}
extern "C" {
    pub fn granite_widgets_source_list_disable_drag_dest(self_:
                                                             *mut GraniteWidgetsSourceList);
}
extern "C" {
    pub fn granite_widgets_source_list_scroll_to_item(self_:
                                                          *mut GraniteWidgetsSourceList,
                                                      item:
                                                          *mut GraniteWidgetsSourceListItem,
                                                      expand_parents:
                                                          gboolean,
                                                      use_align: gboolean,
                                                      row_align: gfloat)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_source_list_get_previous_item(self_:
                                                             *mut GraniteWidgetsSourceList,
                                                         reference:
                                                             *mut GraniteWidgetsSourceListItem)
     -> *mut GraniteWidgetsSourceListItem;
}
extern "C" {
    pub fn granite_widgets_source_list_get_next_item(self_:
                                                         *mut GraniteWidgetsSourceList,
                                                     reference:
                                                         *mut GraniteWidgetsSourceListItem)
     -> *mut GraniteWidgetsSourceListItem;
}
extern "C" {
    pub fn granite_widgets_source_list_get_first_child(self_:
                                                           *mut GraniteWidgetsSourceList,
                                                       parent:
                                                           *mut GraniteWidgetsSourceListExpandableItem)
     -> *mut GraniteWidgetsSourceListItem;
}
extern "C" {
    pub fn granite_widgets_source_list_get_last_child(self_:
                                                          *mut GraniteWidgetsSourceList,
                                                      parent:
                                                          *mut GraniteWidgetsSourceListExpandableItem)
     -> *mut GraniteWidgetsSourceListItem;
}
extern "C" {
    pub fn granite_widgets_source_list_get_n_visible_children(self_:
                                                                  *mut GraniteWidgetsSourceList,
                                                              parent:
                                                                  *mut GraniteWidgetsSourceListExpandableItem)
     -> guint;
}
extern "C" {
    pub fn granite_widgets_source_list_get_root(self_:
                                                    *mut GraniteWidgetsSourceList)
     -> *mut GraniteWidgetsSourceListExpandableItem;
}
extern "C" {
    pub fn granite_widgets_source_list_set_root(self_:
                                                    *mut GraniteWidgetsSourceList,
                                                value:
                                                    *mut GraniteWidgetsSourceListExpandableItem);
}
extern "C" {
    pub fn granite_widgets_source_list_get_selected(self_:
                                                        *mut GraniteWidgetsSourceList)
     -> *mut GraniteWidgetsSourceListItem;
}
extern "C" {
    pub fn granite_widgets_source_list_set_selected(self_:
                                                        *mut GraniteWidgetsSourceList,
                                                    value:
                                                        *mut GraniteWidgetsSourceListItem);
}
extern "C" {
    pub fn granite_widgets_source_list_get_ellipsize_mode(self_:
                                                              *mut GraniteWidgetsSourceList)
     -> PangoEllipsizeMode;
}
extern "C" {
    pub fn granite_widgets_source_list_set_ellipsize_mode(self_:
                                                              *mut GraniteWidgetsSourceList,
                                                          value:
                                                              PangoEllipsizeMode);
}
extern "C" {
    pub fn granite_widgets_source_list_get_editing(self_:
                                                       *mut GraniteWidgetsSourceList)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_source_list_get_sort_direction(self_:
                                                              *mut GraniteWidgetsSourceList)
     -> GtkSortType;
}
extern "C" {
    pub fn granite_widgets_source_list_set_sort_direction(self_:
                                                              *mut GraniteWidgetsSourceList,
                                                          value: GtkSortType);
}
extern "C" {
    pub fn granite_widgets_source_list_item_new(name: *const gchar)
     -> *mut GraniteWidgetsSourceListItem;
}
extern "C" {
    pub fn granite_widgets_source_list_item_construct(object_type: GType,
                                                      name: *const gchar)
     -> *mut GraniteWidgetsSourceListItem;
}
extern "C" {
    pub fn granite_widgets_source_list_item_get_context_menu(self_:
                                                                 *mut GraniteWidgetsSourceListItem)
     -> *mut GtkMenu;
}
extern "C" {
    pub fn granite_widgets_source_list_item_get_parent(self_:
                                                           *mut GraniteWidgetsSourceListItem)
     -> *mut GraniteWidgetsSourceListExpandableItem;
}
extern "C" {
    pub fn granite_widgets_source_list_item_get_name(self_:
                                                         *mut GraniteWidgetsSourceListItem)
     -> *const gchar;
}
extern "C" {
    pub fn granite_widgets_source_list_item_set_name(self_:
                                                         *mut GraniteWidgetsSourceListItem,
                                                     value: *const gchar);
}
extern "C" {
    pub fn granite_widgets_source_list_item_get_badge(self_:
                                                          *mut GraniteWidgetsSourceListItem)
     -> *const gchar;
}
extern "C" {
    pub fn granite_widgets_source_list_item_set_badge(self_:
                                                          *mut GraniteWidgetsSourceListItem,
                                                      value: *const gchar);
}
extern "C" {
    pub fn granite_widgets_source_list_item_get_editable(self_:
                                                             *mut GraniteWidgetsSourceListItem)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_source_list_item_set_editable(self_:
                                                             *mut GraniteWidgetsSourceListItem,
                                                         value: gboolean);
}
extern "C" {
    pub fn granite_widgets_source_list_item_get_visible(self_:
                                                            *mut GraniteWidgetsSourceListItem)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_source_list_item_set_visible(self_:
                                                            *mut GraniteWidgetsSourceListItem,
                                                        value: gboolean);
}
extern "C" {
    pub fn granite_widgets_source_list_item_get_selectable(self_:
                                                               *mut GraniteWidgetsSourceListItem)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_source_list_item_set_selectable(self_:
                                                               *mut GraniteWidgetsSourceListItem,
                                                           value: gboolean);
}
extern "C" {
    pub fn granite_widgets_source_list_item_get_icon(self_:
                                                         *mut GraniteWidgetsSourceListItem)
     -> *mut GIcon;
}
extern "C" {
    pub fn granite_widgets_source_list_item_set_icon(self_:
                                                         *mut GraniteWidgetsSourceListItem,
                                                     value: *mut GIcon);
}
extern "C" {
    pub fn granite_widgets_source_list_item_get_activatable(self_:
                                                                *mut GraniteWidgetsSourceListItem)
     -> *mut GIcon;
}
extern "C" {
    pub fn granite_widgets_source_list_item_set_activatable(self_:
                                                                *mut GraniteWidgetsSourceListItem,
                                                            value:
                                                                *mut GIcon);
}
extern "C" {
    pub fn granite_widgets_source_list_expandable_item_new(name: *const gchar)
     -> *mut GraniteWidgetsSourceListExpandableItem;
}
extern "C" {
    pub fn granite_widgets_source_list_expandable_item_construct(object_type:
                                                                     GType,
                                                                 name:
                                                                     *const gchar)
     -> *mut GraniteWidgetsSourceListExpandableItem;
}
extern "C" {
    pub fn granite_widgets_source_list_expandable_item_contains(self_:
                                                                    *mut GraniteWidgetsSourceListExpandableItem,
                                                                item:
                                                                    *mut GraniteWidgetsSourceListItem)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_source_list_expandable_item_add(self_:
                                                               *mut GraniteWidgetsSourceListExpandableItem,
                                                           item:
                                                               *mut GraniteWidgetsSourceListItem);
}
extern "C" {
    pub fn granite_widgets_source_list_expandable_item_remove(self_:
                                                                  *mut GraniteWidgetsSourceListExpandableItem,
                                                              item:
                                                                  *mut GraniteWidgetsSourceListItem);
}
extern "C" {
    pub fn granite_widgets_source_list_expandable_item_clear(self_:
                                                                 *mut GraniteWidgetsSourceListExpandableItem);
}
extern "C" {
    pub fn granite_widgets_source_list_expandable_item_expand_all(self_:
                                                                      *mut GraniteWidgetsSourceListExpandableItem,
                                                                  inclusive:
                                                                      gboolean,
                                                                  recursive:
                                                                      gboolean);
}
extern "C" {
    pub fn granite_widgets_source_list_expandable_item_collapse_all(self_:
                                                                        *mut GraniteWidgetsSourceListExpandableItem,
                                                                    inclusive:
                                                                        gboolean,
                                                                    recursive:
                                                                        gboolean);
}
extern "C" {
    pub fn granite_widgets_source_list_expandable_item_expand_with_parents(self_:
                                                                               *mut GraniteWidgetsSourceListExpandableItem);
}
extern "C" {
    pub fn granite_widgets_source_list_expandable_item_collapse_with_parents(self_:
                                                                                 *mut GraniteWidgetsSourceListExpandableItem);
}
extern "C" {
    pub fn granite_widgets_source_list_expandable_item_get_collapsible(self_:
                                                                           *mut GraniteWidgetsSourceListExpandableItem)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_source_list_expandable_item_set_collapsible(self_:
                                                                           *mut GraniteWidgetsSourceListExpandableItem,
                                                                       value:
                                                                           gboolean);
}
extern "C" {
    pub fn granite_widgets_source_list_expandable_item_get_expanded(self_:
                                                                        *mut GraniteWidgetsSourceListExpandableItem)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_source_list_expandable_item_set_expanded(self_:
                                                                        *mut GraniteWidgetsSourceListExpandableItem,
                                                                    value:
                                                                        gboolean);
}
extern "C" {
    pub fn granite_widgets_source_list_expandable_item_get_n_children(self_:
                                                                          *mut GraniteWidgetsSourceListExpandableItem)
     -> guint;
}
extern "C" {
    pub fn granite_widgets_source_list_expandable_item_get_children(self_:
                                                                        *mut GraniteWidgetsSourceListExpandableItem)
     -> *mut GeeCollection;
}
extern "C" {
    pub fn granite_widgets_cell_renderer_expander_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_cell_renderer_expander_new()
     -> *mut GraniteWidgetsCellRendererExpander;
}
extern "C" {
    pub fn granite_widgets_cell_renderer_expander_construct(object_type:
                                                                GType)
     -> *mut GraniteWidgetsCellRendererExpander;
}
extern "C" {
    pub fn granite_widgets_cell_renderer_expander_get_arrow_size(self_:
                                                                     *mut GraniteWidgetsCellRendererExpander,
                                                                 widget:
                                                                     *mut GtkWidget)
     -> gint;
}
extern "C" {
    pub fn granite_widgets_cell_renderer_expander_get_is_category_expander(self_:
                                                                               *mut GraniteWidgetsCellRendererExpander)
     -> gboolean;
}
extern "C" {
    pub fn granite_widgets_cell_renderer_expander_set_is_category_expander(self_:
                                                                               *mut GraniteWidgetsCellRendererExpander,
                                                                           value:
                                                                               gboolean);
}
extern "C" {
    pub fn granite_widgets_cell_renderer_badge_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_cell_renderer_badge_new()
     -> *mut GraniteWidgetsCellRendererBadge;
}
extern "C" {
    pub fn granite_widgets_cell_renderer_badge_construct(object_type: GType)
     -> *mut GraniteWidgetsCellRendererBadge;
}
extern "C" {
    pub fn granite_widgets_cell_renderer_badge_get_text(self_:
                                                            *mut GraniteWidgetsCellRendererBadge)
     -> *const gchar;
}
extern "C" {
    pub fn granite_widgets_cell_renderer_badge_set_text(self_:
                                                            *mut GraniteWidgetsCellRendererBadge,
                                                        value: *const gchar);
}
extern "C" {
    pub fn granite_widgets_thin_paned_new(orientation: GtkOrientation)
     -> *mut GraniteWidgetsThinPaned;
}
extern "C" {
    pub fn granite_widgets_thin_paned_construct(object_type: GType,
                                                orientation: GtkOrientation)
     -> *mut GraniteWidgetsThinPaned;
}
extern "C" {
    pub fn granite_widgets_thin_paned_get_overlay_handle_window(self_:
                                                                    *mut GraniteWidgetsThinPaned)
     -> *mut GdkWindow;
}
extern "C" {
    pub fn granite_widgets_overlay_bar_get_type() -> GType;
}
extern "C" {
    pub fn granite_widgets_overlay_bar_new(overlay: *mut GtkOverlay)
     -> *mut GraniteWidgetsOverlayBar;
}
extern "C" {
    pub fn granite_widgets_overlay_bar_construct(object_type: GType,
                                                 overlay: *mut GtkOverlay)
     -> *mut GraniteWidgetsOverlayBar;
}
extern "C" {
    pub fn granite_widgets_overlay_bar_get_status(self_:
                                                      *mut GraniteWidgetsOverlayBar)
     -> *const gchar;
}
extern "C" {
    pub fn granite_widgets_overlay_bar_set_status(self_:
                                                      *mut GraniteWidgetsOverlayBar,
                                                  value: *const gchar);
}
